/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/AppMap.js":
/*!*******************************!*\
  !*** ./src/scripts/AppMap.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('AppMap', [\r\n  'Map', \r\n  'control.ZoomControl', \r\n  'Constant'  \r\n],\r\nfunction(provide, Map, ZoomControl, Constant) {\r\n  \r\n  class AppMap extends Map {\r\n    /**\r\n     * @param {number[]} center \r\n     * @param {numner} zoom\r\n     */\r\n    constructor() {\r\n\r\n      // Array of Dropzones and their coordinates.\r\n      var dz = [\r\n        {name: \"Коломна\", mapCenter: [55.091289443603706, 38.917269584802675]}, \r\n        {name: \"Пущино\", mapCenter: [54.78929269708931,37.64268598670033]}, \r\n        {name: \"Ватулино\", mapCenter: [55.663193308717396,36.14121807608322]}\r\n      ];    \r\n        \r\n      super(\"map\", {\r\n        center: dz[0].mapCenter,    \r\n        zoom: Constant.defaultZoom\r\n      }, {\r\n        suppressMapOpenBlock: true  // remove button 'open in yandex maps'\r\n      });\r\n      \r\n      this.dz = dz; \r\n \r\n      this.setType(\"yandex#satellite\");  // view from space    \r\n      this.cursors.push('arrow');  \r\n      this.controls.remove('trafficControl');  \r\n      this.controls.remove('zoomControl');\r\n      var zoomControl = new ZoomControl({options: { \r\n        position: { right: 10, top: 105 }, \r\n        size: 'small'\r\n      }}); \r\n      this.controls.add(zoomControl);\r\n      this.controls.remove('geolocationControl');\r\n      this.controls.remove('fullscreenControl');   \r\n       \r\n      this.searchControl = this.controls.get('searchControl');\r\n      this.searchControl.options.set('size', 'small');\r\n      this.searchControl.options.set('noPlacemark', true);\r\n      this.searchControl.options.set('noSelect', true);\r\n\r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.preventDefault();  \r\n      });     \r\n    }\r\n    \r\n    \r\n    setSearchProcessor(path, calculator, windList) {\r\n      \r\n      this.path = path;\r\n      this.heightOutput = path.heightOutput;\r\n      this.calculator = calculator;\r\n      this.wind = windList.currentWind;\r\n      this.defaultZoom = Constant.defaultZoom;\r\n      \r\n      this.searchControl.events.add('resultshow', function(e) {\r\n                \r\n        this.path.clear();\r\n        this.heightOutput.print([this.calculator.getStartHeight()]);\r\n         \r\n        this.setZoom(this.defaultZoom);\r\n         \r\n        this.wind.arrow.setCoordinates(this.getCenter());\r\n         \r\n        var index = e.get('index');    \r\n        var geoObjectsArray = this.searchControl.getResultsArray();\r\n        var resultName = geoObjectsArray[index].properties.get('name');\r\n\r\n        var newDz = {\r\n          name: resultName, \r\n          mapCenter: this.getCenter()\r\n        };    \r\n        this.dz.push(newDz);    \r\n        $(\"#dz\").append(\"<option>\" + newDz.name + \"</option>\");    \r\n        $(\"#dz\").children()[this.dz.length - 1].selected = true;    \r\n      }.bind(this));      \r\n    }\r\n        \r\n  } \r\n  provide(AppMap);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/AppMap.js?");

/***/ }),

/***/ "./src/scripts/Arrow.js":
/*!******************************!*\
  !*** ./src/scripts/Arrow.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Arrow */\r\nymaps.modules.define('Arrow', [\r\n  'Placemark',\r\n  'templateLayoutFactory', \r\n  'Constant'  \r\n],\r\nfunction(provide, Placemark, templateLayoutFactory, Constant) {\r\n  \r\n  /**\r\n   * Yandex Maps Placemark for Wind Arrow. \r\n   */\r\n  class Arrow extends Placemark {\r\n\r\n    constructor() {      \r\n      var arrowStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var arrowStartRadius = Constant.isMobile ? arrowStartSize : arrowStartSize/2; \r\n      \r\n      super(\r\n        //map.getCenter(),\r\n        [],        \r\n        {\r\n          arrowClass: \"arrow_selected\",  \r\n          //rotation: 90,\r\n          rotation: 0,           \r\n          size: arrowStartSize\r\n        }, \r\n        {\r\n          draggable: true,\r\n          iconLayout: templateLayoutFactory.createClass(\r\n              '<div class=\"$[properties.arrowClass]\" style=\"transform: rotate($[properties.rotation]deg);' + \r\n              'width: $[properties.size]px; height: $[properties.size]px;\"/>'\r\n            ), \r\n          iconShape: {\r\n            type: 'Circle',\r\n            coordinates: [arrowStartSize/2, arrowStartSize/2],\r\n            radius: arrowStartRadius\r\n          }          \r\n        }\r\n      );\r\n                    \r\n      this.arrowStartSize = arrowStartSize;\r\n      this.arrowStartRadius = arrowStartRadius;   \r\n      \r\n      this.heightPlacemarkShift = 0.0001;\r\n      \r\n      //var point = this.geometry.getCoordinates();\r\n      \r\n      // Placemark for Height of Chute at this vertex\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        //[point[0] + this.heightPlacemarkShift, point[1]],\r\n        [],         \r\n        {}, \r\n        {\r\n          preset: 'islands#darkOrangeStretchyIcon', \r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n    \r\n      //this.placemarkIsOn = true;    \r\n      this.isSelected = false;\r\n      this.isScaled = true;\r\n            \r\n      // when we drag arrow, we should drag its heightPlacemark too\r\n      this.events.add('drag', function(e) {\r\n        e.stopPropagation();\r\n        var newPoint = this.geometry.getCoordinates();       \r\n        this.heightPlacemark.geometry.setCoordinates(\r\n          [newPoint[0] + this.heightPlacemarkShift, newPoint[1]]\r\n        );          \r\n      }.bind(this)); \r\n            \r\n      this.map = null;\r\n\r\n      this.boundChange = this.boundChange.bind(this);\r\n            \r\n    }\r\n\r\n    \r\n    setCoordinates(coordinates) {\r\n      this.geometry.setCoordinates(coordinates);\r\n      this.heightPlacemark.geometry.setCoordinates(\r\n        [coordinates[0] + this.heightPlacemarkShift, coordinates[1]]\r\n      );      \r\n    }\r\n   \r\n   /**\r\n    * Change arrow selection\r\n    * @param {boolean || null} - isSelected    \r\n    */   \r\n    setSelection(isSelected = null) {\r\n\r\n      this.isSelected = (isSelected == null) ? \r\n        !this.isSelected : isSelected; \r\n      \r\n      var arrowClass = this.isSelected ? 'arrow_selected' : 'arrow';      \r\n      this.properties.set('arrowClass', arrowClass);   \r\n    }\r\n\r\n    getSelection() {\r\n      return(this.isSelected);\r\n    }    \r\n                 \r\n   /**\r\n    * Rotate arrow\r\n    */\r\n    rotate(angle) {\r\n      //this.properties.set('rotation', (-1)*angle + 90);\r\n      this.properties.set('rotation', (-1)*angle);      \r\n    }\r\n    \r\n    /**\r\n     * Arrow will have different size for different Zoom.\r\n     */\r\n    changeSize(newZoom) {\r\n      var size = (2**(newZoom - Constant.defaultZoom))*(this.arrowStartSize);\r\n      \r\n      var shape = \r\n        {\r\n          type: 'Circle',\r\n          coordinates: [size/2, size/2],\r\n          radius: (2**(newZoom - Constant.defaultZoom))*(this.arrowStartRadius)\r\n        };\r\n      \r\n      this.options.set('iconShape', shape);      \r\n      this.properties.set('size', size);\r\n      // properties.set call rebuild of Placemark, \r\n      // so, properties.set should stay after options.set      \r\n    }\r\n    \r\n    \r\n    addToMap(map, coordinates = null) {\r\n      this.map = map;\r\n      map.geoObjects.add(this);\r\n      \r\n      map.geoObjects.add(this.heightPlacemark);\r\n            \r\n      if (coordinates == null) {\r\n        var e = 0.005;\r\n        var mapCenter = map.getCenter();\r\n        var dlatitude = \r\n          (Math.random() - 0.5) * e * Math.cos((Math.PI/180) * mapCenter[0]);\r\n        var dlongtitude = (Math.random() - 0.5) * e;  \r\n        coordinates = mapCenter;\r\n        coordinates[0] += dlatitude;\r\n        coordinates[1] += dlongtitude;\r\n      }\r\n\r\n      this.setCoordinates(coordinates);\r\n      \r\n      this.setArrowToBeScaled(true);      \r\n    }\r\n    \r\n    removeFromMap(map) {\r\n      map.geoObjects.remove(this);\r\n      map.geoObjects.remove(this.heightPlacemark);         \r\n    }\r\n    \r\n    \r\n    addPlacemark() {\r\n      this.map.geoObjects.add(this.heightPlacemark);      \r\n    } \r\n    \r\n    \r\n    removePlacemark() {\r\n      this.map.geoObjects.remove(this.heightPlacemark);      \r\n    } \r\n\r\n       \r\n    /**\r\n     * Set arrow to be scaled with map zooming or \r\n     * not to be scaled. Map should be defined. \r\n     * @param {boolean} arrowIsScaled\r\n     */     \r\n    setArrowToBeScaled(arrowIsScaled) {\r\n      \r\n      this.isScaled = arrowIsScaled;\r\n    \r\n      if (arrowIsScaled) {\r\n        this.map.events.add('boundschange', this.boundChange);\r\n        var zoom = this.map.getZoom();\r\n        this.changeSize(zoom);\r\n                \r\n      } else {\r\n        this.map.events.remove('boundschange', this.boundChange); \r\n        this.changeSize(Constant.defaultZoom);       \r\n      }       \r\n    }\r\n    \r\n    getIsScaled() {\r\n      return(this.isScaled);\r\n    }\r\n    \r\n    /**\r\n     * Event function for boundChange event from \r\n     * this.setArrowToBeScaled function.\r\n     * @param {Event} e     \r\n     */\r\n    boundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        this.changeSize(newZoom);\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    print(str) {\r\n      this.heightPlacemark.properties.set(\"iconContent\", str);           \r\n    }\r\n    \r\n  }\r\n\r\n  provide(Arrow);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/Arrow.js?");

/***/ }),

/***/ "./src/scripts/Calculator.js":
/*!***********************************!*\
  !*** ./src/scripts/Calculator.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Calculator */\r\nymaps.modules.define('Calculator', [\r\n  'VectorMath', \r\n  'Circle', \r\n  'Constant'\r\n],\r\nfunction(provide, VectorMath, Circle, Constant) {\r\n  /**\r\n   * This class calculates heights at all vertices of path.  \r\n   */\r\n  class Calculator {\r\n    /**\r\n     * If path.getPathDirection() == true (that is, we add vertices \r\n     * to the last vertex), then calculator begins computation \r\n     * from first vertex and boundaryHeights.startHeight height; \r\n     * if path.getPathDirection() == false (that is, we add vertices \r\n     * to first vertex), then calculator begins computation \r\n     * from last vertex and boundaryHeights.finalHeight height.\r\n     * @param {Path} path - list of vertices and edges of Chute Path.\r\n     * @param {Chute} chute - Chute velocity.     \r\n     * @param {WindList} windList \r\n     * @param {Object} boundaryHeights\r\n     * @param {number} boundaryHeights.startHeight - Default Start height of chute, in meters;\r\n     * it is used for Direct computation (from start vertex to final vertex of the path).\r\n     * @param {number} boundaryHeights.finalHeight - Default Final Height; it is used for \r\n     * Back computation (from final vertex to start vertex of the path).\r\n     */\r\n    constructor(path, chute, windList, boundaryHeights) {            \r\n      this.path = path;\r\n      this.chute = chute;\r\n      this.windList = windList;      \r\n      this.boundaryHeights = boundaryHeights;\r\n                      \r\n      // Array of heights in all vertices of path.\r\n      this.height = [];        \r\n    }\r\n     \r\n\r\n    getHeight() {\r\n      return(this.height);\r\n    }\r\n\r\n    /**\r\n     * Condition for using this function: path.length > 0\r\n     */\r\n    calculateHeight() {      \r\n      if (this.path.getPathDirection()) {\r\n        this.calculateHeightForward()\r\n      } else {\r\n        this.calculateHeightBack();\r\n      }                  \r\n    }\r\n\r\n\r\n    calculateHeightForward() {\r\n                 \r\n      if (this.path.length < 2) {\r\n        this.height = [this.boundaryHeights.startHeight];\r\n        return;\r\n      } \r\n\r\n      var height = [this.boundaryHeights.startHeight];\r\n        \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n                                  \r\n      var wind = windList.lastWind;\r\n      \r\n      // Skip winds without heights \r\n      while(wind.getHeight() == null) {\r\n        wind = wind.prevWind;\r\n      }\r\n      \r\n      // Skip to wind corresponding to first vertex      \r\n      while(wind != windList.firstWind && wind.getHeight() > height[0]) {\r\n        wind = wind.prevWind;\r\n      }\r\n      \r\n      var vertexA = path.firstVertex, \r\n          vertexB = vertexA.nextVertex;\r\n          \r\n      var pointA = vertexA.geometry.getCoordinates();\r\n      var pointB = vertexB.geometry.getCoordinates();\r\n\r\n      var heightIndex = 1;  // index for array height\r\n     \r\n      var pointAHeight = height[0];\r\n\r\n      \r\n      while(true) {\r\n                \r\n        console.log(\"wind height: \" + wind.getHeight());\r\n                                             \r\n        var edgeChuteVelocity = \r\n          this.calculateChuteEdgeVelocity(pointA, pointB, chute, wind); \r\n                    \r\n        console.log(\"edgeChuteVelocity: \" + edgeChuteVelocity);  \r\n          \r\n        if (edgeChuteVelocity < 0) {\r\n          // Case: impossible to fly this edge (and so, this path)          \r\n          for(var j = heightIndex; j < path.length; j++) {\r\n            height[j] = null;\r\n          } \r\n          break;\r\n        } \r\n        \r\n        if (edgeChuteVelocity == 0) {\r\n          // Case: chute is hanging above pointA\r\n          if (wind == windList.firstWind) {\r\n            // Case of firstWind: it is impossible to fly such path           \r\n            for(var j = heightIndex; j < path.length; j++) {\r\n              height[j] = null;\r\n            } \r\n            break;                        \r\n          } else {            \r\n            // This is bottom boundary of current wind\r\n            pointAHeight = wind.getHeight();                         \r\n            wind = wind.prevWind;            \r\n            continue;     \r\n          }         \r\n        }\r\n                             \r\n        if (edgeChuteVelocity > 0) {\r\n          \r\n          var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n          var t1 = dist / edgeChuteVelocity;\r\n          \r\n          \r\n          if (wind == windList.firstWind) {\r\n\r\n            if (t1 > Constant.maxFlightTime) {\r\n              for(var j = heightIndex; j < path.length; j++) {\r\n                height[j] = null;\r\n              } \r\n              break;\r\n            }\r\n            \r\n            pointAHeight -= t1 * this.chute.verticalVel;\r\n            \r\n            height[heightIndex] = pointAHeight;\r\n                             \r\n            if (vertexB == path.lastVertex) break;\r\n            \r\n            vertexA = vertexB;\r\n            vertexB = vertexA.nextVertex;\r\n            \r\n            pointA = vertexA.geometry.getCoordinates();\r\n            pointB = vertexB.geometry.getCoordinates();              \r\n\r\n            heightIndex++;\r\n            \r\n            continue;\r\n            \r\n          } else {  // wind != windList.firstWind\r\n                                     \r\n            var t2 = (pointAHeight - wind.getHeight()) / chute.verticalVel;\r\n                         \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, chute will reach pointB\r\n                            \r\n              if (t1 > Constant.maxFlightTime) {\r\n                for(var j = heightIndex; j < path.length; j++) {\r\n                  height[j] = null;\r\n                } \r\n                break;\r\n              }\r\n              \r\n              pointAHeight -= t1 * this.chute.verticalVel;\r\n              \r\n              height[heightIndex] = pointAHeight;\r\n                                 \r\n              if (vertexB == path.lastVertex) break;\r\n              \r\n              vertexA = vertexB;\r\n              vertexB = vertexA.nextVertex;\r\n              \r\n              pointA = vertexA.geometry.getCoordinates();\r\n              pointB = vertexB.geometry.getCoordinates();              \r\n                       \r\n              heightIndex++;    \r\n                          \r\n              continue;  \r\n            } else {\r\n              var v = VectorMath.subVectors(pointB, pointA);\r\n              \r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n              \r\n              v = VectorMath.multVectorConstant(v, (t2 * edgeChuteVelocity)/dist);\r\n                           \r\n              pointA = VectorMath.addVectors(pointA, v);\r\n              \r\n              pointAHeight -= t2 * this.chute.verticalVel;\r\n              \r\n              //this.path.map.geoObjects.remove(this.p);              \r\n              //this.p = new Circle([pointA, 10]);\r\n              //this.path.map.geoObjects.add(this.p);\r\n                                                        \r\n              wind = wind.prevWind;\r\n              \r\n              continue;\r\n            }     \r\n          }          \r\n        }                \r\n      }\r\n\r\n      this.boundaryHeights.finalHeight = height[height.length - 1];      \r\n      this.height = height;      \r\n      return;  \r\n    }\r\n    \r\n\r\n\r\n    \r\n    calculateHeightBack() {\r\n\r\n\r\n    \r\n      if (this.path.length < 2) {\r\n        this.height = [this.boundaryHeights.finalHeight];\r\n        return;\r\n      } \r\n\r\n      var height = [];\r\n\r\n      height[this.path.length - 1] = this.boundaryHeights.finalHeight;\r\n        \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n                                  \r\n      var wind = windList.firstWind;\r\n      \r\n      /*\r\n      // Skip winds without heights \r\n      while(wind.getHeight() == null) {\r\n        wind = wind.prevWind;\r\n      } */\r\n      \r\n      // Skip to wind corresponding to final vertex      \r\n      while(wind != windList.lastWind && \r\n            wind.getHeight() <= height[path.length-1]) {\r\n        wind = wind.nextWind;\r\n      }\r\n\r\n      if (wind != windList.firstWind) {\r\n        wind = wind.prevWind;\r\n      }\r\n            \r\n      var vertexB = path.lastVertex, \r\n          vertexA = vertexB.prevVertex;\r\n          \r\n      var pointB = vertexB.geometry.getCoordinates(),\r\n          pointA = vertexA.geometry.getCoordinates();\r\n\r\n      var heightIndex = path.length - 2;  // index for array height\r\n     \r\n      var pointAHeight = height[path.length - 1];\r\n\r\n      \r\n      while(true) {\r\n                \r\n        console.log(\"wind height: \" + wind.getHeight());\r\n                                             \r\n        var edgeChuteVelocity = \r\n          this.calculateChuteEdgeVelocity(pointA, pointB, chute, wind); \r\n                    \r\n        console.log(\"edgeChuteVelocity: \" + edgeChuteVelocity);  \r\n          \r\n        if (edgeChuteVelocity < 0) {\r\n          // Case: impossible to fly this edge (and so, this path)          \r\n          for(var j = heightIndex; j >= 0; j--) {\r\n            height[j] = null;\r\n          } \r\n          break;\r\n        } \r\n        \r\n        if (edgeChuteVelocity == 0) {\r\n          // Case: chute is hanging above pointA\r\n          if (wind == lastList.firstWind) {\r\n            // Case: it is impossible to fly such path           \r\n            for(var j = heightIndex; j >= 0; j--) {\r\n              height[j] = null;\r\n            } \r\n            break;                        \r\n          } else {            \r\n            // This is bottom boundary of current wind\r\n            pointAHeight = wind.getHeight();                         \r\n            wind = wind.prevWind;            \r\n            continue;     \r\n          }         \r\n        }\r\n                             \r\n        if (edgeChuteVelocity > 0) {\r\n          \r\n          var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n          var t1 = dist / edgeChuteVelocity;\r\n          \r\n          \r\n          if (wind == windList.firstWind) {\r\n\r\n            if (t1 > Constant.maxFlightTime) {\r\n              for(var j = heightIndex; j < path.length; j++) {\r\n                height[j] = null;\r\n              } \r\n              break;\r\n            }\r\n            \r\n            pointAHeight -= t1 * this.chute.verticalVel;\r\n            \r\n            height[heightIndex] = pointAHeight;\r\n                             \r\n            if (vertexB == path.lastVertex) break;\r\n            \r\n            vertexA = vertexB;\r\n            vertexB = vertexA.nextVertex;\r\n            \r\n            pointA = vertexA.geometry.getCoordinates();\r\n            pointB = vertexB.geometry.getCoordinates();              \r\n\r\n            heightIndex++;\r\n            \r\n            continue;\r\n            \r\n          } else {  // wind != windList.firstWind\r\n                                     \r\n            var t2 = (pointAHeight - wind.getHeight()) / chute.verticalVel;\r\n                         \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, chute will reach pointB\r\n                            \r\n              if (t1 > Constant.maxFlightTime) {\r\n                for(var j = heightIndex; j < path.length; j++) {\r\n                  height[j] = null;\r\n                } \r\n                break;\r\n              }\r\n              \r\n              pointAHeight -= t1 * this.chute.verticalVel;\r\n              \r\n              height[heightIndex] = pointAHeight;\r\n                                 \r\n              if (vertexB == path.lastVertex) break;\r\n              \r\n              vertexA = vertexB;\r\n              vertexB = vertexA.nextVertex;\r\n              \r\n              pointA = vertexA.geometry.getCoordinates();\r\n              pointB = vertexB.geometry.getCoordinates();              \r\n                       \r\n              heightIndex++;    \r\n                          \r\n              continue;  \r\n            } else {\r\n              var v = VectorMath.subVectors(pointB, pointA);\r\n              \r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n              \r\n              v = VectorMath.multVectorConstant(v, (t2 * edgeChuteVelocity)/dist);\r\n                           \r\n              pointA = VectorMath.addVectors(pointA, v);\r\n              \r\n              pointAHeight -= t2 * this.chute.verticalVel;\r\n              \r\n              //this.path.map.geoObjects.remove(this.p);              \r\n              //this.p = new Circle([pointA, 10]);\r\n              //this.path.map.geoObjects.add(this.p);\r\n                                                        \r\n              wind = wind.prevWind;\r\n              \r\n              continue;\r\n            }     \r\n          }          \r\n        }                \r\n      }\r\n\r\n      this.boundaryHeights.finalHeight = height[height.length - 1];      \r\n      this.height = height;      \r\n      return;      \r\n\r\n    }\r\n\r\n    \r\n    \r\n\r\n    /** \r\n     * Calculate Absolute (relatively to Earth) Chute Velocity \r\n     * along Line Segment (we suppose that chute is flying along this line segment).\r\n     * @param {number[]} pointA - Yandex Maps Coordinates: (latitude, longitude).\r\n     * @param {number[]} pointB - Yandex Maps Coordinates: (latitude, longitude). \r\n     * @param {Chute} chute \r\n     * @param {Wind} wind     \r\n     * @return {number} chuteEdgeVelocity - Absolute Chute Velocity along \r\n     * line segment [pointA, pointB]; in m/sec; \r\n     * Cases: chuteEdgeVelocity < 0 - If it is impossible to fly this segment;\r\n     * chuteEdgeVelocity == 0 - hanging above pointA all time;    \r\n     * chuteEdgeVelocity > 0 - chute will fly from pointA to pointB.\r\n     */    \r\n    calculateChuteEdgeVelocity(pointA, pointB, chute, wind) {\r\n          \r\n      // Let's find right orthonormal basis (e, f), first vector of which (e)\r\n      // has the same direction with vector [pointA, pointB].      \r\n      // Yandex Maps Coordinates: (latitude, longitude)\r\n      // Latitude is increasing from bottom to top (-90deg, 90deg)\r\n      // Longitude is increasing from West to East (-180deg, 180deg)\r\n            \r\n      function sign(a) {\r\n        if (a>0) return 1;\r\n        if (a==0) return 0;\r\n        return -1;\r\n      }      \r\n      \r\n      var sx = sign(pointB[1] - pointA[1]);\r\n      var sy = sign(pointB[0] - pointA[0]);       \r\n    \r\n      var pointC = [pointA[0], pointB[1]];\r\n      \r\n      // now (ex, ey) are coordinates of vector e in standart orthonormal basis:\r\n      // x has direction from left to right, \r\n      // y has direction from bottom to top, \r\n      // scale: 1 meter\r\n      var ex = sx * ymaps.coordSystem.geo.getDistance(pointC, pointA);\r\n      var ey = sy * ymaps.coordSystem.geo.getDistance(pointC, pointB);\r\n                \r\n      var d = Math.sqrt(ex*ex + ey*ey);\r\n      ex = ex / d;\r\n      ey = ey / d;\r\n      \r\n      var fx = -ey;\r\n      var fy = ex;\r\n      \r\n      // Let's find coordinates (we, wf) of vector 'wind' in basis (e, f).\r\n      // (e, f) is orthogonal basis, so we = (wind, e), wf = (wind, f).\r\n      var [wx, wy] = wind.getXY();\r\n   \r\n      var we = wx * ex + wy * ey; \r\n      var wf = wx * fx + wy * fy;     \r\n       \r\n      // Let's find coordinates (ce, cf) of chute velocity \r\n      // in basis (e, f):\r\n      \r\n      var cf = (-1)*wf;\r\n      \r\n      // it is impossible to fly this segment\r\n      if (chute.horizontalVel < Math.abs(cf)) return(-1);\r\n  \r\n      var ce = Math.sqrt(chute.horizontalVel**2 - cf**2);\r\n      \r\n      // We consider only case, where ce >= 0 \r\n      // (it's always the case, if chute velocity is greater than wind velocity)    \r\n      // In general case you should consider case, \r\n      // when ce < 0 (case when diver flies forward with his back)   \r\n\r\n      var chuteEdgeVelocity = ce + we;\r\n      return(chuteEdgeVelocity);       \r\n    }\r\n   \r\n  }\r\n      \r\n  provide(Calculator);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Calculator.js?");

/***/ }),

/***/ "./src/scripts/Chute.js":
/*!******************************!*\
  !*** ./src/scripts/Chute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Chute', [],\r\nfunction(provide) {\r\n\r\n  class Chute {\r\n    /**\r\n     * @param {number} horizontalVel - Horizontal chute velocity, in m/sec.\r\n     * @param {number} verticalVel - Vertical chute velocity, in m/sec.     \r\n     */\r\n    constructor(horizontalVel, verticalVel) {\r\n      this.horizontalVel = horizontalVel; \r\n      this.verticalVel = verticalVel;   \r\n    }   \r\n  }\r\n      \r\n  provide(Chute);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Chute.js?");

/***/ }),

/***/ "./src/scripts/CircleVertex.js":
/*!*************************************!*\
  !*** ./src/scripts/CircleVertex.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('CircleVertex', [\r\n  'Circle'       \r\n],\r\nfunction(provide, Circle) {\r\n  \r\n  class CircleVertex extends Circle {\r\n    /**\r\n     * @param {number[]} center - Yandex.Maps coordinates.\r\n     * @param {number} radius\r\n     * @param {number} zIndex - z-index of Circle.     \r\n     */\r\n    constructor(center, radius, zIndex=0) {\r\n      super([center, radius]);\r\n      this.options.set(\"fillColor\", \"#0000FF\");\r\n      this.options.set(\"strokeColor\", \"#0000FF\");\r\n      this.options.set(\"zIndex\", zIndex);       \r\n    }\r\n  } \r\n  provide(CircleVertex);  \r\n});      \r\n      \n\n//# sourceURL=webpack:///./src/scripts/CircleVertex.js?");

/***/ }),

/***/ "./src/scripts/Constant.js":
/*!*********************************!*\
  !*** ./src/scripts/Constant.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Constant', [],\r\nfunction(provide) {\r\n\r\n// Determine mobile or desktop case.\r\nvar isMobile = false;\r\nif(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) { \r\n  isMobile = true;\r\n}\r\n\r\n  var Constant = {\r\n    defaultStartHeight: 300, \r\n    defaultFinalHeight: 0, \r\n    defaultZoom: 16,\r\n    // We will not consider cases when horizontal velocity \r\n    // is more than maxChuteHorizontalVelocity    \r\n    maxChuteHorizontalVelocity: 25, \r\n    maxChuteVerticalVelocity: 15, \r\n    maxHeight: 4000, \r\n    maxWindValue: 10,\r\n    // If we will fly more than maxFlightTime, then \r\n    // it is impossible to fly this path\r\n    maxFlightTime: 3600, // 1 hour    \r\n    isMobile: isMobile    \r\n  }\r\n      \r\n  provide(Constant);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Constant.js?");

/***/ }),

/***/ "./src/scripts/DialogWindows.js":
/*!**************************************!*\
  !*** ./src/scripts/DialogWindows.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('DialogWindows', [\r\n  'Output', \r\n  'Constant', \r\n  'Arrow'\r\n],\r\nfunction(\r\n  provide, \r\n  Output, \r\n  Constant, \r\n  Arrow  \r\n) {\r\n\r\n  var DialogWindows = {};\r\n  /**\r\n   * @param {AppMap} map\r\n   * @param {Path} path\r\n   * @param {HeightOutputElement} heightOutput\r\n   * @param {WindOutputElement} windOutput\r\n   * @param {Calculator} calculator\r\n   * @param {Chute} chute\r\n   * @param {Wind} wind \r\n   */\r\n  DialogWindows.initializeWindows = function (\r\n    map, \r\n    path, \r\n    //heightOutput, \r\n    //windOutput, \r\n    calculator, \r\n    chute, \r\n    windList, \r\n    boundaryHeights\r\n  ) {\r\n    \r\n    var wind = windList.currentWind;\r\n    \r\n\r\n    initSettingsWindow();\r\n    initChuteWindow();\r\n    initWindListWindow();\r\n    \r\n       \r\n    /**\r\n     * Settings (Dz and Start Height Window) initialization:\r\n     *   default options for <input> tags, \r\n     *   events 'change' for <input> tags.\r\n     */\r\n    function initSettingsWindow() {\r\n      // Set default options: dz array\r\n      for(var i=0; i<map.dz.length; i++) {\r\n        $(\"#dz\").append(\"<option>\" + map.dz[i].name + \"</option>\");    \r\n      }  \r\n      $(\"#dz\").on(\"change\", function() {\r\n        var mapCenter = map.dz[this.selectedIndex].mapCenter;      \r\n        map.setCenter(mapCenter, Constant.defaultZoom); \r\n        wind.arrow.setCoordinates(mapCenter);\r\n        //arrow.geometry.setCoordinates(mapCenter);\r\n        \r\n        // path.clear() will print results too\r\n        path.clear();\r\n      });\r\n      \r\n      //$(\"#startHeight\").val(Constant.defaultStartHeight);\r\n      \r\n      $(\"#startHeight\").val(boundaryHeights.startHeight);\r\n                        \r\n      $(\"#startHeight\").change(function () {       \r\n        var s = $(this).val();\r\n        var n = Number.parseFloat(s);\r\n        if ((n >= 0) && (n <= Constant.maxHeight)) {\r\n          //calculator.setStartHeight(n);      \r\n          //Constant.defaultStartHeight = n;\r\n          boundaryHeights.startHeight = n;\r\n          $(\"#startHeight\").val(n);  // if value was parsed hardly\r\n     \r\n          if (path.length > 0) {  \r\n            calculator.calculateHeight();   \r\n            Output.print(calculator, path);   \r\n          } else {\r\n            path.heightOutput.print(n);\r\n            boundaryHeights.finalHeight = n;\r\n            $(\"#finalHeight\").val(n);                     \r\n          }\r\n        } else {\r\n          $(\"#startHeight\").val(boundaryHeights.startHeight);\r\n        }\r\n      });\r\n\r\n      \r\n      //$(\"#finalHeight\").val(Constant.defaultStartHeight);\r\n\r\n      $(\"#finalHeight\").val(boundaryHeights.startHeight);\r\n      \r\n      $(\"#finalHeight\").prop(\"disabled\", true);\r\n      \r\n      $(\"#finalHeight\").change(function () {       \r\n        var s = $(this).val();\r\n        var n = Number.parseFloat(s);\r\n        if ((n >= 0) && (n <= Constant.maxHeight)) {\r\n          //calculator.setFinalHeight(n);      \r\n          //Constant.defaultFinalHeight = n;\r\n          boundaryHeights.finalHeight = n;\r\n          $(\"#finalHeight\").val(n);  // if value was parsed hardly\r\n          \r\n          if (path.length > 0) {\r\n            calculator.calculateHeight();   \r\n            Output.print(calculator, path);           \r\n          } else {\r\n            path.heightOutput.print(n);\r\n            boundaryHeights.startHeight = n;\r\n            $(\"#startHeight\").val(n);                     \r\n          }\r\n        } else {\r\n          $(\"#finalHeight\").val(boundaryHeights.finalHeight);\r\n        }    \r\n      });\r\n\r\n      \r\n      $(\"#pathDirection\").change(function() {\r\n        var isChecked = $(this).prop(\"checked\");\r\n\r\n        path.setPathDirection(!isChecked);\r\n        \r\n        $(\"#startHeight\").prop(\"disabled\", isChecked);\r\n        $(\"#finalHeight\").prop(\"disabled\", !isChecked);\r\n\r\n        \r\n        if (path.length > 0) {\r\n          if (path.getPathDirection()) {\r\n            if (boundaryHeights.startHeight == null) {\r\n              //calculator.setStartHeight(Constant.defaultStartHeight);\r\n              boundaryHeights.startHeight = Constant.defaultStartHeight;\r\n            }            \r\n          } else {\r\n            if (boundaryHeights.finalHeight == null) {\r\n              //calculator.setFinalHeight(Constant.defaultFinalHeight);\r\n              boundaryHeights.finalHeight = Constant.defaultFinalHeight;\r\n            }\r\n          }   \r\n          \r\n          calculator.calculateHeight();   \r\n          Output.print(calculator, path);           \r\n        } else { \r\n          /*\r\n          var out = path.getPathDirection() ? \r\n            //Constant.defaultStartHeight : Constant.defaultFinalHeight;      \r\n            boundaryHeights.startHeight : boundaryHeights.finalHeight; \r\n          \r\n          heightOutput.print(out);\r\n          $(\"#startHeight\").val(out);\r\n          $(\"#finalHeight\").val(out);  */\r\n          //calculator.setStartHeight(Constant.defaultStartHeight);\r\n          //calculator.setFinalHeight(Constant.defaultFinalHeight);\r\n          //calculator.setStartHeight(boundaryHeights.startHeight);\r\n          //alculator.setFinalHeight(boundaryHeights.finalHeight);   \r\n          \r\n        }                                 \r\n      });        \r\n    }    \r\n              \r\n    /** \r\n     * Chute Window initialization.\r\n     */\r\n    function initChuteWindow() {\r\n      $(\"#chutehorvel\").val(chute.horizontalVel);\r\n      $(\"#chutevervel\").val(chute.verticalVel);\r\n    \r\n      $(\"#chutehorvel, #chutevervel\").on(\"change\", function () {      \r\n        var chutehorvel = Number.parseFloat($(\"#chutehorvel\").val());\r\n        if ((chutehorvel>=0) && (chutehorvel<=Constant.maxChuteHorizontalVelocity)) {\r\n          chute.horizontalVel = chutehorvel;\r\n        }\r\n        $(\"chutehorvel\").val(chute.horizontalVel);\r\n              \r\n        var chutevervel = Number.parseFloat($(\"#chutevervel\").val());\r\n        if (( chutevervel>=0) && (chutevervel<=Constant.maxChuteVerticalVelocity)) {\r\n          chute.verticalVel = chutevervel;    \r\n        } \r\n        $(\"#chutevervel\").val(chute.verticalVel);        \r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();   \r\n          Output.print(calculator, path);    \r\n        }\r\n      });\r\n    }    \r\n\r\n    /** \r\n     * WindList Window initialization.\r\n     */    \r\n    function initWindListWindow() {\r\n      \r\n      $(\"#windValueInput\").prop(\"max\", \"\" + Constant.maxWindValue);\r\n        \r\n      windList.printCurrentWindWindow();      \r\n        \r\n      //initWindWindow();\r\n            \r\n      $(\"#windHeightInput\").on(\"change\", function() {        \r\n        // Remember that #windHeightInput is disabled for firstWind\r\n        \r\n        // If we jump to firstWind by use of Tab button (our app has such \r\n        // possibility), it will call windList.setHeightToCurrentWind (it will be error).\r\n        if (windList.currentWind == windList.firstWind) return;\r\n        \r\n        var s = $(\"#windHeightInput\").val();        \r\n        var n = Number.parseFloat(s);\r\n        \r\n        if ((n > 0) && (n <= Constant.maxHeight)) { \r\n          if (windList.setHeightToCurrentWind(n)) { \r\n            $(\"#windHeightInput\").val(n);\r\n          } else {\r\n            var v = windList.currentWind.getHeight();\r\n            var w = (v == null) ? '' : v;             \r\n            $(\"#windHeightInput\").val(w);\r\n            alert(\"Такая высота уже была!\");            \r\n          }            \r\n        } else {\r\n          var v = windList.currentWind.getHeight();\r\n          var w = (v == null) ? '' : v;             \r\n          $(\"#windHeightInput\").val(w);\r\n          alert(\"Значение не попадает в допустимый интервал!\");\r\n        } \r\n                        \r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();   \r\n          Output.print(calculator, path);\r\n        }        \r\n      });\r\n      \r\n                       \r\n      // Change Wind Direction in Wind Window.  \r\n      $(\"#windDirectionInput\").on('input change', function() {\r\n        var angleStr = $(\"#windDirectionInput\").val();          \r\n        var angle = Number.parseInt(angleStr);\r\n           \r\n        //windList.currentWind.setAngle(angle);\r\n        windList.setCurrentAngle(angle);\r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();   \r\n          Output.print(calculator, path);\r\n        }\r\n        \r\n        //windOutput.print(windList.currentWind);            \r\n      });\r\n\r\n      // Change Wind Value in Wind Window.   \r\n      $(\"#windValueInput\").on('input change', function() {\r\n        var valueStr = $(\"#windValueInput\").val();\r\n        var value = Number.parseInt(valueStr);\r\n\r\n        //windList.currentWind.setValue(value);\r\n        windList.setCurrentValue(value);\r\n        \r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();   \r\n          Output.print(calculator, path);\r\n        }\r\n        \r\n        //windOutput.print(windList.currentWind);        \r\n      });\r\n      \r\n      // Draw scales for Wind Window    \r\n      drawWindScales();\r\n      \r\n      /*      \r\n      $(\"#arrowScale\").prop(\"checked\", windList.firstWind.arrow.getIsScaled());\r\n      \r\n      $(\"#arrowScale\").change(function() {\r\n        var isChecked = $(this).prop(\"checked\");\r\n        windList.currentWind.arrow.setArrowToBeScaled(isChecked);               \r\n      });   */\r\n      \r\n      \r\n      function initWindWindow() {\r\n        if (windList.currentWind == windList.firstWind) {\r\n          $(\"#windHeightInput\").prop(\"disabled\", true);\r\n         // $(\"#removeWind\").prop(\"disabled\", true);          \r\n        } else {\r\n          $(\"#windHeightInput\").prop(\"disabled\", false);\r\n         // $(\"#removeWind\").prop(\"disabled\", false);\r\n        }\r\n        $(\"#windHeightInput\").val(windList.currentWind.getHeight());    \r\n        $(\"#windDirectionInput\").val(windList.currentWind.getAngle());\r\n        $(\"#windValueInput\").val(windList.currentWind.getValue());  \r\n        $(\"#arrowScale\").prop(\"checked\", windList.currentWind.arrow.getIsScaled());        \r\n      }                        \r\n    }\r\n   \r\n    /**\r\n     * Draw scales for Wind Window:\r\n     *   wind direction scale (E, N, W, S, E),\r\n     *   wind velocity scale (0, ..., 10 m/s)\r\n     */\r\n    function drawWindScales() {\r\n      // Create legend for direction range input\r\n      var directionPlateSpan = 5;\r\n      var directionPlateNumber = 4*directionPlateSpan + 1;\r\n\r\n      for(var i=0; i<directionPlateNumber; i++) {\r\n        var str = \"\";\r\n        switch (i) {\r\n          case 0: \r\n            str = \"В\";\r\n            break;\r\n          case directionPlateSpan: \r\n            str = \"С\";\r\n            break;\r\n          case directionPlateSpan*2: \r\n            str = \"З\";\r\n            break;      \r\n          case directionPlateSpan*3: \r\n            str = \"Ю\";\r\n            break;\r\n          case directionPlateSpan*4: \r\n            str = \"В\";\r\n            break;\r\n          default:\r\n            str = \"&nbsp\";          \r\n        }\r\n        $(\"#windDirectionInputScale\").append(\"<div class='directionPlate'>\" + str + \"</div>\");                \r\n      }\r\n      $(\".directionPlate\").css({\r\n        \"width\": 100/(directionPlateNumber) + \"%\",\r\n        \"float\": \"left\", \r\n        \"text-align\": \"center\"\r\n      });\r\n\r\n      // Create legend for value range input\r\n      // For fine view, Constant.maxWindValue should be equals 10\r\n      var maxWindVelocity = Constant.maxWindValue;\r\n      for(var i=0; i<maxWindVelocity + 1; i++) {    \r\n        $(\"#windValueInputScale\").append(\"<div class='valueScale' id='v\" + i + \"'>\" + i + \"</div>\");\r\n      }\r\n\r\n      $(\".valueScale\").css({\r\n        \"width\": 100/(maxWindVelocity + 0.38) + \"%\",\r\n        \"float\": \"left\",\r\n        \"text-align\": \"left\"\r\n      });\r\n\r\n      $(\"#v\" + (maxWindVelocity - 1)).css({\r\n        \"width\": 100/(maxWindVelocity*2) + \"%\"\r\n      }); \r\n\r\n      $(\"#v\" + maxWindVelocity).css({\r\n        \"width\": 100/(maxWindVelocity*1.25) + \"%\",\r\n        \"float\": \"left\",\r\n        \"text-align\": \"right\"\r\n      });  \r\n    }     \r\n  }\r\n\r\n  provide(DialogWindows);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/DialogWindows.js?");

/***/ }),

/***/ "./src/scripts/HeightOutputElement.js":
/*!********************************************!*\
  !*** ./src/scripts/HeightOutputElement.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('HeightOutputElement', [\r\n  'OutputElement'       \r\n],\r\nfunction(provide, OutputElement) {\r\n  /**\r\n   * Window for outputing height. \r\n   */\r\n  class HeightOutputElement extends OutputElement {\r\n\r\n    /**\r\n     * @param {number} height\r\n     */  \r\n    constructor(height) {\r\n      super();\r\n            \r\n      this.print(height);      \r\n    }\r\n    \r\n    /**\r\n     * @param {number} height\r\n     */\r\n    print(height) {\r\n      \r\n      if (typeof(height) == 'number') {\r\n        this.data.set(\"content\", \"Высота: \" + Math.floor(height) + \" м\");               \r\n      } else {\r\n        this.data.set(\"content\", \"Высота: неопределена\");                \r\n      }\r\n      \r\n      //this.data.set(\"content\", message); \r\n      /*    \r\n      if (height.length > 0) {      \r\n        if ((height.length == this.path.length) || \r\n            (this.path.length == 0)) {         \r\n          this.data.set(\"content\", \r\n            \"Высота: \" + Math.floor(height[height.length - 1]) + \" м\");                                                                                     \r\n        } else {\r\n          // Impossible to fly to this vertex          \r\n          this.data.set(\"content\", \"Высота: неопределена\");\r\n        }\r\n      } */     \r\n    }     \r\n  } \r\n  provide(HeightOutputElement);  \r\n}); \r\n\n\n//# sourceURL=webpack:///./src/scripts/HeightOutputElement.js?");

/***/ }),

/***/ "./src/scripts/Keyboard.js":
/*!*********************************!*\
  !*** ./src/scripts/Keyboard.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Keyboard', [\r\n  'Output', \r\n  'Constant'\r\n],\r\nfunction(\r\n  provide,\r\n  Output, \r\n  Constant\r\n) {\r\n\r\n  var Keyboard = {};\r\n  \r\n  /**\r\n   * Keys: left, right, up, down are for changing wind direction\r\n   * and wind value.\r\n   * Enter key on <input> tag will cause loose of focus.\r\n   * @param {Wind} wind\r\n   * @param {Calculator} calculator\r\n   * @param {WindOutputElement} windOutput\r\n   * @param {HeightOutputElement} heightOutput\r\n   * @param {Path} path   \r\n   */\r\n  Keyboard.startKeyboardProcessing = function(\r\n    windList, \r\n    calculator, \r\n    //windOutput, \r\n    //heightOutput, \r\n    path\r\n  ) {\r\n    \r\n    \r\n    \r\n    //  Change Wind by keyboard.\r\n    $(\"html\").keydown(function(e) {\r\n   \r\n      var angle = windList.currentWind.getAngle(),\r\n          value = windList.currentWind.getValue();\r\n          \r\n      var key = e.which;\r\n      switch(key) {\r\n        case 39:\r\n          angle += 5;\r\n          //wind.setAngle(angle);\r\n          windList.setCurrentAngle(angle);\r\n          $(\"#windDirectionInput\").val(angle);\r\n          calculatePrintRresults();           \r\n          break;\r\n        case 37:\r\n          angle -= 5;\r\n          //wind.setAngle(angle);\r\n          windList.setCurrentAngle(angle);\r\n          $(\"#windDirectionInput\").val(angle);\r\n          calculatePrintRresults();          \r\n          break;\r\n        case 38:\r\n          if (value <= Constant.maxWindValue - 1) {\r\n            value++;            \r\n            //wind.setValue(value);\r\n            windList.setCurrentValue(value);\r\n            $(\"#windValueInput\").val(value);\r\n            calculatePrintRresults();\r\n          }           \r\n          break;\r\n        case 40:\r\n          if (value >= 1) {\r\n            value--;\r\n            //wind.setValue(value);\r\n            windList.setCurrentValue(value);            \r\n            $(\"#windValueInput\").val(value);\r\n            calculatePrintRresults();\r\n          }          \r\n          break;\r\n        case 9:  // Tab keydown event\r\n          e.preventDefault();\r\n          windList.moveCurrentPointerToNext();\r\n          windList.printCurrentWindWindow();           \r\n          break;          \r\n      }\r\n      \r\n    });\r\n\r\n    // To loose focus after pressing Enter on <input>\r\n    // This is for dzHeightMenu and chuteMenu  \r\n    $(\"input\").keypress(function(e) {\r\n      if (e.keyCode === 13 || e.keyCode === 9) {  // Enter keycode\r\n        $(\"input\").blur();     // Forced loose of focus\r\n      }    \r\n    });\r\n    \r\n        \r\n    function calculatePrintRresults() {     \r\n      if (path.length > 0) {      \r\n        calculator.calculateHeight();   \r\n        Output.print(calculator, path);\r\n      }      \r\n      //windOutput.print(windList.currentWind);             \r\n    }\r\n  }\r\n    \r\n  provide(Keyboard);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Keyboard.js?");

/***/ }),

/***/ "./src/scripts/Menu.js":
/*!*****************************!*\
  !*** ./src/scripts/Menu.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Menu', [\r\n  'MenuButton'\r\n],\r\nfunction(provide, MenuButton) {\r\n  /**\r\n   * Set of buttons at the left side of screen.\r\n   */\r\n  class Menu {\r\n    /**\r\n     * @param {Map} map\r\n     * @param {Path} path\r\n     */\r\n    constructor(map, path) {\r\n      \r\n      this.path = path;      \r\n      this.pressedButton = null;\r\n         \r\n      // Clear Button\r\n      var clearButton = new MenuButton(\"Очистить\", \"images/icon_eraser.svg\");\r\n      clearButton.events.add('click', function() {\r\n        this.path.clear();          \r\n      }.bind(this));\r\n          \r\n      // DzStartHeight Button\r\n      var dzHeightButton = \r\n        new MenuButton(\"Настройки\", \"images/icon_settings.svg\", \"#dzHeightMenu\", this);\r\n\r\n      // Chute Button\r\n      var chuteButton = \r\n        new MenuButton(\"Настройки парашюта\", \"images/icon_chute.svg\", \"#chuteMenu\", this);\r\n\r\n      // Help Button\r\n      var helpButton = \r\n        new MenuButton(\"Справка\", \"images/icon_help.svg\", \"#helpMenu\", this);\r\n\r\n      // Wind Button\r\n      var windButton = \r\n        new MenuButton(\"Настройка ветра\", \"images/icon_arrow.svg\", \"#windMenu\", this);  \r\n\r\n      // Adding Buttons to Map.  \r\n      map.controls.add(dzHeightButton, {position: {top: 45, left: 10}});\r\n      map.controls.add(chuteButton, {position: {top: 75, left: 10}});\r\n      map.controls.add(windButton, {position: {top: 105, left: 10}});\r\n      map.controls.add(helpButton, {position: {top: 135, left: 10}});   \r\n      map.controls.add(clearButton, {position: {top: 165, left: 10}});     \r\n    }  \r\n  }\r\n      \r\n  provide(Menu);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/Menu.js?");

/***/ }),

/***/ "./src/scripts/MenuButton.js":
/*!***********************************!*\
  !*** ./src/scripts/MenuButton.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('MenuButton', [\r\n  'control.Button'       \r\n],\r\nfunction(provide, Button) {\r\n  /**\r\n   * @extends control.Button\r\n   */\r\n  class MenuButton extends Button {\r\n    /**\r\n     * @param {string} [title] - Button hint.\r\n     * @param {string} [image] - Src for <img> tag of this button.\r\n     * @param {string} [windowjQuerySelector] - jQuery selector for corresponding window. \r\n     * @param {Menu} [menu] - Link to parent menu.   \r\n     * @param {string} [cssclass] - Css for this button.          \r\n     */ \r\n    constructor(\r\n      title='', \r\n      image='', \r\n      windowjQuerySelector='', \r\n      menu=null, \r\n      cssclass='inputControlElement' \r\n    ) {\r\n      super({\r\n        data: {\r\n          title: title,\r\n          image: image, \r\n          cssclass: cssclass        \r\n        },  \r\n        options: {\r\n          layout: ymaps.templateLayoutFactory.createClass(\r\n            \"<div title='{{data.title}}' class='{{data.cssclass}}'>\" + \r\n              \"<img class='iconimage' src='{{data.image}}'>\" +           \r\n            \"</div>\"\r\n          ),\r\n          maxWidth: 300\r\n        }\r\n      });\r\n\r\n      this.menu = menu;\r\n      this.buttonIsOn = false;\r\n      this.windowjQuerySelector = windowjQuerySelector;  \r\n \r\n      // When the button is clicked, corresponding window \r\n      // (with jquery selector this.windowjQuerySelector) will be shown.      \r\n      if (this.windowjQuerySelector != '') {    \r\n        this.events.add('click', function() {\r\n          this.buttonIsOn = !this.buttonIsOn;\r\n          if (this.buttonIsOn) {\r\n            // show() is jQuery function\r\n            $(this.windowjQuerySelector).show();      \r\n            //arrow.geometry.setCoordinates(map.getCenter());\r\n            this.data.set('cssclass', 'pressedInputControlElement');\r\n\r\n            if ((this.menu.pressedButton != null) && (this.menu.pressedButton != this)) {\r\n              this.menu.pressedButton.turnOffButton();\r\n            }\r\n            this.menu.pressedButton = this;        \r\n          } else {\r\n            this.turnOffButton();\r\n            this.menu.pressedButton = null;        \r\n          }   \r\n        }.bind(this));\r\n                \r\n        // Cross closing of window element\r\n        $(this.windowjQuerySelector + \"Rectangle\").click(function() {\r\n          this.turnOffButton();  \r\n          this.menu.pressedButton = null;      \r\n        }.bind(this));\r\n        \r\n        this.turnOffButton = this.turnOffButton.bind(this);        \r\n      }   \r\n    }\r\n    \r\n        \r\n    /**\r\n     * Turn off button.\r\n     */     \r\n    turnOffButton() {\r\n      $(this.windowjQuerySelector).hide();\r\n      this.buttonIsOn = false;\r\n      this.data.set('cssclass', 'inputControlElement');\r\n    }     \r\n    \r\n  } \r\n  provide(MenuButton);  \r\n}); \r\n\n\n//# sourceURL=webpack:///./src/scripts/MenuButton.js?");

/***/ }),

/***/ "./src/scripts/Output.js":
/*!*******************************!*\
  !*** ./src/scripts/Output.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Output', [],\r\nfunction(provide) {\r\n\r\n  var Output = {};\r\n  \r\n  Output.print = function(calculator, path) {\r\n\r\n    var heightArray = calculator.getHeight();\r\n    \r\n    if (heightArray.length > 0) {\r\n      \r\n      path.printBallonsAndHints(heightArray);\r\n            \r\n      var startHeight = heightArray[0];\r\n      var finalHeight = heightArray[heightArray.length - 1];\r\n      \r\n      //path.heightOutput.print(finalHeight);\r\n                      \r\n      if (finalHeight == null) {\r\n        $(\"#finalHeight\").val(\"не определена\");      \r\n      } else {\r\n        var fh = Math.floor(finalHeight);           \r\n        $(\"#finalHeight\").val(fh);\r\n      }      \r\n\r\n      if (startHeight == null) {\r\n        $(\"#startHeight\").val(\"не определена\");          \r\n      } else {\r\n        var sh = Math.floor(startHeight);           \r\n        $(\"#startHeight\").val(sh);\r\n      }     \r\n    }              \r\n  }\r\n    \r\n  provide(Output);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Output.js?");

/***/ }),

/***/ "./src/scripts/OutputElement.js":
/*!**************************************!*\
  !*** ./src/scripts/OutputElement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('OutputElement', [\r\n  'control.Button', \r\n  'templateLayoutFactory'  \r\n],\r\nfunction(provide, Button, templateLayoutFactory) {\r\n  \r\n  class OutputElement extends Button {\r\n    /**\r\n     * @param {string} content   \r\n     */\r\n    constructor(content='') {\r\n      \r\n      super({\r\n        data: {content: content},  \r\n          \r\n        options: {\r\n          layout: templateLayoutFactory.createClass(\r\n            \"<div class='outputControlElement'>{{data.content}}</div>\"\r\n          ),\r\n         maxWidth: 300 \r\n        }\r\n      });           \r\n    }\r\n  } \r\n  provide(OutputElement);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/OutputElement.js?");

/***/ }),

/***/ "./src/scripts/Path.js":
/*!*****************************!*\
  !*** ./src/scripts/Path.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Path */      \r\nymaps.modules.define('Path', [ \r\n  'CircleVertex', \r\n  'TriangleVertex',\r\n  'Vertex', \r\n  'PathEdge', \r\n  'Output', \r\n  'Constant', \r\n  'HeightOutputElement'  \r\n],\r\nfunction(\r\n  provide, \r\n  CircleVertex, \r\n  TriangleVertex, \r\n  Vertex, \r\n  PathEdge, \r\n  Output, \r\n  Constant, \r\n  HeightOutputElement\r\n) {     \r\n  /**\r\n   * List of vertices and edges of Chute Path.\r\n   * Last vertex consist of one outer invisible Circle (Vertex class that \r\n   * extends ymaps.Circle) and arrow-trianlge (TriangleVertex class that extends ymaps.Polyline).\r\n   * Other vertices consist of one outer invisible Circle (Vertex class)\r\n   * and one visible inner Circle (CircleVertex class that extends ymaps.Circle). \r\n   * Outer vertex circles are invisible and serve for handy clicking  \r\n   * vertices.\r\n   */  \r\n  class Path {\r\n    /**\r\n     * @param {Map} map - link to Yandex map.\r\n     */  \r\n    constructor(map) {\r\n      this.map = map;\r\n      this.firstVertex = null;\r\n      this.lastVertex = null;\r\n      // number of vertices\r\n      this.length = 0;\r\n      \r\n      // If pathDirection is true, we add new vertex to the start of Path; \r\n      // if false, we add it to end of Path.\r\n      this.pathDirection = true;\r\n            \r\n      // radius for inner circle vertices, in meters\r\n      this.vertexRadius = Constant.isMobile ? 4 : 4;\r\n      // radius for outer invisible circles, in meters    \r\n      this.vertexOuterRadius = Constant.isMobile ? 6*this.vertexRadius : 3*this.vertexRadius;     \r\n\r\n      // On the map: line segments should be under vertex images, \r\n      // vertex images should be under vertices\r\n      this.vertexZIndex = 2;      \r\n      this.vertexImageZIndex = 1;\r\n      this.edgeZIndex = 0;\r\n      this.edgeImageZIndex = -1;\r\n\r\n      // Distance from vertex to it's heightPlacemark\r\n      this.heightPlacemarkShift = 0.0002;\r\n            \r\n      this.calculator = null;\r\n   \r\n      \r\n      // Output window at the top left corner of the screen.    \r\n      \r\n      this.heightOutput = \r\n        new HeightOutputElement(Constant.defaultStartHeight); \r\n        \r\n      //this.map.controls.add(this.heightOutput, {float: 'left'}); \r\n    }\r\n\r\n    \r\n    setPathDirection(pathDirection) {\r\n      this.pathDirection = pathDirection;\r\n    }\r\n    \r\n    getPathDirection() {\r\n      return(this.pathDirection);      \r\n    }\r\n\r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n\r\n    setHeightOutput(heightOutput) {\r\n      this.heightOutput = heightOutput;\r\n    }    \r\n        \r\n    /**\r\n     * Add new vertex to Path and to map.\r\n     * Add corresponding edge to Path and to map.\r\n     * @param {number[]} point - Yandex.Maps coordinates, point = [x, y].\r\n     * @return {Array} New last vertex and new last edge of Path.\r\n     */\r\n    addVertex(point) {  \r\n      var map = this.map;\r\n      \r\n      var vertex = new Vertex(point, this.vertexOuterRadius, this);\r\n            \r\n      //var newEdge = null;\r\n              \r\n      if (this.length > 0) {\r\n                \r\n        if (this.pathDirection) { \r\n          // We should add vertex to the end of path\r\n                                  \r\n          var lastPoint = this.lastVertex.geometry.getCoordinates();\r\n\r\n          vertex.image = new TriangleVertex(lastPoint, point, this.vertexImageZIndex);\r\n\r\n          var newEdge = new PathEdge(lastPoint, vertex.image.getEdgePoint(), this); \r\n          map.geoObjects.add(newEdge); \r\n          map.geoObjects.add(newEdge.image);        \r\n          \r\n                 \r\n          // We change last Triangle vertex to Circle vertex\r\n          map.geoObjects.remove(this.lastVertex.image);        \r\n          this.lastVertex.image = \r\n            new CircleVertex(lastPoint, this.vertexRadius, this.vertexImageZIndex);\r\n          map.geoObjects.add(this.lastVertex.image);\r\n\r\n          \r\n          // lastVertex image changed from triangle to circle.\r\n          // So edge from lastVertex.prevVertex to lastVertex should be lengthen.\r\n          if (this.lastVertex.prevVertex != null) {\r\n            // that is, lastVertex != firstVertex\r\n            var lastlastPoint = this.lastVertex.prevVertex.geometry.getCoordinates();\r\n            var lastEdge = this.lastVertex.prevVertex.nextLine;\r\n            lastEdge.setCoordinates(lastlastPoint, lastPoint);          \r\n          }\r\n                                 \r\n          this.lastVertex.nextVertex = vertex;\r\n          vertex.prevVertex = this.lastVertex;\r\n          \r\n          vertex.nextVertex = null;\r\n          \r\n          this.lastVertex.nextLine = newEdge; \r\n          newEdge.prevVertex = this.lastVertex;  \r\n\r\n          this.lastVertex = vertex;         \r\n        } else { \r\n          // We should add vertex to the beginning of path  \r\n\r\n          var firstPoint = this.firstVertex.geometry.getCoordinates(); \r\n          \r\n          var newEdge = null;\r\n          \r\n          if (this.length == 1) {\r\n\r\n            map.geoObjects.remove(this.firstVertex.image);\r\n            this.firstVertex.image = new TriangleVertex(point, firstPoint, this.vertexImageZIndex);\r\n            map.geoObjects.add(this.firstVertex.image);\r\n\r\n            newEdge = new PathEdge(point, this.firstVertex.image.getEdgePoint(), this); \r\n                             \r\n          } else {\r\n            newEdge = new PathEdge(point, firstPoint, this);              \r\n          }\r\n          \r\n          map.geoObjects.add(newEdge); \r\n          map.geoObjects.add(newEdge.image); \r\n          \r\n          vertex.nextVertex = this.firstVertex;\r\n          this.firstVertex.prevVertex = vertex;\r\n          \r\n          vertex.prevVertex = null;\r\n          \r\n          vertex.nextLine = newEdge;\r\n          newEdge.prevVertex = vertex;\r\n          this.firstVertex = vertex; \r\n          \r\n          vertex.image = new CircleVertex(point, this.vertexRadius, this.vertexImageZIndex);         \r\n        }                \r\n        \r\n      } else {  // this.length == 0;\r\n        vertex.prevVertex = null;\r\n        vertex.nextVertex = null;\r\n      \r\n        this.firstVertex = vertex;\r\n        this.lastVertex = vertex;         \r\n        vertex.image = new CircleVertex(point, this.vertexRadius, this.vertexImageZIndex);  \r\n      }\r\n      \r\n      map.geoObjects.add(vertex.image);\r\n      map.geoObjects.add(vertex);\r\n      map.geoObjects.add(vertex.heightPlacemark);\r\n           \r\n      this.length++;\r\n\r\n      this.calculator.calculateHeight();   \r\n      Output.print(this.calculator, this);      \r\n   \r\n      return([vertex, newEdge]);       \r\n    }\r\n    \r\n            \r\n    /**\r\n     * Divide edge of Path by point.\r\n     * Point should be on that line segment. \r\n     * @param {Edge} edge\r\n     * @param {number[]} point - Yandex.maps coordinates.\r\n     * @return {Array} New vertex and two new edges of Path.     \r\n     */        \r\n    divideEdge(edge, point) {\r\n      var map = this.map;\r\n\r\n      var prevVertex = edge.prevVertex,\r\n          nextVertex = edge.prevVertex.nextVertex;\r\n          \r\n      var prevPoint = prevVertex.geometry.getCoordinates(), \r\n          nextPoint = nextVertex.geometry.getCoordinates();\r\n          \r\n      var vertex = new Vertex(point, this.vertexOuterRadius, this);            \r\n      vertex.image = new CircleVertex(point, this.vertexRadius, this.vertexImageZIndex);\r\n      \r\n\r\n      var newEdge1 = new PathEdge(prevPoint, point, this);\r\n      \r\n      // In case when nextVertex is lastVertex\r\n      if (nextVertex.nextVertex == null) {\r\n        nextPoint = nextVertex.image.getEdgePoint();\r\n      }  \r\n      \r\n      var newEdge2 = new PathEdge(point, nextPoint, this);\r\n         \r\n      vertex.prevVertex = prevVertex;\r\n      vertex.nextVertex = nextVertex;\r\n      \r\n      prevVertex.nextVertex = vertex;\r\n      nextVertex.prevVertex = vertex;\r\n \r\n      prevVertex.nextLine = newEdge1;\r\n      vertex.nextLine = newEdge2;\r\n      \r\n      newEdge1.prevVertex = prevVertex;\r\n      newEdge2.prevVertex = vertex;\r\n      \r\n      this.length++;\r\n\r\n      map.geoObjects.remove(edge);\r\n      map.geoObjects.remove(edge.image);\r\n      map.geoObjects.add(vertex.image);\r\n      map.geoObjects.add(vertex);\r\n      map.geoObjects.add(vertex.heightPlacemark);\r\n      map.geoObjects.add(newEdge1);\r\n      map.geoObjects.add(newEdge2);\r\n      map.geoObjects.add(newEdge1.image);\r\n      map.geoObjects.add(newEdge2.image);      \r\n      \r\n      //this.calculateAndPrintHeights();\r\n      this.calculator.calculateHeight();   \r\n      Output.print(this.calculator, this);         \r\n            \r\n      return([vertex, newEdge1, newEdge2]);      \r\n    }\r\n    \r\n    /**\r\n     * Remove vertex from Path and from map.\r\n     * @param {Vertex} removingVertex\r\n     * @return {(Edge|null)} Edge between previous and next vertices. \r\n     */    \r\n    removeVertex(removingVertex) {\r\n      var map = this.map;\r\n    \r\n      map.geoObjects.remove(removingVertex);\r\n      map.geoObjects.remove(removingVertex.image);\r\n      \r\n      //if (removingVertex.heightPlacemark != undefined) {\r\n        map.geoObjects.remove(removingVertex.heightPlacemark);  \r\n      //}\r\n      \r\n      var prevVertex = removingVertex.prevVertex;\r\n      var nextVertex = removingVertex.nextVertex;\r\n      \r\n      var newEdge = null;\r\n      \r\n      if (this.length > 1) {\r\n        //if ((prevVertex != undefined) && (nextVertex != undefined)) {\r\n        if ((prevVertex != null) && (nextVertex != null)) {        \r\n        \r\n          var removingEdge1 = prevVertex.nextLine;\r\n          var removingEdge2 = removingVertex.nextLine;\r\n          \r\n          map.geoObjects.remove(removingEdge1);\r\n          map.geoObjects.remove(removingEdge1.image);\r\n          map.geoObjects.remove(removingEdge2);\r\n          map.geoObjects.remove(removingEdge2.image);\r\n          \r\n          var prevPoint = prevVertex.geometry.getCoordinates();\r\n          var nextPoint = nextVertex.geometry.getCoordinates();\r\n\r\n          \r\n          //newEdge = new Edge(prevPoint, nextPoint, this);\r\n          //this.map.geoObjects.add(newEdge);\r\n\r\n          \r\n          //prevVertex.nextLine = newEdge;\r\n          prevVertex.nextVertex = nextVertex;\r\n          nextVertex.prevVertex = prevVertex;\r\n          \r\n          \r\n          var nextEdgePoint = null;\r\n          \r\n          // case when nextVertex is lastVertex \r\n          // and so we have to change direction of \r\n          // arrow (triangle) of lastVertex\r\n          \r\n          //if (nextVertex.nextVertex == undefined) {\r\n          if (nextVertex.nextVertex == null) {  \r\n            map.geoObjects.remove(nextVertex.image);            \r\n            nextVertex.image = \r\n              new TriangleVertex(prevPoint, nextPoint, this.vertexImageZIndex);\r\n            map.geoObjects.add(nextVertex.image); \r\n           \r\n            nextEdgePoint = nextVertex.image.getEdgePoint();            \r\n                       \r\n          } else {\r\n            nextEdgePoint = nextPoint;            \r\n          }\r\n          \r\n          newEdge = new PathEdge(prevPoint, nextEdgePoint, this);\r\n          this.map.geoObjects.add(newEdge);\r\n          this.map.geoObjects.add(newEdge.image);\r\n          \r\n          newEdge.prevVertex = prevVertex;\r\n          prevVertex.nextLine = newEdge;\r\n          \r\n          \r\n          \r\n        //} else if (nextVertex == undefined) {  // last vertex case\r\n        } else if (nextVertex == null) {  // last vertex case        \r\n          var removingEdge = prevVertex.nextLine;          \r\n          map.geoObjects.remove(removingEdge);\r\n          \r\n          \r\n          map.geoObjects.remove(removingEdge.image);\r\n          \r\n          \r\n          this.lastVertex = prevVertex;\r\n          prevVertex.nextVertex = null;\r\n          prevVertex.nextLine = null; \r\n          //if (prevVertex.prevVertex != undefined) {\r\n          if (prevVertex.prevVertex != null) {  \r\n            map.geoObjects.remove(prevVertex.image);\r\n                        \r\n            var prevPrevPoint = prevVertex.prevVertex.geometry.getCoordinates();\r\n            var prevPoint = prevVertex.geometry.getCoordinates();            \r\n            prevVertex.image = \r\n              new TriangleVertex(prevPrevPoint, prevPoint, this.vertexImageZIndex);\r\n            map.geoObjects.add(prevVertex.image);\r\n            \r\n\r\n            prevVertex.prevVertex.nextLine.setCoordinates(prevPrevPoint, prevVertex.image.getEdgePoint());            \r\n            \r\n          }\r\n\r\n          // If we remove last vertex (pathDirection == false), \r\n          // initial height will change.\r\n          if (!this.pathDirection) {\r\n            var n = this.calculator.height.length;             \r\n            //this.calculator.setFinalHeight(this.calculator.height[n-2]);\r\n            this.calculator.boundaryHeights.finalHeight = \r\n              this.calculator.height[n-2];\r\n            $(\"#finalHeight\").val(Math.floor(this.calculator.height[n-2]));\r\n          } \r\n          \r\n        } else {  // first vertex case\r\n          map.geoObjects.remove(removingVertex.nextLine);\r\n          map.geoObjects.remove(removingVertex.nextLine.image);\r\n          \r\n          nextVertex.prevVertex = null;\r\n          this.firstVertex = nextVertex;           \r\n          \r\n          if (this.length == 2) {\r\n            var p = nextVertex.geometry.getCoordinates();\r\n            map.geoObjects.remove(nextVertex.image);\r\n            nextVertex.image = \r\n              new CircleVertex(p, this.vertexRadius, this.vertexImageZIndex);\r\n            map.geoObjects.add(nextVertex.image);\r\n          }\r\n          \r\n          // If we remove first vertex (pathPosition == true), \r\n          // initial height will change.\r\n          if (this.pathDirection) {          \r\n            //this.calculator.setStartHeight(this.calculator.height[1]);\r\n            this.calculator.boundaryHeights.startHeight = \r\n              this.calculator.height[1];\r\n            \r\n            $(\"#startHeight\").val(Math.floor(this.calculator.height[1]));\r\n          }\r\n          \r\n        }\r\n      } else {  // case: only one circle\r\n        this.lastVertex = null;\r\n      }\r\n      \r\n      this.length--;\r\n      \r\n      //this.calculateAndPrintHeights();\r\n      if (this.length > 0) {\r\n        this.calculator.calculateHeight();\r\n        Output.print(this.calculator, this);         \r\n      }        \r\n        \r\n            \r\n      return(newEdge);\r\n    }\r\n   \r\n    /**\r\n     * Drag vertex with neibour edges.\r\n     * @param {Vertex} vertex\r\n     */     \r\n    dragVertex(vertex) {\r\n      var map = this.map;\r\n          \r\n      //this.calculateAndPrintHeights();\r\n      this.calculator.calculateHeight();   \r\n      Output.print(this.calculator, this);   \r\n      \r\n      // new vertex coordinates\r\n      var point = vertex.geometry.getCoordinates();\r\n                             \r\n      var nextVertex = vertex.nextVertex;\r\n      var prevVertex = vertex.prevVertex;  \r\n      \r\n      // Case: both prevVertex and nextVertex don't exist, \r\n      // that is, path consists of one vertex\r\n      //if ((nextVertex == undefined) && (prevVertex == undefined)) {\r\n      if ((nextVertex == null) && (prevVertex == null)) {        \r\n        vertex.image.geometry.setCoordinates(point);\r\n        return;\r\n      }\r\n\r\n      // Case: both prevVertex and nextVertex exist,\r\n      // that is, this vertex is not first and not last.     \r\n      //if ((nextVertex != undefined) && (prevVertex != undefined)) {\r\n      if ((nextVertex != null) && (prevVertex != null)) {\r\n      \r\n        vertex.image.geometry.setCoordinates(point); \r\n        \r\n        var nextPoint = nextVertex.geometry.getCoordinates();\r\n        var prevPoint = prevVertex.geometry.getCoordinates();\r\n        \r\n        var nextLine = vertex.nextLine;\r\n        var prevLine = prevVertex.nextLine;\r\n        \r\n        var nextEdgePoint = null;                \r\n        // Case when vertex.nextVertex is lastVertex:\r\n        // in that case your should change \r\n        // direction of arrow at lastVertex.\r\n        //if (nextVertex.nextVertex == undefined) {\r\n        if (nextVertex.nextVertex == null) {          \r\n          nextVertex.image.setCoordinates(point, nextPoint);\r\n          \r\n          nextEdgePoint = nextVertex.image.getEdgePoint();\r\n        } else {\r\n          nextEdgePoint = nextPoint;\r\n        }\r\n        \r\n        //nextLine.geometry.setCoordinates([point, nextEdgePoint]);\r\n        //prevLine.geometry.setCoordinates([prevPoint, point]);        \r\n        \r\n        nextLine.setCoordinates(point, nextEdgePoint);\r\n        prevLine.setCoordinates(prevPoint, point); \r\n        \r\n        \r\n        return;        \r\n      }\r\n      \r\n      // Case: prevVertex exists, nextVertex doesn't exist, \r\n      // that is, vertex is lastVertex.      \r\n      //if (prevVertex != undefined) {\r\n      if (prevVertex != null) {         \r\n        var prevPoint = prevVertex.geometry.getCoordinates();\r\n        var prevLine = prevVertex.nextLine;        \r\n\r\n\r\n        // We should change direction of arrow at the vertex\r\n        vertex.image.setCoordinates(prevPoint, point);\r\n        \r\n        var edgePoint = vertex.image.getEdgePoint();\r\n        //prevLine.geometry.setCoordinates([prevPoint, edgePoint]);\r\n        \r\n        prevLine.setCoordinates(prevPoint, edgePoint);\r\n        \r\n        return;        \r\n      }\r\n            \r\n      // Case: nextVertex exists, prevVertex doesn't exist, \r\n      // that is, vertex is firstVertex. \r\n      vertex.image.geometry.setCoordinates(point);\r\n      \r\n      var nextPoint = nextVertex.geometry.getCoordinates();\r\n\r\n\r\n      var nextEdgePoint = null;\r\n      // Case when vertex.nextVertex is lastVertex:\r\n      // in that case your should change \r\n      // direction of arrow at lastVertex.\r\n      //if (nextVertex.nextVertex == undefined) {\r\n      if (nextVertex.nextVertex == null) {        \r\n        nextVertex.image.setCoordinates(point, nextPoint);\r\n        nextEdgePoint = nextVertex.image.getEdgePoint();        \r\n      } else {\r\n        nextEdgePoint = nextPoint;        \r\n      }\r\n      \r\n      var nextLine = vertex.nextLine;        \r\n      //nextLine.geometry.setCoordinates([point, nextEdgePoint]);\r\n      \r\n      nextLine.setCoordinates(point, nextEdgePoint);\r\n      \r\n      \r\n      return;            \r\n    }\r\n\r\n    \r\n    /** Remove all vetrices and edges from Path and from map. */    \r\n    clear() {\r\n      var map = this.map;\r\n           \r\n      if (this.length > 0 ) {\r\n      \r\n        var vertex = this.lastVertex;  \r\n        map.geoObjects.remove(vertex);\r\n        map.geoObjects.remove(vertex.image);\r\n        map.geoObjects.remove(vertex.heightPlacemark);\r\n        \r\n        for(var i=1; i < this.length; i++) {\r\n          vertex = vertex.prevVertex; \r\n          map.geoObjects.remove(vertex);\r\n          map.geoObjects.remove(vertex.image);\r\n          map.geoObjects.remove(vertex.nextLine);\r\n          map.geoObjects.remove(vertex.nextLine.image);\r\n          map.geoObjects.remove(vertex.heightPlacemark);\r\n        }\r\n        \r\n        this.length = 0;\r\n        this.lastVertex = null; \r\n      }\r\n      \r\n      var out = this.pathDirection ? \r\n        Constant.defaultStartHeight : Constant.defaultFinalHeight;      \r\n      \r\n      this.heightOutput.print(out);\r\n      $(\"#startHeight\").val(out);\r\n      $(\"#finalHeight\").val(out);\r\n      \r\n      this.calculator.boundaryHeights.startHeight = Constant.defaultStartHeight;\r\n      this.calculator.boundaryHeights.finalHeight = Constant.defaultFinalHeight;    \r\n    }\r\n\r\n\r\n    /**\r\n     * Print heights in vertices ballons and hints.\r\n     * @param {Array} height - heights in Path vertices.\r\n     */     \r\n    printBallonsAndHints(height) {\r\n      if (this.length > 0 && height.length > 0) {      \r\n        var vertex = this.firstVertex;\r\n        \r\n        var beforeNumber = true;\r\n            \r\n        for(var i=0; i < this.length; i++) {\r\n          \r\n          if (typeof(height[i]) == 'number') {\r\n            \r\n            vertex.printHint(\"h=\" + Math.floor(height[i]) + \"м\");\r\n            vertex.printPlacemark(Math.floor(height[i]) + \"м\");\r\n                \r\n            /*                \r\n            vertex.properties.set(\"hintContent\", \"h=\" + \r\n                                         Math.floor(height[i]) + \"м\");\r\n            vertex.heightPlacemark.properties.set(\"iconContent\",\r\n                                         Math.floor(height[i]) + \"м\"); */\r\n            beforeNumber = false;\r\n                                         \r\n          } else {\r\n            if (beforeNumber) {\r\n              vertex.printHint(\"&#x26D4;\");\r\n              vertex.printPlacemark(\"Отсюда не долететь!\");\r\n              //vertex.properties.set(\"hintContent\", \"&#x26D4;\");\r\n              //vertex.heightPlacemark.properties.set(\"iconContent\", \"Отсюда не долететь!\");                         \r\n            } else {\r\n              //vertex.heightPlacemark.options.set(\"preset\", \"islands#redIcon\");\r\n              vertex.printHint(\"&#x26D4;\");\r\n              vertex.printPlacemark(\"Сюда не долететь!\");                \r\n              //vertex.properties.set(\"hintContent\", \"&#x26D4;\");\r\n              //vertex.heightPlacemark.properties.set(\"iconContent\", \"Сюда не долететь!\");        \r\n            }            \r\n          }                            \r\n                                                                              \r\n          vertex = vertex.nextVertex;\r\n        }\r\n      }      \r\n    }\r\n  \r\n  }  \r\n  provide(Path);      \r\n});      \r\n\n\n//# sourceURL=webpack:///./src/scripts/Path.js?");

/***/ }),

/***/ "./src/scripts/PathEdge.js":
/*!*********************************!*\
  !*** ./src/scripts/PathEdge.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module PathEdge */\r\nymaps.modules.define('PathEdge', [\r\n  'Polygon', \r\n  'VectorMath'  \r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n  /**\r\n   * PathEdge consists of two rectangles: \r\n   *   visible rectangle and invisible rectangle.\r\n   * Invisible rectangle (shell rectangle) is for the means of \r\n   * more simple clicking (especially in mobile case)\r\n   */\r\n  class PathEdge extends Polygon {\r\n    /**\r\n     * @param {number[]} pointA - Yandex.Maps coordinates of first point.\r\n     * @param {number[]} pointB - Yandex.Maps coordinates of second point.\r\n     * @param {number} edgeImageWidthWidth\r\n     * @param {number} edgeWidth      \r\n     * @param {number} zIndex - z-index of edge, z-index of edgeImage\r\n     *    will equals zIndex-1.     \r\n     */\r\n    constructor(\r\n      pointA, \r\n      pointB,\r\n      path, \r\n      edgeWidth = 1,       \r\n      edgeImageWidth = 0.1, \r\n      zIndex = 0\r\n    ) {\r\n            \r\n      // Rectangle vertices will be calculated later\r\n      super([], {}, {\r\n        // edge will be invisible\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: zIndex\r\n      });\r\n                            \r\n      this.image = new Polygon([], {}, {\r\n        fillColor: \"#0000FF\",\r\n        strokeColor: \"#0000FF\", \r\n        zIndex: (zIndex - 1)        \r\n      });\r\n      \r\n      this.pointA = pointA;\r\n      this.pointB = pointB;\r\n      this.path = path;\r\n      this.edgeWidth = edgeWidth; \r\n      this.edgeImageWidth = edgeImageWidth;\r\n      \r\n      this.setCoordinates(pointA, pointB);\r\n\r\n      this.divideEdge = this.divideEdge.bind(this);\r\n      this.events.add('click', this.divideEdge);           \r\n    }\r\n    \r\n    \r\n    /**    \r\n     * Here we calculate projection of point = e.get('coords') to \r\n     * line segment {this.pointA, this.pointB} and then \r\n     * send that projection to path.divideEdge.     \r\n     * @param {Event} e\r\n     */\r\n    divideEdge(e) {\r\n      \r\n      e.stopPropagation();          \r\n      var point = e.get('coords');\r\n      \r\n      var pointA = this.pointA, \r\n          pointB = this.pointB;\r\n              \r\n      var vector1 = VectorMath.subVectors(point, pointA), \r\n          vector2 = VectorMath.subVectors(pointB, pointA);\r\n      vector2 = VectorMath.normaliseVector(vector2);                \r\n      var c = VectorMath.scalarProduct(vector1, vector2);        \r\n      var vector3 = VectorMath.multVectorConstant(vector2, c);\r\n      \r\n      var point2 = VectorMath.addVectors(pointA, vector3);\r\n                            \r\n      this.path.divideEdge(this, point2);    \r\n    }\r\n        \r\n        \r\n    setCoordinates(pointA, pointB) {\r\n      \r\n      var vertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeWidth);\r\n\r\n      this.geometry.setCoordinates([vertices]);        \r\n      \r\n      var imageVertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeImageWidth);\r\n\r\n      this.image.geometry.setCoordinates([imageVertices]); \r\n\r\n      this.pointA = pointA;\r\n      this.pointB = pointB;      \r\n    }\r\n    \r\n    \r\n    /**\r\n     * @param {number} width - Width of Rectangle, in meters. \r\n     */    \r\n    calculateRectangleVertices (pointA, pointB, width) {\r\n                  \r\n      var latitude = pointA[0],\r\n          geodesicVectorAB = VectorMath.subVectors(pointB, pointA);\r\n\r\n      var cartVectorAB = \r\n            VectorMath.toLocalVector(geodesicVectorAB, latitude);         \r\n\r\n      var v = VectorMath.normaliseVector(cartVectorAB);\r\n      \r\n      var w = [(-v[1])*width , v[0]*width];\r\n      \r\n      \r\n      var wg = VectorMath.toGeodesicVector(w, latitude);\r\n      var wwg = [wg[0]*(-1), wg[1]*(-1)];\r\n      \r\n      var vertices = [];  \r\n      vertices[0] = VectorMath.addVectors(pointA, wg);\r\n      vertices[1] = VectorMath.addVectors(pointB, wg);\r\n      vertices[2] = VectorMath.addVectors(pointB, wwg); \r\n      vertices[3] = VectorMath.addVectors(pointA, wwg);       \r\n                  \r\n      return(vertices);  \r\n    }      \r\n    \r\n        \r\n  } \r\n  provide(PathEdge);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/PathEdge.js?");

/***/ }),

/***/ "./src/scripts/TriangleVertex.js":
/*!***************************************!*\
  !*** ./src/scripts/TriangleVertex.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('TriangleVertex', [\r\n  'Polygon', \r\n  'VectorMath'  \r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n \r\n  /** \r\n   * Let point1, point2 - two points with Yandex.maps (geodesic) coordinates. \r\n   * TriangleVertex is Yandex maps triangle, \r\n   * such that vector (point1, point2) and that triangle \r\n   * form arrow (end of path).\r\n   * Size of arrow is about several meters.\r\n   */ \r\n  class TriangleVertex extends Polygon {\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates. \r\n     * @param {number} zIndex - z-index of Polygon.     \r\n     */\r\n    constructor(point1, point2, zIndex=0) {\r\n      // four square brackets is a must for Polygon constructor, \r\n      // non empty super constructor is a must     \r\n      super([], {}, {\r\n        fillColor: \"#0000FF\", \r\n        strokeColor: \"#0000FF\", \r\n        zIndex: zIndex          \r\n      });   \r\n      \r\n      // Three vertices of triangle \r\n      this.triangleVertices = null;\r\n      // Point on triangle side to which edge will be connected\r\n      this.edgePoint = null;\r\n      \r\n      this.setCoordinates(point1, point2);       \r\n    }\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.    \r\n     */    \r\n    setCoordinates (point1, point2) {\r\n      var p = this.calculateVertices(point1, point2);\r\n\r\n      this.triangleVertices = [p[0], p[1], p[2]];\r\n      this.edgePoint = p[3]; \r\n      \r\n      this.geometry.setCoordinates([this.triangleVertices]); \r\n    }\r\n    \r\n    getEdgePoint() {\r\n      return(this.edgePoint);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps point coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps point coordinates.\r\n     * @return {number[][]} points - First three points of this array are \r\n     * the vertices of triangle; last point is a point at the triangle side \r\n     * to which edge will be connected.  \r\n     */     \r\n    calculateVertices (point1, point2) {\r\n                   \r\n      var latitude = point1[0],\r\n          geodesicArrowVector = VectorMath.subVectors(point2, point1),\r\n          localArrowVector = \r\n            VectorMath.toLocalVector(geodesicArrowVector, latitude);         \r\n\r\n      localArrowVector = VectorMath.normaliseVector(localArrowVector);                \r\n      \r\n      // Points coordinates in local cartesian coordinate system.\r\n      // First three point are the vertices of triangle.\r\n      // Last point is a point at the triangle side \r\n      // to which edge will be connected.\r\n      var pointsLocal = [[-2, 0.5], [-2, -0.5], [0, 0], [-2,0]];\r\n      \r\n      var points = [];                 \r\n      for(var i=0; i<pointsLocal.length; i++) {   \r\n        points[i] = VectorMath.rotateVector(pointsLocal[i], localArrowVector);\r\n        points[i] = VectorMath.addVectors(\r\n          point2, \r\n          VectorMath.toGeodesicVector(points[i], latitude)\r\n        );\r\n      }\r\n \r\n      return(points);  \r\n    }        \r\n  }\r\n  \r\n  provide(TriangleVertex);      \r\n});\n\n//# sourceURL=webpack:///./src/scripts/TriangleVertex.js?");

/***/ }),

/***/ "./src/scripts/VectorMath.js":
/*!***********************************!*\
  !*** ./src/scripts/VectorMath.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('VectorMath', [],\r\nfunction(provide) {\r\n  /** Set of functions for working with Sphere (2 dimensional) vectors. */\r\n  class VectorMath {\r\n       \r\n    /**\r\n     * We consider following local cartesian coordinate system: \r\n     *  axis have the same direction as Latitude-Longtitude, \r\n     *  axis have the same length (with each other), \r\n     *  default scale parameter (0.00008) makes this \r\n     *  coordinate system be of the size we need in our tasks.\r\n     * @param {number[]} geodesicVector - Latitude-Longtitude vector coordinates.\r\n     * @param {number} latitude\r\n     * @param {number} scale - Default value is 0.00008\r\n     * @return {number[]} [vx, vy] - Vector coordinates in cartesian coordinate system.\r\n     */      \r\n    static toLocalVector(geodesicVector, latitude, scale=0.00008) {  \r\n      var vx = geodesicVector[0]/scale;\r\n      var vy = (geodesicVector[1]/scale) * \r\n                Math.cos((Math.PI/180)*latitude);\r\n      return([vx, vy]);\r\n    }\r\n    \r\n    /**\r\n     * Convert Cartesian coordinate to Latitude-Longtitude coordinates.\r\n     * @param {number[]} localVector - Cartesian vector. \r\n     * @param {number} latitude\r\n     * @param {number} scale \r\n     * @return {number[]|0} [vlat, vlon] - [Latitude, Longtitude] or 0 \r\n     *  (if impossible to convert).       \r\n     */\r\n    static toGeodesicVector(localVector, latitude, scale=0.00008) {\r\n      var vlat = localVector[0]*scale;\r\n      var c = Math.cos((Math.PI/180)*latitude);\r\n      if (c == 0) return 0;\r\n      var vlon = (localVector[1]*scale) / c;\r\n      return([vlat, vlon]);\r\n    }\r\n\r\n    static normaliseVector(v) {\r\n      var d = Math.sqrt(v[0]**2 + v[1]**2);\r\n      if (d>0) {\r\n        return ([v[0]/d, v[1]/d]);\r\n      } else {        \r\n        return ([0, 0]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * n = (cos(alpha), sin(alpha)), \r\n     * alpha is angle of rotation\r\n     */\r\n    static rotateVector(v, n) {\r\n      var wx = n[0]*v[0] - n[1]*v[1];\r\n      var wy = n[1]*v[0] + n[0]*v[1];\r\n      return ([wx, wy]);        \r\n    }\r\n\r\n    static addVectors(v1, v2) {\r\n      return([v1[0] + v2[0], v1[1] + v2[1]]);\r\n    } \r\n    \r\n    static subVectors(v1, v2) {\r\n      return([v1[0] - v2[0], v1[1] - v2[1]]);\r\n    }\r\n\r\n    static multVectorConstant(v, a) {\r\n      return([v[0]*a, v[1]*a]);\r\n    }\r\n\r\n    static scalarProduct(v1, v2) {\r\n      return(v1[0]*v2[0] + v1[1]*v2[1]);      \r\n    }\r\n    \r\n    static length(v) {\r\n      return(Math.sqrt(v[0]*v[0] + v[1]*v[1]));\r\n    }\r\n        \r\n  }\r\n      \r\n  provide(VectorMath);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/VectorMath.js?");

/***/ }),

/***/ "./src/scripts/Vertex.js":
/*!*******************************!*\
  !*** ./src/scripts/Vertex.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Vertex', [\r\n  'Circle', \r\n  'Placemark'  \r\n],\r\nfunction(provide, Circle, Placemark) {\r\n  /**\r\n   * Vertex of Path. \r\n   * It is invisible circle. Vertex image will be vertex.image object.\r\n   */\r\n  class Vertex extends Circle {\r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {number} radius\r\n     * @param {Path} path - Link to path; we need it because \r\n     * double clicking and draging of vertex change path (neibours of vertex).     \r\n     */\r\n    constructor(point, radius, path) {\r\n      super([\r\n        point, \r\n        radius\r\n      ], {}, {\r\n        draggable: true,\r\n        // vertex will be invisible\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: path.vertexZIndex\r\n      }); \r\n            \r\n      // Distance from vertex to it's heightPlacemark\r\n      this.heightPlacemarkShift = 0.0001;\r\n      \r\n      // Placemark for Height of Chute at this vertex\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        [point[0] + this.heightPlacemarkShift, point[1]], \r\n        {}, \r\n        {\r\n          preset: 'islands#blackStretchyIcon', \r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n      \r\n      // This varialable will be set up later.\r\n      this.image = null;\r\n      \r\n      this.path = path; \r\n\r\n      this.prevVertex = null;\r\n      this.nextVertex = null;\r\n      \r\n      this.clickNumber = 0;\r\n      this.placemarkIsShown = true; \r\n              \r\n      this.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n      \r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });\r\n      \r\n      this.events.add('drag', function(e) {\r\n        e.stopPropagation();\r\n        this.processVertexDrag();       \r\n      }.bind(this));\r\n    \r\n    }\r\n          \r\n    /**\r\n     * Process both click and dblclick on this vertex.\r\n     */       \r\n    processVertexClick() {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (this.clickNumber == 1) {  // Single Click\r\n            this.placemarkIsShown = !this.placemarkIsShown;\r\n            \r\n            if (this.placemarkIsShown) {\r\n              this.path.map.geoObjects.add(this.heightPlacemark);\r\n            } else {\r\n              this.path.map.geoObjects.remove(this.heightPlacemark);                  \r\n            }\r\n                            \r\n            this.clickNumber = 0;\r\n          } else {  // Double Click               \r\n            this.path.removeVertex(this);                 \r\n          }  \r\n        }.bind(this), 200);\r\n      }  \r\n    }\r\n\r\n    /**\r\n     * Process vertex dragging.\r\n     */     \r\n    processVertexDrag() {\r\n      var newPoint = this.geometry.getCoordinates();\r\n     \r\n      this.heightPlacemark.geometry.setCoordinates(\r\n        [newPoint[0] + this.heightPlacemarkShift, newPoint[1]]\r\n      );\r\n      \r\n      this.path.dragVertex(this);         \r\n    }\r\n    \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set(\"iconContent\", str);           \r\n    }\r\n    \r\n    printHint(str) {\r\n      this.properties.set(\"hintContent\", str);      \r\n    }\r\n    \r\n        \r\n  } \r\n  provide(Vertex);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Vertex.js?");

/***/ }),

/***/ "./src/scripts/Wind.js":
/*!*****************************!*\
  !*** ./src/scripts/Wind.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Wind', [\r\n  'Arrow'\r\n],\r\nfunction(provide, Arrow) {\r\n\r\n  /**\r\n   * Wind at particular height.  \r\n   */\r\n  class Wind {\r\n    /** \r\n     * Wind in polar coordinate system.\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     * @param {number} angle - Angle between current wind and West wind; in degrees.    \r\n     * @param {number || null} height - In meters; height must be >= 0.\r\n     */\r\n    constructor(value, angle, height) {\r\n      \r\n      this.arrow = new Arrow();        \r\n      \r\n      this.setValue(value);\r\n      this.setAngle(angle);\r\n      this.setHeight(height); \r\n\r\n      this.prevWind = null;\r\n      this.nextWind = null;      \r\n    }\r\n    \r\n    /**\r\n     * @param {number || null} height - In meters; height must be >= 0.\r\n     */\r\n    setHeight(height) {\r\n      if (height != null) {\r\n        this.arrow.print(height + \"м\");        \r\n      } else {\r\n        this.arrow.print(\"h = ?\");\r\n      }\r\n      \r\n      this.height = height;      \r\n    }\r\n    \r\n    /**\r\n     * this.angle will be reduced to interval (-180, 180] degrees.\r\n     * @param {number} angle\r\n     */\r\n    setAngle(angle) {\r\n      \r\n      angle = Math.floor(angle); \r\n            \r\n      if (angle >= 0) {\r\n        angle = angle % 360;\r\n      } else {\r\n        // negative angle case\r\n        angle = angle * (-1);\r\n        angle = angle % 360;\r\n        angle = 360 - angle;        \r\n      }\r\n      \r\n      if (angle > 180) {\r\n        angle -= 360;\r\n      }        \r\n            \r\n      this.arrow.rotate(angle);\r\n\r\n      this.angle = angle;            \r\n    }\r\n    \r\n    /**\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     */\r\n    setValue(value) {\r\n      this.value = value;             \r\n    }\r\n    \r\n     \r\n    getAngle() {\r\n      return(this.angle);\r\n    }\r\n    \r\n    getValue() {\r\n      return(this.value);\r\n    }\r\n    \r\n    getHeight() {\r\n      return(this.height);\r\n    }\r\n        \r\n    /**\r\n     * Calculate wind coordinates in cartesian coordinate system.\r\n     * @return {number[]} [vx, vy] - coordinates, in m/sec.\r\n     */\r\n    getXY () {      \r\n      var radiandirection = this.angle * ((2*Math.PI)/360);       \r\n      var vx = this.value * Math.cos(radiandirection);\r\n      var vy = this.value * Math.sin(radiandirection);\r\n      return [vx, vy];      \r\n    } \r\n    \r\n    /**\r\n     * Get name of wind direction (E, N, W, S, ...)\r\n     */    \r\n    getDirection() {     \r\n      var angleSwitch = Math.floor((this.angle + 180 + 22)/45);\r\n      var direction;\r\n      \r\n      switch(angleSwitch) {\r\n        case 0: direction = \"В\"; break;\r\n        case 1: direction = \"СВ\"; break;\r\n        case 2: direction = \"С\"; break;\r\n        case 3: direction = \"СЗ\"; break;\r\n        case 4: direction = \"З\"; break;\r\n        case 5: direction = \"ЮЗ\"; break;\r\n        case 6: direction = \"Ю\"; break;\r\n        case 7: direction = \"ЮВ\"; break;\r\n        case 8: direction = \"В\"; break;    \r\n      }\r\n      \r\n      return(direction);     \r\n    }  \r\n\r\n    addToMap(map, coordinates = null) {\r\n      this.arrow.addToMap(map, coordinates);\r\n    }\r\n    \r\n    removeFromMap(map) {\r\n      this.arrow.removeFromMap(map);\r\n    }\r\n    \r\n  }\r\n      \r\n  provide(Wind);  \r\n});      \r\n      \n\n//# sourceURL=webpack:///./src/scripts/Wind.js?");

/***/ }),

/***/ "./src/scripts/WindList.js":
/*!*********************************!*\
  !*** ./src/scripts/WindList.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindList', [\r\n  'Wind', \r\n  'WindOutputElement'\r\n],\r\nfunction(provide, Wind, WindOutputElement) {\r\n\r\n  /**\r\n   * List of winds at different heights; \r\n   * always contains wind at height = 0m (surface wind); \r\n   * that surface wind is always first and cannot be removed;\r\n   * list will be sorted for height (from bottom to top); \r\n   * all winds should have different heights.\r\n   * WindList also contains WindOutputElement for showing \r\n   * parameters of current wind.\r\n   * WindList contains function printCurrentWindWindow() \r\n   * for printing parameters of current window to wind dialog window; \r\n   * you should make this printing by hand (that is, call \r\n   * that function when you need).\r\n   */\r\n  class WindList {\r\n    constructor(map) {\r\n      this.map = map; \r\n     \r\n      // 5 m/sec, west wind, h = 0m (surface wind)\r\n      this.firstWind = new Wind(5, 0, 0);\r\n      this.firstWind.arrow.setSelection(false);      \r\n      // we add to map corresponding windsock\r\n      this.firstWind.addToMap(this.map, this.map.getCenter());\r\n      this.firstWind.arrow.removePlacemark();      \r\n      \r\n      this.currentWind = this.firstWind;\r\n      this.lastWind = this.firstWind;\r\n      this.numberOfWinds = 1;\r\n\r\n      // Output window at the top left corner of the screen.    \r\n      this.windOutput = new WindOutputElement(this.firstWind);\r\n      this.map.controls.add(this.windOutput, {float: 'left'}); \r\n      this.windOutput.print(this.currentWind);          \r\n      \r\n      this.firstWind.arrow.events.add('click', function(e) {\r\n        if (this.numberOfWinds == 1) return;      \r\n        if (this.currentWind != this.firstWind) {\r\n          this.currentWind.arrow.setSelection(false);\r\n          this.firstWind.arrow.setSelection(true);\r\n          this.currentWind = this.firstWind;          \r\n        }         \r\n        this.printCurrentWindWindow();\r\n        this.windOutput.print(this.currentWind);        \r\n      }.bind(this));      \r\n    }\r\n\r\n    /**\r\n     * Create new wind (value = 5, angle = 0, height is unknown) and \r\n     * add it to the end of the list.\r\n     */\r\n    addWind(point = null) {\r\n      \r\n      var wind = new Wind(5, 0, null);\r\n      wind.addToMap(this.map, point);\r\n           \r\n      this.currentWind.arrow.setSelection(false);\r\n      wind.arrow.setSelection(true);\r\n\r\n      this.lastWind.nextWind = wind;      \r\n      \r\n      wind.prevWind = this.lastWind;\r\n      wind.nextWind = null;\r\n      \r\n      this.lastWind = wind;\r\n      this.currentWind = wind;\r\n                      \r\n      var clickNumber = 0;\r\n      \r\n      wind.arrow.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n\r\n        clickNumber++;\r\n        if (clickNumber == 1) {\r\n          setTimeout(function() {        \r\n            if (clickNumber == 1) {  // Single Click (selection arrow)\r\n              \r\n              if (this.currentWind != wind) {\r\n                this.currentWind.arrow.setSelection(false);\r\n                wind.arrow.setSelection(true);\r\n                this.currentWind = wind;          \r\n              } \r\n              \r\n              this.printCurrentWindWindow();\r\n              this.windOutput.print(this.currentWind);               \r\n            } else {  // Double Click (deletion of current arrow)\r\n              this.removeWind(this.currentWind);         \r\n            }\r\n            \r\n            clickNumber = 0;\r\n            \r\n          }.bind(this), 200);\r\n        }          \r\n      }.bind(this));\r\n            \r\n      // remove standart map zoom for double click\r\n      wind.arrow.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });      \r\n    \r\n      this.windOutput.print(this.currentWind);       \r\n      this.numberOfWinds++;\r\n      \r\n      if (this.numberOfWinds == 2) {\r\n        this.firstWind.arrow.addPlacemark();\r\n      }       \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Remove wind from WindList. If wind equals currentWind then \r\n     * after removing currentWind will be equal currentWind.prevWind.\r\n     * Note: you cannot remove firstWind by construction.\r\n     * @param {Wind} wind - It is supposed that wind belongs to WindList.  \r\n     */\r\n    removeWind(wind) {\r\n      \r\n      // First wind, that is, surface wind, cannot be removed\r\n      if (wind == this.firstWind) {\r\n        console.warn(\"This wind was not removed, because it was firstWind.\");\r\n        return;\r\n      }\r\n      \r\n      wind.removeFromMap(this.map);     \r\n\r\n      wind.prevWind.nextWind = wind.nextWind;      \r\n      if (wind != this.lastWind) {\r\n        wind.nextWind.prevWind = wind.prevWind;\r\n      } else {\r\n        this.lastWind = wind.prevWind;\r\n      }\r\n      \r\n      if (wind == this.currentWind) {\r\n        this.currentWind = wind.prevWind;\r\n        if (this.numberOfWinds > 1) {\r\n          this.currentWind.arrow.setSelection(true);\r\n        } \r\n        //this.printCurrentWindWindow();\r\n        this.windOutput.print(this.currentWind);        \r\n      }\r\n                                    \r\n      this.numberOfWinds--;       \r\n      \r\n      if (this.numberOfWinds == 1) {\r\n        this.firstWind.arrow.removePlacemark();\r\n        this.currentWind.arrow.setSelection(false);        \r\n      }                       \r\n    }\r\n    \r\n    \r\n    moveCurrentPointer(wind) {      \r\n      if (wind == this.currentWind) return;      \r\n      this.currentWind.arrow.setSelection(false);            \r\n      this.currentWind = wind;\r\n      this.currentWind.arrow.setSelection(true); \r\n      this.windOutput.print(this.currentWind);  \r\n      //this.printCurrentWindWindow();      \r\n    }\r\n    \r\n    \r\n    moveCurrentPointerToPrev() {\r\n      if (this.numberOfWinds == 1) return;      \r\n      this.currentWind.arrow.setSelection(false);      \r\n      if (this.currentWind != this.firstWind) {\r\n        this.currentWind = this.currentWind.prevWind;\r\n      } else {\r\n        this.currentWind = this.lastWind;\r\n      }  \r\n      this.currentWind.arrow.setSelection(true); \r\n      //this.printCurrentWindWindow();\r\n      this.windOutput.print(this.currentWind);   \r\n    }\r\n    \r\n    \r\n    moveCurrentPointerToNext() {\r\n      if (this.numberOfWinds == 1) return;      \r\n      this.currentWind.arrow.setSelection(false);      \r\n      if (this.currentWind != this.lastWind) {\r\n        this.currentWind = this.currentWind.nextWind;\r\n      } else {\r\n        this.currentWind = this.firstWind;\r\n      }\r\n      this.currentWind.arrow.setSelection(true);      \r\n      //this.printCurrentWindWindow();\r\n      this.windOutput.print(this.currentWind);             \r\n    }\r\n    \r\n    /**\r\n     * Set height to this.currentWind and then order WindList for heights \r\n     * (increasing order, null is greater then number);\r\n     * you cannot change height of first wind (0) by construction.\r\n     * @param {number || null} height - Height of wind; if it is number then must be > 0.\r\n     * @return {boolean} - False if it is impossible to set this height \r\n     * (height is a number and such height has already existed).\r\n     */ \r\n    setHeightToCurrentWind(height) {\r\n      // We cannot change height for first (surface) wind by construction \r\n      if (this.currentWind == this.firstWind) {\r\n        throw(\"You cannot change height of this.firstWind!\");\r\n      }\r\n      \r\n      if ((typeof(height) == 'number') && (height <= 0)) {\r\n        throw(\"Height of winds must be > 0!\");\r\n      }      \r\n               \r\n      // Different cones must have different heights  \r\n      if (typeof(height) == 'number') {  \r\n        var wind = this.firstWind;        \r\n        while(true) {\r\n          if ((wind != this.currentWind) && (wind.getHeight() == height)) { \r\n            return(false);\r\n          }            \r\n          if ((wind == this.lastWind) || (wind.getHeight() == null)) break;          \r\n          wind = wind.nextWind;         \r\n        }\r\n      }     \r\n                        \r\n      var currentWind = this.currentWind;\r\n      \r\n      this.currentWind.setHeight(height);         \r\n      this.windOutput.print(this.currentWind);\r\n            \r\n      var wind = this.currentWind;\r\n \r\n      // Order windList by heights (increasing order, \r\n      // null values are greater than numbers)               \r\n      if (height == null) {         \r\n        while(true) {          \r\n          if (wind.nextWind == null || wind.nextWind.getHeight() == null) break;\r\n          var wind = wind.nextWind;        \r\n        }\r\n         \r\n        this.moveWind(currentWind, wind);\r\n              \r\n      } else {  // height is a number\r\n        \r\n        // Moving in previous order\r\n        if (wind.prevWind.getHeight() == null || \r\n            height < wind.prevWind.getHeight()) {  \r\n        \r\n          while(true) {\r\n            if (wind.prevWind.getHeight() != null) break; \r\n            wind = wind.prevWind;       \r\n          }\r\n              \r\n          while(true) {\r\n            if (height > wind.prevWind.getHeight()) break;\r\n            wind = wind.prevWind;\r\n          }\r\n          \r\n          this.moveWind(currentWind, wind.prevWind);\r\n          \r\n        } else {\r\n                \r\n          while(true) {\r\n            if (wind.nextWind == null || wind.nextWind.getHeight() == null ||\r\n                height < wind.nextWind.getHeight()) break;\r\n            wind = wind.nextWind;    \r\n          }\r\n          \r\n          this.moveWind(currentWind, wind);        \r\n        }                        \r\n      }\r\n      \r\n      return(true);            \r\n    }\r\n    \r\n    /**\r\n     * Move windA to be next wind for windB.\r\n     * Remember, that in WindList first wind always exists. \r\n     */\r\n    moveWind(windA, windB) {\r\n      if (windA == windB || windA == windB.nextWind) return;\r\n              \r\n      if (windB == this.lastWind) {\r\n        \r\n        windA.nextWind.prevWind = windA.prevWind;\r\n        windA.prevWind.nextWind = windA.nextWind;        \r\n                \r\n        windB.nextWind = windA;\r\n        windA.prevWind = windB;\r\n\r\n        this.lastWind = windA;         \r\n      } else if (windA == this.lastWind) {\r\n        \r\n        this.lastWind = windA.prevWind;\r\n        windA.prevWind.nextWind = null;        \r\n\r\n        windA.nextWind = windB.nextWind;        \r\n        windB.nextWind.prevWind = windA;\r\n        \r\n        windA.prevWind = windB;\r\n        windB.nextWind = windA;              \r\n      } else {  // both windA and windB are not lastWind\r\n        \r\n        windA.nextWind.prevWind = windA.prevWind;\r\n        windA.prevWind.nextWind = windA.nextWind;         \r\n        \r\n        windA.nextWind = windB.nextWind;        \r\n        windB.nextWind.prevWind = windA;\r\n\r\n        windA.prevWind = windB;\r\n        windB.nextWind = windA;                    \r\n      }       \r\n    }\r\n    \r\n    \r\n    setCurrentAngle(angle) {\r\n      this.currentWind.setAngle(angle);\r\n      this.windOutput.print(this.currentWind);             \r\n    }\r\n    \r\n    setCurrentValue(value) {\r\n      this.currentWind.setValue(value);\r\n      this.windOutput.print(this.currentWind);              \r\n    }\r\n    \r\n    /**\r\n     * It is good idea not to use this function in WindList methods\r\n     * (because it uses outer objects); use this function beyond WindList class.\r\n     */\r\n    printCurrentWindWindow() {\r\n      if (this.currentWind == this.firstWind) {\r\n        $(\"#windHeightInput\").prop(\"disabled\", true);\r\n        $(\"#removeWind\").prop(\"disabled\", true);          \r\n      } else {\r\n        $(\"#windHeightInput\").prop(\"disabled\", false);\r\n        $(\"#removeWind\").prop(\"disabled\", false);\r\n      }\r\n      $(\"#windHeightInput\").val(this.currentWind.getHeight());    \r\n      $(\"#windDirectionInput\").val(this.currentWind.getAngle());\r\n      $(\"#windValueInput\").val(this.currentWind.getValue());\r\n      $(\"#arrowScale\").prop(\"checked\", this.currentWind.arrow.getIsScaled());      \r\n    } \r\n       \r\n  }\r\n      \r\n  provide(WindList);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindList.js?");

/***/ }),

/***/ "./src/scripts/WindOutputElement.js":
/*!******************************************!*\
  !*** ./src/scripts/WindOutputElement.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindOutputElement', [\r\n  'OutputElement'       \r\n],\r\nfunction(provide, OutputElement) {\r\n  /**\r\n   * Window for outputing Wind value and Wind direction.\r\n   */\r\n  class WindOutputElement extends OutputElement {\r\n    \r\n    constructor(wind) {\r\n      super();\r\n      this.print(wind);\r\n    }\r\n    \r\n    /**\r\n     * @param {Wind} wind\r\n     */     \r\n    print(wind) {\r\n      var windHeight = wind.getHeight();\r\n      windHeight = (windHeight == null) ? '?' : windHeight;\r\n    \r\n      this.data.set(\"content\", \"Ветер: h = \" + windHeight + \"м, \" +\r\n        wind.getValue() + \" м/с, \" + wind.getDirection());        \r\n    }           \r\n  } \r\n  provide(WindOutputElement);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/WindOutputElement.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** \r\n * Program calculate height of Chute for \r\n * given point on the Path. Path is a set of line segments (edges).\r\n * You can input Path by clicking left mouse button.\r\n */\r\n \r\n      \r\nymaps.ready(init);  \r\nfunction init() {   \r\n  ymaps.modules.require([\r\n    'AppMap',\r\n    'WindList',     \r\n    'Chute',\r\n    'Path',    \r\n    'Calculator',  \r\n    'Menu', \r\n    'DialogWindows', \r\n    'Keyboard', \r\n    'Constant'\r\n  ]).spread(function (\r\n    AppMap,\r\n    WindList,     \r\n    Chute,\r\n    Path,      \r\n    Calculator, \r\n    Menu, \r\n    DialogWindows, \r\n    Keyboard, \r\n    Constant   \r\n  ) {\r\n    var map = new AppMap();\r\n    \r\n    var chute = new Chute(10, 5);  // Chute velocity = (10, 5) m/s \r\n\r\n    var windList = new WindList(map);  // Winds at several heights.\r\n     \r\n    var path = new Path(map);  // List of vertices, edges. \r\n    \r\n    var boundaryHeights = {\r\n      startHeight: Constant.defaultStartHeight, \r\n      finalHeight: Constant.defaultFinalHeight\r\n    };\r\n        \r\n    // Calculator will make all computations.\r\n    var calculator = new Calculator(\r\n      path, \r\n      chute,       \r\n      windList,\r\n      boundaryHeights      \r\n    );\r\n    path.setCalculator(calculator);     \r\n\r\n              \r\n    // Click on the map will add vertice to path\r\n    /*    \r\n    map.events.add('click', function(e) {\r\n      var point = e.get('coords');\r\n      path.addVertex(point);      \r\n    }); */\r\n\r\n   \r\n    var clickNumber = 0;\r\n\r\n    map.events.add('click', function(e) {\r\n      var point = e.get('coords');    \r\n      clickNumber++;\r\n      if (clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (clickNumber == 1) {  // Single Click\r\n            // We add vertex to path           \r\n            path.addVertex(point);                               \r\n          } else {  // Double Click\r\n            // We add new wind arrow (windsock)           \r\n            windList.addWind(point);\r\n            windList.printCurrentWindWindow();             \r\n          }\r\n          clickNumber = 0;           \r\n        }, 200);\r\n      }    \r\n    });\r\n    \r\n        \r\n    // Set of buttons in the left side of screen:\r\n    //   Settings, Chute, Wind, Help, Clean buttons. \r\n    var menu = new Menu(map, path);    \r\n\r\n    \r\n    // Add events processing for Dialog Windows:\r\n    //   for Settings, Chute, Wind windows.\r\n    DialogWindows.initializeWindows(\r\n      map, \r\n      path, \r\n      calculator, \r\n      chute, \r\n      windList, \r\n      boundaryHeights\r\n    );\r\n\r\n    \r\n    // Add keyboard events: \r\n    //   left, right, up, down pressing (for changing wind value and direction), \r\n    //   enter key press on <input> tag - to loose focus after pressing enter.  \r\n    Keyboard.startKeyboardProcessing(\r\n      windList, \r\n      calculator, \r\n      path\r\n    ); \r\n\r\n    \r\n    // After yandex maps search we should: \r\n    //   move wind arrows to the current screen, \r\n    //   add result of search to Settings Dialog Window.\r\n    map.setSearchProcessor(path, calculator, windList); \r\n  });      \r\n}\n\n//# sourceURL=webpack:///./src/scripts/index.js?");

/***/ }),

/***/ 0:
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/scripts/AppMap.js ./src/scripts/Arrow.js ./src/scripts/Calculator.js ./src/scripts/Chute.js ./src/scripts/CircleVertex.js ./src/scripts/Constant.js ./src/scripts/DialogWindows.js ./src/scripts/HeightOutputElement.js ./src/scripts/index.js ./src/scripts/Keyboard.js ./src/scripts/Menu.js ./src/scripts/MenuButton.js ./src/scripts/Output.js ./src/scripts/OutputElement.js ./src/scripts/Path.js ./src/scripts/PathEdge.js ./src/scripts/TriangleVertex.js ./src/scripts/VectorMath.js ./src/scripts/Vertex.js ./src/scripts/Wind.js ./src/scripts/WindList.js ./src/scripts/WindOutputElement.js ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/scripts/AppMap.js */\"./src/scripts/AppMap.js\");\n__webpack_require__(/*! ./src/scripts/Arrow.js */\"./src/scripts/Arrow.js\");\n__webpack_require__(/*! ./src/scripts/Calculator.js */\"./src/scripts/Calculator.js\");\n__webpack_require__(/*! ./src/scripts/Chute.js */\"./src/scripts/Chute.js\");\n__webpack_require__(/*! ./src/scripts/CircleVertex.js */\"./src/scripts/CircleVertex.js\");\n__webpack_require__(/*! ./src/scripts/Constant.js */\"./src/scripts/Constant.js\");\n__webpack_require__(/*! ./src/scripts/DialogWindows.js */\"./src/scripts/DialogWindows.js\");\n__webpack_require__(/*! ./src/scripts/HeightOutputElement.js */\"./src/scripts/HeightOutputElement.js\");\n__webpack_require__(/*! ./src/scripts/index.js */\"./src/scripts/index.js\");\n__webpack_require__(/*! ./src/scripts/Keyboard.js */\"./src/scripts/Keyboard.js\");\n__webpack_require__(/*! ./src/scripts/Menu.js */\"./src/scripts/Menu.js\");\n__webpack_require__(/*! ./src/scripts/MenuButton.js */\"./src/scripts/MenuButton.js\");\n__webpack_require__(/*! ./src/scripts/Output.js */\"./src/scripts/Output.js\");\n__webpack_require__(/*! ./src/scripts/OutputElement.js */\"./src/scripts/OutputElement.js\");\n__webpack_require__(/*! ./src/scripts/Path.js */\"./src/scripts/Path.js\");\n__webpack_require__(/*! ./src/scripts/PathEdge.js */\"./src/scripts/PathEdge.js\");\n__webpack_require__(/*! ./src/scripts/TriangleVertex.js */\"./src/scripts/TriangleVertex.js\");\n__webpack_require__(/*! ./src/scripts/VectorMath.js */\"./src/scripts/VectorMath.js\");\n__webpack_require__(/*! ./src/scripts/Vertex.js */\"./src/scripts/Vertex.js\");\n__webpack_require__(/*! ./src/scripts/Wind.js */\"./src/scripts/Wind.js\");\n__webpack_require__(/*! ./src/scripts/WindList.js */\"./src/scripts/WindList.js\");\nmodule.exports = __webpack_require__(/*! ./src/scripts/WindOutputElement.js */\"./src/scripts/WindOutputElement.js\");\n\n\n//# sourceURL=webpack:///multi_./src/scripts/AppMap.js_./src/scripts/Arrow.js_./src/scripts/Calculator.js_./src/scripts/Chute.js_./src/scripts/CircleVertex.js_./src/scripts/Constant.js_./src/scripts/DialogWindows.js_./src/scripts/HeightOutputElement.js_./src/scripts/index.js_./src/scripts/Keyboard.js_./src/scripts/Menu.js_./src/scripts/MenuButton.js_./src/scripts/Output.js_./src/scripts/OutputElement.js_./src/scripts/Path.js_./src/scripts/PathEdge.js_./src/scripts/TriangleVertex.js_./src/scripts/VectorMath.js_./src/scripts/Vertex.js_./src/scripts/Wind.js_./src/scripts/WindList.js_./src/scripts/WindOutputElement.js?");

/***/ })

/******/ });