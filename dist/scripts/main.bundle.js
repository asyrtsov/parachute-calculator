/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src-compiled/scripts/AppMap.js":
/*!****************************************!*\
  !*** ./src-compiled/scripts/AppMap.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('AppMap', ['Map', 'control.ZoomControl', 'Constant', 'MenuButton', 'OutputElement', 'Arrow'], function (provide, Map, ZoomControl, Constant, MenuButton, OutputElement, Arrow) {\n  var AppMap = function (_Map) {\n    _inherits(AppMap, _Map);\n\n    function AppMap() {\n      _classCallCheck(this, AppMap);\n\n      // Array of Dropzones and their coordinates.\n      var dz = [{ name: 'Коломна!!!', mapCenter: [55.091289443603706, 38.917269584802675] }, { name: 'Пущино', mapCenter: [54.78929269708931, 37.64268598670033] }, { name: 'Ватулино', mapCenter: [55.663193308717396, 36.14121807608322] }, { name: 'Skydive Dubai', mapCenter: [25.089337722640472, 55.13236164813229] }];\n\n      var _this = _possibleConstructorReturn(this, (AppMap.__proto__ || Object.getPrototypeOf(AppMap)).call(this, 'map', {\n        center: dz[0].mapCenter,\n        zoom: Constant.defaultZoom\n      }, {\n        suppressMapOpenBlock: true // remove button 'open in yandex maps'\n      }));\n\n      _this.dz = dz;\n      _this.path = null;\n\n      // view from space\n      _this.setType('yandex#satellite');\n      _this.cursors.push('arrow');\n      _this.controls.remove('trafficControl');\n      _this.controls.remove('zoomControl');\n      var zoomControl = new ZoomControl({ options: {\n          position: { right: 10, top: 105 },\n          size: 'small'\n        } });\n      _this.controls.add(zoomControl);\n      _this.controls.remove('geolocationControl');\n      _this.controls.remove('fullscreenControl');\n\n      _this.searchControl = _this.controls.get('searchControl');\n      _this.searchControl.options.set('size', 'small');\n      _this.searchControl.options.set('noPlacemark', true);\n      _this.searchControl.options.set('noSelect', true);\n      _this.searchControl.options.set('position', { top: 10, left: 45 });\n\n      // Settings menu (ymaps.Button)\n      var settingsButton = new MenuButton('Настройки', 'images/icon_menu.svg', '#settingsMenu', '#settingsMenuDarkScreen');\n      _this.controls.add(settingsButton, { position: { top: 10, left: 10 } });\n\n      // Output for Surface wind parameters (ymaps.Button)\n      _this.windOutput = new OutputElement();\n      _this.controls.add(_this.windOutput, { position: { bottom: 30, left: 10 } });\n\n      // Wind arrow (Windsock)\n      _this.arrow = new Arrow(_this.getCenter());\n      _this.geoObjects.add(_this.arrow);\n\n      // remove standart map zoom for double click\n      _this.events.add('dblclick', function (e) {\n        e.preventDefault();\n      });\n\n      _this.moveArrow = _this.moveArrow.bind(_this);\n      _this.events.add('boundschange', _this.moveArrow);\n\n      _this.searchControl.events.add('resultshow', function (e) {\n        this.processResultShow(e);\n      }.bind(_this));\n      return _this;\n    }\n\n    /**\r\n     * If arrow is out of the screen, we should\r\n     * shift it to to the center of the screen.\r\n     */\n\n\n    _createClass(AppMap, [{\n      key: 'moveArrow',\n      value: function moveArrow() {\n        var arrowGeoCoordinates = this.arrow.geometry.getCoordinates();\n        var arrowPixelCoordinates = this.getPixelCoordinates(arrowGeoCoordinates);\n\n        var _arrowPixelCoordinate = _slicedToArray(arrowPixelCoordinates, 2),\n            x = _arrowPixelCoordinate[0],\n            y = _arrowPixelCoordinate[1];\n\n        if (x < 0 || y < 0 || x > screen.width || y > screen.height) {\n          this.arrow.setCoordinates(this.getCenter());\n        }\n      }\n\n      /**\r\n       * @param {number[]} point - Geo object coordinates.\r\n       * @returns {number[]} - Pixel coordinates.\r\n       */\n\n    }, {\n      key: 'getPixelCoordinates',\n      value: function getPixelCoordinates(point) {\n        var projection = this.options.get('projection');\n        return this.converter.globalToPage(projection.toGlobalPixels(point, this.getZoom()));\n      }\n    }, {\n      key: 'getPixelDistance',\n      value: function getPixelDistance(pointA, pointB) {\n        var x = this.getPixelCoordinates(pointB)[0] - this.getPixelCoordinates(pointA)[0];\n        var y = this.getPixelCoordinates(pointB)[1] - this.getPixelCoordinates(pointA)[1];\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n      }\n    }, {\n      key: 'setPath',\n      value: function setPath(path) {\n        this.path = path;\n      }\n\n      /**\r\n       * Processing Search result event.\r\n       * You should set up this.path before using this function.\r\n       */\n\n    }, {\n      key: 'processResultShow',\n      value: function processResultShow(e) {\n        this.path.clear();\n        this.setZoom(Constant.defaultZoom);\n        this.arrow.setCoordinates(this.getCenter());\n        var index = e.get('index');\n        var geoObjectsArray = this.searchControl.getResultsArray();\n        var resultName = geoObjectsArray[index].properties.get('name');\n        var newDz = {\n          name: resultName,\n          mapCenter: this.getCenter()\n        };\n        this.dz.push(newDz);\n        $('#dz').append('<option>' + newDz.name + '</option>');\n        $('#dz').children()[this.dz.length - 1].selected = true;\n      }\n    }]);\n\n    return AppMap;\n  }(Map);\n\n  provide(AppMap);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/AppMap.js?");

/***/ }),

/***/ "./src-compiled/scripts/Arrow.js":
/*!***************************************!*\
  !*** ./src-compiled/scripts/Arrow.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('Arrow', ['Placemark', 'templateLayoutFactory', 'Constant'], function (provide, Placemark, templateLayoutFactory, Constant) {\n  /**\r\n   * Wind Arrow (Yandex Maps API Placemark).\r\n   * You can: rotate it, change its size and coordinates.\r\n   */\n  var Arrow = function (_Placemark) {\n    _inherits(Arrow, _Placemark);\n\n    function Arrow() {\n      var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      _classCallCheck(this, Arrow);\n\n      var arrowStartSize = 25;\n      // radius of start active area for Arrow\n      var arrowStartRadius = Constant.isMobile ? arrowStartSize : arrowStartSize / 2;\n\n      var _this = _possibleConstructorReturn(this, (Arrow.__proto__ || Object.getPrototypeOf(Arrow)).call(this, [], {\n        arrowClass: 'arrow',\n        rotation: 0,\n        size: arrowStartSize\n      }, {\n        draggable: true,\n        iconLayout: templateLayoutFactory.createClass('<div class=\"$[properties.arrowClass]\" ' + 'style=\"transform: rotate($[properties.rotation]deg);' + 'width: $[properties.size]px; height: $[properties.size]px;\"/>'),\n        iconShape: {\n          type: 'Circle',\n          coordinates: [arrowStartSize / 2, arrowStartSize / 2],\n          radius: arrowStartRadius\n        }\n      }));\n\n      _this.arrowStartSize = arrowStartSize;\n      _this.arrowStartRadius = arrowStartRadius;\n\n      if (coordinates != null) {\n        _this.setCoordinates(coordinates);\n      }\n\n      _this.boundChange = _this.boundChange.bind(_this);\n      return _this;\n    }\n\n    _createClass(Arrow, [{\n      key: 'setCoordinates',\n      value: function setCoordinates(coordinates) {\n        this.geometry.setCoordinates(coordinates);\n      }\n\n      /**\r\n       * Rotate arrow\r\n       * @param {Number} angle - In degrees.\r\n       */\n\n    }, {\n      key: 'rotate',\n      value: function rotate(angle) {\n        this.properties.set('rotation', -1 * angle);\n      }\n\n      /**\r\n       * Arrow can have different size for different Zoom.\r\n       */\n\n    }, {\n      key: 'changeSize',\n      value: function changeSize(newZoom) {\n        var size = Math.pow(2, newZoom - Constant.defaultZoom) * this.arrowStartSize;\n\n        var shape = {\n          type: 'Circle',\n          coordinates: [size / 2, size / 2],\n          radius: Math.pow(2, newZoom - Constant.defaultZoom) * this.arrowStartRadius\n        };\n\n        this.options.set('iconShape', shape);\n        this.properties.set('size', size);\n        // properties.set call rebuild of Placemark,\n        // so, properties.set should stay after options.set\n      }\n\n      /**\r\n       * If Yandex Maps Zoom is changed we will call this.changeSize() function.\r\n       * @param {Event} e - Yandex Maps 'boundschange' event.\r\n       */\n\n    }, {\n      key: 'boundChange',\n      value: function boundChange(e) {\n        var newZoom = e.get('newZoom'),\n            oldZoom = e.get('oldZoom');\n        if (newZoom != oldZoom) {\n          this.changeSize(newZoom);\n        }\n      }\n    }]);\n\n    return Arrow;\n  }(Placemark);\n\n  provide(Arrow);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Arrow.js?");

/***/ }),

/***/ "./src-compiled/scripts/Calculator.js":
/*!********************************************!*\
  !*** ./src-compiled/scripts/Calculator.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('Calculator', ['VectorMath', 'Constant'], function (provide, VectorMath, Constant) {\n  /**\r\n   * This class calculates:\r\n   * a) heights at all vertices of the Path\r\n   * (it will be kept in vertex.height varialables where vertex belongs\r\n   * to Path),\r\n   * b) points on the Path where wind changes (it will be kept in\r\n   * wind.vertex varialables where wind belongs to WindList).\r\n   */\n  var Calculator = function () {\n    /**\r\n     * @param {Path} path - list of vertices and edges of Chute Path.\r\n     * @param {Chute} chute - Chute velocity.\r\n     * @param {WindList} windList\r\n     */\n    function Calculator(path, chute, windList) {\n      _classCallCheck(this, Calculator);\n\n      this.path = path;\n      this.chute = chute;\n      this.windList = windList;\n\n      // If edgeChuteVelocity is positive and less than this value,\n      // will will suppose that edgeChuteVelocity is equals this value. In m/s.\n      this.minEdgeChuteVelocity = 0.001;\n    }\n\n    /**\r\n     * Calculate first wind that less than this vertex.height.\r\n     * @param {Vertex} vertex\r\n     * @returns {Wind | null}\r\n     */\n\n\n    _createClass(Calculator, [{\n      key: 'calculateVertexNextWind',\n      value: function calculateVertexNextWind(vertex) {\n        if (vertex == this.path.lastVertex || vertex.height <= 0) {\n          return null;\n        }\n        var wind = this.windList.lastWind;\n        while (true) {\n          if (wind.height < vertex.height) {\n            return wind.height >= vertex.nextVertex.height ? wind : null;\n          }\n          wind = wind.prevWind;\n          if (wind == null) {\n            return null;\n          }\n        }\n      }\n\n      /**\r\n       *\r\n       */\n\n    }, {\n      key: 'calculatePathWindList',\n      value: function calculatePathWindList() {\n        var wind = this.windList.lastWind;\n        var windVertex = wind.vertex;\n        var pathVertex = this.path.firstVertex;\n        var vertex = pathVertex.height >= windVertex.height ? pathVertex.height : windVertex.height;\n        while (true) {}\n      }\n    }, {\n      key: 'calculatePathWindList',\n      value: function calculatePathWindList() {}\n\n      /**\r\n       * Clearing directions: skydiver will fly face forward.\r\n       */\n      /*\r\n      clearVertexDirections() {\r\n        var wind = this.windList.firstWind;\r\n        while(true) {\r\n          wind.vertex.chuteImage.chuteDirection = true;\r\n          wind.vertex.chuteImageBack.chuteDirection = true;\r\n          wind = wind.nextWind;\r\n          if (wind == null) break;\r\n        }\r\n        var vertex = this.path.firstVertex;\r\n        while(true) {\r\n          if (vertex == null) break;\r\n          vertex.chuteImage.chuteDirection = true;\r\n          vertex.chuteImageBack.chuteDirection = true;\r\n          vertex = vertex.nextVertex;\r\n        }\r\n      }  */\n\n      /**\r\n       * Main calculation function.\r\n       */\n\n    }, {\n      key: 'calculateHeight',\n      value: function calculateHeight() {\n        var fromBaseToLast = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        if (this.path.length == 0) {\n          this.windList.hide();\n          return;\n        }\n\n        switch (fromBaseToLast) {\n          case true:\n            this.calculateHeightForward();\n            break;\n\n          case false:\n            this.calculateHeightBack();\n            break;\n\n          case null:\n            this.calculateHeightForward();\n            this.calculateHeightBack();\n        }\n      }\n\n      /**\r\n       * Case: calculation from Base Vertex to Last Vertex\r\n       * (height is decreasing).\r\n       */\n\n    }, {\n      key: 'calculateHeightForward',\n      value: function calculateHeightForward() {\n        var path = this.path,\n            chute = this.chute,\n            windList = this.windList,\n            map = this.path.map;\n\n        //console.log('calculateHeightForward');\n\n        var vertexA = path.baseVertex;\n        var wind = windList.lastWind;\n\n        // Skip to wind corresponding to base vertex\n        // (first wind, such that wind.height < vertexA.height)\n        // Note: height in base vertex should be >= 0.\n        if (vertexA.height > 0) {\n          while (wind.height >= vertexA.height) {\n            wind = wind.prevWind;\n          }\n        } else {\n          wind = windList.firstWind;\n        }\n\n        // Case: nothing to calculate.\n        if (vertexA == path.lastVertex) {\n          while (wind != null) {\n            wind.vertex.hide();\n            wind = wind.prevWind;\n          }\n          return;\n        }\n\n        // vertexB will always be PathVertex,\n        // later vertexA can be PathVertex or WindVertex.\n        var vertexB = vertexA.nextVertex;\n\n        var edgeChuteDirection;\n        var chutePolarAngle;\n        var chuteCanFlyAlongLine;\n\n        if (vertexA.height > 0) {\n          while (true) {\n            // edgeChuteVelocity is velocity along edge [pointA, pointB] at pointA.\n            // 'wind' is a wind in pointA.\n            // Our aim is to calculate height in pointB.\n\n            var pointA = vertexA.getCoordinates();\n            var pointB = vertexB.getCoordinates();\n            edgeChuteDirection = vertexA.chuteImage.chuteDirection;\n\n            var calcResults = this.calculateChuteVelocity(pointA, pointB, chute, wind, edgeChuteDirection);\n\n            var edgeChuteVelocity = calcResults.chuteEdgeVelocity;\n            chutePolarAngle = calcResults.chutePolarAngle;\n            // Convert from Radians to Degrees.\n            chutePolarAngle = chutePolarAngle / Math.PI * 180;\n            chuteCanFlyAlongLine = calcResults.chuteCanFlyAlongLine;\n\n            if (!chuteCanFlyAlongLine) {\n              break;\n            }\n\n            if (edgeChuteVelocity < 0) {\n              break;\n            }\n\n            if (edgeChuteVelocity < this.minEdgeChuteVelocity) {\n              edgeChuteVelocity = this.minEdgeChuteVelocity;\n            }\n\n            if (edgeChuteVelocity > 0) {\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\n              var t1 = dist / edgeChuteVelocity; // t1 > 0 always.\n\n              var t2;\n              if (vertexA.height > 0) {\n                // Main case.\n                // t2 > 0 always.\n                t2 = (vertexA.height - wind.height) / chute.verticalVel;\n              } else {\n                t2 = t1 + 1; // We only want t2 to be greater than t1.\n              }\n\n              if (t2 >= t1) {\n                // Case: with current wind, chute will reach (vertexB) pointB\n\n                if (edgeChuteVelocity == this.minEdgeChuteVelocity) break;\n\n                vertexB.setHeight(vertexA.height - t1 * this.chute.verticalVel);\n                vertexB.prevEdge.hideDividingPoint();\n                vertexB.prevEdge.setColor('#0000FF'); // Blue color.\n\n                if (t2 == t1) {\n                  // It equals that vertexB.height == wind.height\n                  wind.vertex.setCoordinates(pointB);\n                  if (wind != windList.firstWind) {\n                    wind = wind.prevWind;\n                  }\n                }\n\n                //console.log(map.getPixelDistance(pointA, pointB));\n                if (map.getPixelDistance(pointA, pointB) > 50) {\n                  vertexA.chuteImage.setPosition(pointA, pointB, chutePolarAngle);\n                  vertexA.chuteImage.show();\n                } else {\n                  vertexA.chuteImage.hide();\n                }\n\n                vertexA = vertexB;\n                vertexB = vertexB.nextVertex;\n                if (vertexB == null) break;\n                continue;\n              } else {\n                var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\n\n                var pointC = VectorMath.findIntermediatePoint(pointA, pointB, t2 * edgeChuteVelocity / dist);\n\n                if (map.getPixelDistance(pointA, pointC) > 50) {\n                  vertexA.chuteImage.setPosition(pointC, pointA, chutePolarAngle);\n                  vertexA.chuteImage.show();\n                } else {\n                  vertexA.chuteImage.hide();\n                }\n\n                wind.vertex.setCoordinates(pointC);\n                vertexA = wind.vertex;\n\n                if (wind != windList.firstWind) {\n                  wind = wind.prevWind;\n                } else {\n                  // We reached height = 0 at vertexA.\n                  break;\n                }\n                continue;\n              }\n            }\n          }\n        } else {\n          // Case: path.baseVertex.height = 0.\n          //vertexA.chuteImage.hide();\n          wind.vertex.hide();\n        }\n\n        // Note: Now vertexA is a last achieved vertex.\n        if (vertexB != null) {\n          vertexB.setHeight(null);\n\n          var pointA = vertexA.getCoordinates();\n          var pointB = vertexB.getCoordinates();\n\n          if (vertexA.type == 'pathVertex') {\n            vertexA.nextEdge.hideDividingPoint();\n            vertexA.nextEdge.setColor('#FF0000');\n          } else {\n            // vertexA is a wind vertex\n            vertexB.prevEdge.setDividingPoint(pointA);\n            vertexB.prevEdge.setColor('#0000FF', '#FF0000');\n          }\n\n          if (chuteCanFlyAlongLine && vertexA.height != 0 && map.getPixelDistance(pointA, pointB) > 50) {\n            vertexA.chuteImage.show();\n            vertexA.chuteImage.setPosition(pointA, pointB, chutePolarAngle);\n          } else {\n            vertexA.chuteImage.hide();\n          }\n\n          var vertex = vertexB.nextVertex;\n          while (vertex != null) {\n            vertex.setHeight(null);\n            vertex.prevEdge.hideDividingPoint();\n            vertex.prevEdge.setColor('#FF0000'); // Red color.\n            vertex.prevVertex.chuteImage.hide();\n            vertex = vertex.nextVertex;\n          };\n        }\n\n        // Remove redundant wind points.\n        if (wind != windList.firstWind) {\n          while (wind != null) {\n            wind.vertex.hide();\n            wind = wind.prevWind;\n          }\n        } else if (vertexA.height > 0) {\n          wind.vertex.hide();\n        }\n      }\n\n      /**\r\n       * Case: calculation from Base Vertex to First Vertex\r\n       * (height is increasing).\r\n       */\n\n    }, {\n      key: 'calculateHeightBack',\n      value: function calculateHeightBack() {\n        var path = this.path,\n            chute = this.chute,\n            windList = this.windList,\n            map = this.path.map;\n\n        //console.log('calculateHeightBack');\n\n        var vertexB = path.baseVertex;\n        var wind = windList.lastWind;\n\n        // Find wind, corresponding to base vertex.\n        if (vertexB.height > 0) {\n          while (wind.height > vertexB.height) {\n            wind = wind.prevWind;\n          }\n        } else {\n          wind = windList.firstWind;\n        }\n\n        // Case: nothing to calculate.\n        if (vertexB == path.firstVertex) {\n          wind = wind.nextWind;\n          while (wind != null) {\n            wind.vertex.hide();\n            wind = wind.nextWind;\n          }\n          return;\n        }\n\n        //console.log('vertexB.height:' + vertexB.height);\n        //console.log('wind.height:' + wind.height);\n\n        if (vertexB == path.lastVertex && vertexB.height == wind.height) {\n          //console.log('hide')\n          wind.vertex.hide();\n        }\n\n        // vertexA will always be PathVertex,\n        // later vertexB can be PathVertex or WindVertex.\n        var vertexA = vertexB.prevVertex;\n\n        // We will show vertex.chuteImageBack instead of\n        // vertex.chuteImage.\n        /*\r\n        var vertex = vertexA;\r\n        while(vertex != null) {\r\n          vertex.chuteImage.hide();\r\n          vertex = vertex.prevVertex;\r\n        } */\n\n        var edgeChuteDirection;\n        var chutePolarAngle;\n        var chuteCanFlyAlongLine;\n\n        while (true) {\n          // Note: here pointA is only for setting direction;\n          // if there will be changing wind on the edge,\n          // the chute will fly with following velocity only after\n          // last changing (in the direction, determined by\n          // vector pointApointB)\n\n          var pointA = vertexA.getCoordinates();\n          var pointB = vertexB.getCoordinates();\n\n          // WindVertex coincides with PathVertex.\n\n          /*\r\n          if (wind.height == vertexB.height) {\r\n            wind.vertex.setCoordinates(pointB);\r\n            //if (vertexB == path.lastVertex) {\r\n              wind.vertex.chuteImage.hide();\r\n            //}\r\n          }  */\n\n          //edgeChuteDirection = vertexA.chuteImage.chuteDirection;\n\n          edgeChuteDirection = vertexB.chuteImageBack.chuteDirection;\n\n          var calcResults = this.calculateChuteVelocity(pointA, pointB, chute, wind, edgeChuteDirection);\n          var edgeChuteVelocity = calcResults.chuteEdgeVelocity;\n          chutePolarAngle = calcResults.chutePolarAngle;\n          chutePolarAngle = chutePolarAngle / Math.PI * 180;\n          var chuteCanFlyAlongLine = calcResults.chuteCanFlyAlongLine;\n\n          // In this case it is impossible to flight this edge\n          // Explanation: edgeChuteVelocity will be the same\n          // for any pointA from line pointApointB.\n          if (!chuteCanFlyAlongLine || edgeChuteVelocity < 0) {\n            break;\n          }\n\n          // Case: edgeChuteVelocity >= 0\n          if (edgeChuteVelocity < this.minEdgeChuteVelocity) {\n            edgeChuteVelocity = this.minEdgeChuteVelocity;\n          }\n\n          var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\n          var t1 = dist / edgeChuteVelocity; // t1 > 0 always.\n\n          var t2;\n          if (vertexB.height >= 0) {\n            // Main case.\n            if (wind != windList.lastWind) {\n              // t2 > 0 always.\n              t2 = (wind.nextWind.height - vertexB.height) / chute.verticalVel;\n            } else {\n              // wind = windList.lastWind.\n              t2 = t1 + 1; // We only want t2 to be greater than t1.\n            }\n          } else {\n            t2 = -vertexB.height / chute.verticalVel;\n          }\n\n          if (t2 >= t1) {\n            // Case: with current wind, vertexB is reachable from vertexA\n\n            if (edgeChuteVelocity == this.minEdgeChuteVelocity) break;\n\n            vertexA.setHeight(vertexB.height + t1 * this.chute.verticalVel);\n            vertexA.nextEdge.hideDividingPoint(); // Edge between A and B.\n            // Blue color.\n            vertexA.nextEdge.setColor('#0000FF');\n            //vertexA.chuteImage.setPosition(pointA, pointB, chutePolarAngle);\n            //vertexA.chuteImage.show();\n\n            if (map.getPixelDistance(pointA, pointB) > 50) {\n              vertexB.chuteImageBack.setPosition(pointA, pointB, chutePolarAngle);\n              vertexB.chuteImageBack.show();\n            } else {\n              vertexB.chuteImageBack.hide();\n            }\n\n            // It equals: t1 == t2.\n            if (wind.height == vertexA.height) {\n              wind.vertex.setCoordinates(pointA);\n              if (wind != windList.lastWind) {\n                wind = wind.nextWind;\n              }\n              //if (vertexB == path.lastVertex) {\n              //  wind.vertex.chuteImage.hide();\n              //}\n            }\n\n            vertexB = vertexA;\n            vertexA = vertexA.prevVertex;\n            if (vertexA == null) break;\n            continue;\n          } else {\n            // Case: with current wind, vertexB is NOT reachable from vertexA\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\n\n            var pointC = VectorMath.findIntermediatePoint(pointB, pointA, t2 * edgeChuteVelocity / dist);\n\n            //if (vertexB.height >= 0) {\n            //  wind = wind.nextWind;\n            //}\n\n            //if (wind != windList.lastWind) {\n            wind = wind.nextWind;\n            // }\n\n            wind.vertex.setCoordinates(pointC);\n            //vertexB = wind.vertex;\n            //vertexB.chuteImage.setPosition(pointC, pointB, chutePolarAngle);\n            //vertexB.chuteImage.show();\n\n            if (map.getPixelDistance(pointC, pointB) > 50) {\n              vertexB.chuteImageBack.setPosition(pointC, pointB, chutePolarAngle);\n              vertexB.chuteImageBack.show();\n            } else {\n              vertexB.chuteImageBack.hide();\n            }\n\n            vertexB = wind.vertex;\n\n            continue;\n          }\n        }\n\n        if (vertexA != null) {\n          vertexA.setHeight(null);\n          //vertexA.chuteImage.hide();\n\n          var pointA = vertexA.getCoordinates();\n          var pointB = vertexB.getCoordinates();\n\n          if (vertexB.type == 'pathVertex') {\n            vertexA.nextEdge.hideDividingPoint();\n            vertexA.nextEdge.setColor('#FF0000');\n          } else {\n            // vertexB is a WindVertex\n            vertexA.nextEdge.setDividingPoint(pointB);\n            vertexA.nextEdge.setColor('#FF0000', '#0000FF');\n          }\n\n          if (chuteCanFlyAlongLine && map.getPixelDistance(pointA, pointB) > 50) {\n            vertexB.chuteImageBack.show();\n            vertexB.chuteImageBack.setPosition(pointA, pointB, chutePolarAngle);\n          } else {\n            vertexB.chuteImageBack.hide();\n          }\n\n          //var vertex = vertexA.prevVertex;\n          //vertexA.chuteImageBack.hide();\n          var vertex = vertexA.prevVertex;\n          while (vertex != null) {\n            vertex.setHeight(null);\n            vertex.nextEdge.hideDividingPoint();\n            vertex.nextEdge.setColor('#FF0000'); // Red color.\n            //vertex.chuteImage.hide();\n            vertex.nextVertex.chuteImageBack.hide();\n            vertex = vertex.prevVertex;\n          };\n        }\n\n        // Hide redundant wind points.\n        wind = wind.nextWind;\n        while (wind != null) {\n          wind.vertex.hide();\n          wind = wind.nextWind;\n        }\n      }\n\n      /**\r\n       * Calculate Polar angle of Chute Velocity and\r\n       * Absolute (relatively to Earth) Chute Velocity along Line Segment\r\n       * (we suppose that chute is flying along this line segment).\r\n       * @param {number[]} pointA - Yandex Maps Coordinates: (latitude, longitude).\r\n       * @param {number[]} pointB - Yandex Maps Coordinates: (latitude, longitude).\r\n       * @param {Chute} chute\r\n       * @param {Wind} wind\r\n       * @param [boolean] edgeChuteDirection - Skydiver can fly with his face directed\r\n       * with or against edge.\r\n       * @returns {Object} Object\r\n       * @returns {number} Object.chuteEdgeVelocity - Absolute Chute Velocity along\r\n       * line segment [pointA, pointB]; in m/sec;\r\n       * Cases: chuteEdgeVelocity < 0 - In this case it is impossible to fly this segment;\r\n       * chuteEdgeVelocity == 0 - hanging above pointA;\r\n       * chuteEdgeVelocity > 0 - chute will fly from pointA to pointB.\r\n       * @returns {number} Object.chutePolarAngle - Polar angle of Chute Velocity, in Radians.\r\n       * @returns {boolean} Object.chuteCanFlyAlongLine - Is true iff chute velotity\r\n       * is greater or equal to wind velocity projection to direction that is\r\n       * perpendicula to the Line Segment.\r\n       */\n\n    }, {\n      key: 'calculateChuteVelocity',\n      value: function calculateChuteVelocity(pointA, pointB, chute, wind) {\n        var edgeChuteDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n\n        /*\r\n         * Let's find right orthonormal basis (e, f), first vector of which (e)\r\n         * has the same direction with vector [pointA, pointB].\r\n         * Yandex Maps Coordinates: (latitude, longitude)\r\n         * Latitude is increasing from bottom to top (-90deg, 90deg)\r\n         * Longitude is increasing from West to East (-180deg, 180deg)\r\n         */\n\n        function sign(a) {\n          if (a > 0) return 1;\n          if (a == 0) return 0;\n          return -1;\n        }\n\n        var sx = sign(pointB[1] - pointA[1]);\n        var sy = sign(pointB[0] - pointA[0]);\n\n        var pointC = [pointA[0], pointB[1]];\n\n        // now (ex, ey) are coordinates of vector e in standart orthonormal basis:\n        // x has direction from left to right,\n        // y has direction from bottom to top,\n        // scale: 1 meter\n        var ex = sx * ymaps.coordSystem.geo.getDistance(pointC, pointA);\n        var ey = sy * ymaps.coordSystem.geo.getDistance(pointC, pointB);\n\n        // Polar angle of vector (pointA, pointB)\n        var angle1 = VectorMath.getPolarFromCartesian([ex, ey]).angle;\n\n        var d = Math.sqrt(ex * ex + ey * ey);\n        ex = ex / d;\n        ey = ey / d;\n\n        var fx = -ey;\n        var fy = ex;\n\n        // Let's find coordinates (we, wf) of vector 'wind' in basis (e, f).\n        // (e, f) is orthogonal basis, so we = (wind, e), wf = (wind, f).\n\n        var _wind$getXY = wind.getXY(),\n            _wind$getXY2 = _slicedToArray(_wind$getXY, 2),\n            wx = _wind$getXY2[0],\n            wy = _wind$getXY2[1];\n\n        var we = wx * ex + wy * ey;\n        var wf = wx * fx + wy * fy;\n\n        // Let's find coordinates (ce, cf) of chute velocity\n        // in basis (e, f):\n        var cf = -1 * wf;\n\n        // it is impossible to fly this segment\n        if (chute.horizontalVel < Math.abs(cf)) {\n          var _chutePolarAngle = VectorMath.getPolarFromCartesian([0, sign(cf) * chute.horizontalVel]).angle;\n          _chutePolarAngle += angle1;\n          return {\n            chuteEdgeVelocity: 0,\n            chutePolarAngle: _chutePolarAngle,\n            chuteCanFlyAlongLine: false\n          };\n        }\n\n        var directionSign = edgeChuteDirection ? 1 : -1;\n        var ce = directionSign * Math.sqrt(Math.pow(chute.horizontalVel, 2) - Math.pow(cf, 2));\n\n        // Polar angle of Chute velocity relative to bases {e, f}\n        var chutePolarAngle = VectorMath.getPolarFromCartesian([ce, cf]).angle;\n        // Polar angle of Chute velocity\n        chutePolarAngle += angle1;\n\n        var chuteEdgeVelocity = ce + we;\n        return {\n          chuteEdgeVelocity: chuteEdgeVelocity,\n          chutePolarAngle: chutePolarAngle,\n          chuteCanFlyAlongLine: true\n        };\n      }\n    }]);\n\n    return Calculator;\n  }();\n\n  provide(Calculator);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Calculator.js?");

/***/ }),

/***/ "./src-compiled/scripts/Chute.js":
/*!***************************************!*\
  !*** ./src-compiled/scripts/Chute.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('Chute', [], function (provide) {\n  var Chute =\n  /**\r\n   * @param {number} horizontalVel - Horizontal chute velocity, in m/sec.\r\n   * @param {number} verticalVel - Vertical chute velocity, in m/sec.\r\n   */\n  function Chute(horizontalVel, verticalVel) {\n    _classCallCheck(this, Chute);\n\n    this.horizontalVel = horizontalVel;\n    this.verticalVel = verticalVel;\n  };\n\n  provide(Chute);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Chute.js?");

/***/ }),

/***/ "./src-compiled/scripts/ChuteImage.js":
/*!********************************************!*\
  !*** ./src-compiled/scripts/ChuteImage.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('ChuteImage', ['Placemark', 'templateLayoutFactory', 'Constant'], function (provide, Placemark, templateLayoutFactory, Constant) {\n\n  /**\r\n   * Chute Image (Yandex Maps API Placemark).\r\n   * You can: rotate it and change its coordinates.\r\n   */\n  var ChuteImage = function (_Placemark) {\n    _inherits(ChuteImage, _Placemark);\n\n    /**\r\n     * @param {null | Number[]} coordinates\r\n     */\n    function ChuteImage() {\n      var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      _classCallCheck(this, ChuteImage);\n\n      var chuteStartSize = 25;\n      // radius of start active area for Arrow\n      var chuteStartRadius = Constant.isMobile ? chuteStartSize : chuteStartSize / 2;\n\n      // If this.chuteDirection = true, chute flyes along wind,\n      // else - opposite wind.\n      var _this = _possibleConstructorReturn(this, (ChuteImage.__proto__ || Object.getPrototypeOf(ChuteImage)).call(this, coordinates, {\n        chuteClass: 'chute',\n        rotation: 0,\n        size: chuteStartSize\n      }, {\n        iconLayout: templateLayoutFactory.createClass('<div class=\"$[properties.chuteClass]\" style=\"transform: rotate($[properties.rotation]deg);' + 'width: $[properties.size]px; height: $[properties.size]px;\"/>'),\n        iconOffset: [-12, -12],\n        iconShape: {\n          type: 'Circle',\n          coordinates: [chuteStartSize / 2, chuteStartSize / 2],\n          radius: chuteStartRadius\n        },\n        zIndex: 7\n      }));\n\n      _this.chuteDirection = true;\n      _this.calculator = null;\n\n      _this.events.add('click', function (e) {\n        e.stopPropagation(); // remove standart zoom for click\n        this.processChuteImageClick(e);\n      }.bind(_this));\n      return _this;\n    }\n\n    _createClass(ChuteImage, [{\n      key: 'setCalculator',\n      value: function setCalculator(calculator) {\n        this.calculator = calculator;\n      }\n    }, {\n      key: 'processChuteImageClick',\n      value: function processChuteImageClick() {\n        //console.log('click');\n        this.chuteDirection = !this.chuteDirection;\n        if (this.calculator != null) {\n          this.calculator.calculateHeight();\n        }\n      }\n\n      /**\r\n       * @param {Number[]} point\r\n       */\n\n    }, {\n      key: 'setCoordinates',\n      value: function setCoordinates(point) {\n        this.geometry.setCoordinates(point);\n      }\n    }, {\n      key: 'hide',\n      value: function hide() {\n        this.options.set('visible', false);\n      }\n    }, {\n      key: 'show',\n      value: function show() {\n        this.options.set('visible', true);\n      }\n\n      /**\r\n       * Rotate arrow\r\n       * @param {Number} angle - In degrees.\r\n       */\n\n    }, {\n      key: 'rotate',\n      value: function rotate(angle) {\n        this.properties.set('rotation', -1 * angle);\n      }\n\n      /**\r\n       * angle in degrees.\r\n       */\n\n    }, {\n      key: 'setPosition',\n      value: function setPosition(pointA, pointB, angle) {\n        this.setCoordinates([(pointA[0] + pointB[0]) / 2, (pointA[1] + pointB[1]) / 2]);\n        this.rotate(angle);\n      }\n    }]);\n\n    return ChuteImage;\n  }(Placemark);\n\n  provide(ChuteImage);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/ChuteImage.js?");

/***/ }),

/***/ "./src-compiled/scripts/Constant.js":
/*!******************************************!*\
  !*** ./src-compiled/scripts/Constant.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Constant */\nymaps.modules.define('Constant', [], function (provide) {\n\n  // Determine mobile or desktop case.\n  var isMobile = false;\n  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n    isMobile = true;\n  }\n  /** These varialables are constants for app */\n  var Constant = {\n    defaultBaseHeight: 300,\n    defaultStartHeight: 300,\n    defaultFinalHeight: 0,\n    defaultZoom: 16,\n    defaultCalculationDirection: true,\n    // We will not consider the cases when horizontal velocity\n    // is more than maxChuteHorizontalVelocity\n    maxChuteHorizontalVelocity: 100, // wingsuit\n    maxChuteVerticalVelocity: 50, // free fall\n    maxHeight: 15000,\n    maxWindValue: 40,\n    // If we will fly more than maxFlightTime, then\n    // it is impossible to fly this path\n    maxFlightTime: 3600, // 1 hour\n    isMobile: isMobile\n  };\n\n  provide(Constant);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Constant.js?");

/***/ }),

/***/ "./src-compiled/scripts/DialogWindows.js":
/*!***********************************************!*\
  !*** ./src-compiled/scripts/DialogWindows.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('DialogWindows', ['Constant', 'Wind'], function (provide, Constant, Wind) {\n\n  var DialogWindows = {};\n  /**\r\n   * @param {AppMap} map\r\n   * @param {Chute} chute\r\n   * @param {WindList} windList\r\n   * @param {Path} path\r\n   * @param {Calculator} calculator\r\n   */\n  DialogWindows.initMenu = function (map, chute, windList, path, calculator) {\n\n    // First active link in Menu will be Dz link\n    this.prevLinkId = 'helpLink';\n\n    initMenuWindow();\n    initDzWindow();\n    initChuteWindow();\n    initHeightWindow();\n    initWindWindow();\n\n    /**\r\n     * Settings Menu initialization\r\n     */\n    function initMenuWindow() {\n\n      $('#helpLinkContent').css('display', 'block');\n      $('#helpLink').addClass('active');\n      //$('#helpLink').css('color', '#0044BB');\n      // $('#helpLink').css('color', '#000000');\n      //$('#helpLink').css('font-weight', '700');\n      DialogWindows.prevLinkId = 'helpLink';\n\n      $('nav a').on('click', function (e) {\n        e.preventDefault();\n\n        var currentLinkId = $(this).attr('id');\n\n        $('#' + DialogWindows.prevLinkId + 'Content').css('display', 'none');\n        $('#' + currentLinkId + 'Content').css('display', 'block');\n\n        // $('#' + DialogWindows.prevLinkId).css('color', 'rgb(0, 0, 0, 0.5)');\n        //$('#' + DialogWindows.prevLinkId).css('color', '#999999');\n        // $('#' + DialogWindows.prevLinkId).css('font-weight', '400');\n        $('#' + DialogWindows.prevLinkId).removeClass('active');\n        $(this).addClass('active');\n        //$(this).css('color', '#0044BB');\n        // $(this).css('color', '#000000');\n        // $(this).css('font-weight', '700');\n\n        DialogWindows.prevLinkId = currentLinkId;\n      });\n\n      // Close Settings Menu after clicking Cross or Dark screen\n      $(\"#settingsMenuHeaderRectangle, #settingsMenuDarkScreenClickable\").click(function () {\n\n        $(\"#settingsMenuDarkScreen\").css(\"left\", \"-100%\");\n\n        if (window.matchMedia(\"(min-width: 768px)\").matches) {\n          $(\"#settingsMenu\").css(\"left\", \"-50%\");\n        } else {\n          $(\"#settingsMenu\").css(\"left\", \"-100%\");\n        }\n      });\n\n      // Loose focus after pressing Enter on input field.\n      $(\"input\").keypress(function (e) {\n        if (e.keyCode === 13 || e.keyCode === 9) {\n          // Enter keycode\n          $(\"input\").blur(); // Forced loose of focus\n        }\n      });\n    }\n\n    /**\r\n     * Dz Window initialization\r\n     */\n    function initDzWindow() {\n      // Set default options: dz array\n      for (var i = 0; i < map.dz.length; i++) {\n        $(\"#dz\").append(\"<option>\" + map.dz[i].name + \"</option>\");\n      }\n\n      $(\"#dz\").on(\"change\", function () {\n        var mapCenter = map.dz[this.selectedIndex].mapCenter;\n        map.setCenter(mapCenter, Constant.defaultZoom);\n        map.arrow.setCoordinates(mapCenter);\n        // path.clear() will print results too\n        path.clear();\n        clearVertexDirections();\n      });\n    }\n\n    /**\r\n     * Chute Window initialization.\r\n     */\n    function initChuteWindow() {\n      $(\"#chutehorvel\").val(chute.horizontalVel);\n      $(\"#chutevervel\").val(chute.verticalVel);\n\n      $(\"#chutehorvel\").on(\"change\", function () {\n        var chutehorvel = Number.parseFloat($(\"#chutehorvel\").val());\n        if (chutehorvel >= 0 && chutehorvel <= Constant.maxChuteHorizontalVelocity) {\n          chute.horizontalVel = chutehorvel;\n          $(\"#chutehorvel\").val(chutehorvel);\n          clearVertexDirections();\n          if (path.length > 0) {\n            calculator.calculateHeight();\n          }\n        } else {\n          // Incorrect value.\n          if (Number.isNaN(chutehorvel)) {\n            alert('Недопустимое значение!');\n          } else if (chutehorvel < 0) {\n            alert('Скорость должна быть неотрицательной!');\n          } else {\n            alert('Скорость должна быть не больше ' + Constant.maxChuteHorizontalVelocity + 'м/с !');\n          }\n          $(\"#chutehorvel\").val(chute.horizontalVel);\n          return;\n        }\n      });\n\n      $(\"#chutevervel\").on(\"change\", function () {\n        var chutevervel = Number.parseFloat($(\"#chutevervel\").val());\n        if (chutevervel >= 0 && chutevervel <= Constant.maxChuteVerticalVelocity) {\n          chute.verticalVel = chutevervel;\n          $(\"#chutevervel\").val(chutevervel);\n          clearVertexDirections();\n          if (path.length > 0) {\n            calculator.calculateHeight();\n          }\n        } else {\n          // Incorrect value.\n          if (Number.isNaN(chutevervel)) {\n            alert('Недопустимое значение!');\n          } else if (chutevervel < 0) {\n            alert('Скорость должна быть неотрицательной!');\n          } else {\n            alert('Скорость должна быть не больше ' + Constant.maxChuteVerticalVelocity + 'м/с !');\n          }\n          $(\"#chutevervel\").val(chute.verticalVel);\n          return;\n        }\n      });\n    }\n\n    /**\r\n     * Height Window initialization.\r\n     */\n    function initHeightWindow() {\n      $(\"#baseVertexHeight\").val(Math.floor(Constant.defaultBaseHeight));\n\n      $(\"#baseVertexHeight\").on(\"change\", function () {\n        var n = Number.parseFloat($(\"#baseVertexHeight\").val());\n\n        if (n >= 0 && n <= Constant.maxHeight) {\n          clearVertexDirections();\n          path.setBaseVertexHeight(n);\n          $(\"#baseVertexHeight\").val(Math.floor(n));\n        } else {\n\n          if (Number.isNaN(n)) {\n            alert('Недопустимое значение!');\n          } else {\n            if (n < 0) {\n              alert('Высота в базовой точке должна быть неотрицательной!');\n            } else {\n              alert('Высота в базовой точке должна быть не больше ' + Constant.maxHeight + 'м !');\n            }\n          }\n\n          if (path.length > 0) {\n            $(\"#baseVertexHeight\").val(Math.floor(path.baseVertex.height));\n          } else {\n            $(\"#baseVertexHeight\").val(Math.floor(path.baseVertexHeight));\n          }\n        }\n      });\n    }\n\n    /**\r\n     * Wind Window initialization.\r\n     */\n    function initWindWindow() {\n\n      $(\"#windValueInput\").prop(\"max\", \"\" + Constant.maxWindValue);\n      // Draw scales for Range Input Sliders in WindInput window\n      drawWindScales();\n\n      drawWindScreen();\n\n      /**\r\n       * Draw WindScreen window in Wind Menu\r\n       */\n      function drawWindScreen() {\n        $(\"#windInput\").addClass(\"displayNone\");\n        $(\"#windScreen\").removeClass(\"displayNone\");\n\n        var windTable = document.getElementById(\"windTable\");\n        windTable.innerHTML = '';\n        var funcArray = [];\n        var row = [];\n        var wind = windList.firstWind;\n        for (var i = 0; i < windList.numberOfWinds; i++) {\n          row[i] = windTable.insertRow(i);\n          funcArray[i] = createRowClickListener(wind);\n          row[i].addEventListener(\"click\", funcArray[i]);\n          var cell1 = row[i].insertCell(0);\n          var cell2 = row[i].insertCell(1);\n          var cell3 = row[i].insertCell(2);\n          cell1.innerHTML = wind.height == null ? \"?\" : wind.height + \" м\";\n          cell2.innerHTML = '<div class=\\\"arrow\\\"></div>';\n          cell2.firstChild.style.transform = \"rotate(\" + -1 * wind.getAngle() + \"deg)\";\n          cell3.innerHTML = wind.value + \" м/c\";\n          wind = wind.nextWind;\n        }\n\n        // Button Add Wind in WindScreen window\n        $(\"#addWind\").click(function () {\n          var w = new Wind(5, 0, null, map);\n\n          $(\"#addWind\").off('click');\n          for (var i = 0; i < row.length; i++) {\n            row[i].removeEventListener('click', funcArray[i]);\n          }\n          drawWindInput(w);\n        });\n\n        function createRowClickListener(w) {\n          return function (e) {\n            $(\"#windScreen\").addClass(\"displayNone\");\n            windList.currentWind = w;\n            $(\"#windInput\").removeClass(\"displayNone\");\n\n            $(\"#addWind\").off('click');\n            for (var i = 0; i < row.length; i++) {\n              row[i].removeEventListener('click', funcArray[i]);\n            }\n\n            drawWindInput(w);\n          };\n        }\n      }\n\n      /**\r\n       * Draw WindInput window in Wind Menu\r\n       */\n      function drawWindInput(wind) {\n        $(\"#windScreen\").addClass(\"displayNone\");\n        $(\"#windInput\").removeClass(\"displayNone\");\n\n        if (wind == windList.firstWind) {\n          $(\"#windHeightInput\").prop(\"disabled\", true);\n          $(\"#removeWind\").addClass(\"displayNone\");\n        } else {\n          $(\"#windHeightInput\").prop(\"disabled\", false);\n          $(\"#removeWind\").removeClass(\"displayNone\");\n        }\n        $(\"#windHeightInput\").val(wind.getHeight());\n        $(\"#windDirectionInput\").val(wind.getAngle());\n        $(\"#windValueInput\").val(wind.getValue());\n        var angle = wind.getAngle();\n        $(\"#menuArrow\").css(\"transform\", \"rotate(\" + -1 * angle + \"deg)\");\n        $(\"#menuWindValue\").html(wind.getValue() + \" м/с\");\n\n        // Button 'Back to WindScreen' in WindInput window\n        $(\"#windInputHeaderArrowRectangle\").click(function () {\n          $(\"#windHeightInput\").off(\"change\");\n          $(\"#windDirectionInput\").off('input change');\n          $(\"#windValueInput\").off('input change');\n          $(\"#removeWind\").off('click');\n          $(\"#windInputHeaderArrowRectangle\").off('click');\n          drawWindScreen();\n        });\n\n        // Button 'Remove current wind' in WindInput window\n        $(\"#removeWind\").click(function () {\n          if (wind.getHeight() != null) {\n            windList.removeWind(wind);\n\n            if (path.length > 0) {\n              calculator.calculateHeight();\n            }\n          }\n          $(\"#windHeightInput\").off(\"change\");\n          $(\"#windDirectionInput\").off('input change');\n          $(\"#windValueInput\").off('input change');\n          $(\"#removeWind\").off('click');\n          $(\"#windInputHeaderArrowRectangle\").off('click');\n          drawWindScreen();\n        });\n\n        // Input for WindHeight in WindInput window\n        $(\"#windHeightInput\").on(\"change\", function () {\n\n          var heightString = $(\"#windHeightInput\").val();\n          var height = Number.parseFloat(heightString);\n\n          if (!Number.isNaN(height)) {\n            if (height > 0) {\n              if (height <= Constant.maxHeight) {\n                if (!windList.heightIsInList(height)) {\n                  if (wind.height == null) {\n                    wind.setHeight(height);\n                    windList.addWind(wind);\n                  } else {\n                    wind.setHeight(height);\n                    windList.sortList();\n                  }\n\n                  clearVertexDirections();\n                  if (path.length > 0) {\n                    calculator.calculateHeight();\n                  }\n                } else {\n                  alertError('Такая высота уже была!');\n                }\n              } else {\n                // height > Constant.maxHeight\n                alertError('Высота должны быть не больше ' + Constant.maxHeight + ' м!');\n              }\n            } else if (height == 0) {\n              alertError('Поверхностный ветер уже задан!');\n            } else {\n              // height < 0\n              alertError('Высота должна быть больше нуля!');\n            }\n          } else {\n            alertError('Недопустимое значение!');\n          }\n\n          function alertError(str) {\n            alert(str);\n            $(\"#windHeightInput\").val(Math.floor(wind.height));\n          }\n        });\n\n        // Range Input Slider for Wind Direction in WindInput window.\n        $(\"#windDirectionInput\").on('input change', function () {\n          var angleStr = $(\"#windDirectionInput\").val();\n          var angle = Number.parseInt(angleStr);\n\n          wind.setAngle(angle);\n          if (wind == windList.firstWind) {\n            map.windOutput.print(wind.toString());\n            map.arrow.rotate(angle);\n          }\n\n          $(\"#menuArrow\").css(\"transform\", \"rotate(\" + -1 * angle + \"deg)\");\n\n          clearVertexDirections();\n\n          if (wind.height != null && path.length > 0) {\n            calculator.calculateHeight();\n          }\n        });\n\n        // Range Input Slider for  Wind Value in WindInput window.\n        $(\"#windValueInput\").on('input change', function () {\n          var valueStr = $(\"#windValueInput\").val();\n          var value = Number.parseInt(valueStr);\n\n          wind.setValue(value);\n          if (wind == windList.firstWind) {\n            map.windOutput.print(wind.toString());\n          }\n\n          $(\"#menuWindValue\").html(value + \" м/с\");\n\n          clearVertexDirections();\n\n          if (wind.height != null && path.length > 0) {\n            calculator.calculateHeight();\n          }\n        });\n      }\n    }\n\n    /**\r\n     * Draw scales for Wind Window:\r\n     *   wind direction scale (E, N, W, S, E),\r\n     *   wind velocity scale (0, ..., Constant.maxWindValue m/s)\r\n     */\n    function drawWindScales() {\n\n      // Create legend for direction range input\n      var directionPlateSpan = 5;\n      var directionPlateNumber = 4 * directionPlateSpan + 1;\n      var windValuePlateNumber = 0;\n\n      for (var i = 0; i < directionPlateNumber; i++) {\n        var str = \"\";\n        switch (i) {\n          case 0:\n            str = \"В\";\n            break;\n          case directionPlateSpan:\n            str = \"С\";\n            break;\n          case directionPlateSpan * 2:\n            str = \"З\";\n            break;\n          case directionPlateSpan * 3:\n            str = \"Ю\";\n            break;\n          case directionPlateSpan * 4:\n            str = \"В\";\n            break;\n          default:\n            str = \"&nbsp\";\n        }\n        $(\"#windDirectionInputScale\").append(\"<div class='directionPlate'>\" + str + \"</div>\");\n\n        var str2;\n        if (i % 5 == 0) {\n          str2 = windValuePlateNumber;\n          windValuePlateNumber += Constant.maxWindValue / 4;\n        } else {\n          str2 = \"&nbsp\";\n        }\n        $(\"#windValueInputScale\").append(\"<div class='directionPlate'>\" + str2 + \"</div>\");\n      }\n      $(\".directionPlate\").css({\n        \"width\": 100 / directionPlateNumber + \"%\",\n        \"float\": \"left\",\n        \"text-align\": \"center\"\n      });\n    }\n\n    /**\r\n     * Clearing directions: skydiver will fly face forward.\r\n     * We will clear direction after all changing in\r\n     * Dialog windows.\r\n     */\n    function clearVertexDirections() {\n      var wind = windList.firstWind;\n      while (true) {\n        wind.vertex.chuteImage.chuteDirection = true;\n        wind.vertex.chuteImageBack.chuteDirection = true;\n        wind = wind.nextWind;\n        if (wind == null) break;\n      }\n      var vertex = path.firstVertex;\n      while (true) {\n        if (vertex == null) break;\n        vertex.chuteImage.chuteDirection = true;\n        vertex.chuteImageBack.chuteDirection = true;\n        vertex = vertex.nextVertex;\n      }\n    }\n  };\n\n  provide(DialogWindows);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/DialogWindows.js?");

/***/ }),

/***/ "./src-compiled/scripts/Edge.js":
/*!**************************************!*\
  !*** ./src-compiled/scripts/Edge.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('Edge', ['Polygon', 'VectorMath'], function (provide, Polygon, VectorMath) {\n  /**\r\n   * PathEdge consists of two Rectangles:\r\n   * Image Rectangle and Invisible Event Rectangle.\r\n   * Invisible Event Rectangle is aimed for catching events\r\n   * (we use it to make GUI more friendly for Users in mobile case).\r\n   * Image Rectange consists of Blue Rectangle and Red Rectangle.\r\n   */\n  var Edge = function () {\n    /**\r\n     * @param {Vertex} prevVertex\r\n     * @param {Vertex} nextVertex\r\n     * @param {Path} edgeImageWidthWidth\r\n     */\n    //constructor(prevVertex, nextVertex, path, chuteDirection = true) {\n    function Edge(prevVertex, nextVertex, path) {\n      _classCallCheck(this, Edge);\n\n      this.prevVertex = prevVertex;\n      this.nextVertex = nextVertex;\n      this.path = path;\n      this.map = path.map;\n      // true - if Chute motion and Edge has the same direction\n      //this.chuteDirection = chuteDirection;\n\n      this.edgeWidth = 1;\n      this.edgeImageWidth = this.edgeWidth / 10; // edgeImageWidth;\n\n      this.scale = Math.pow(2, 16 - this.map.getZoom());\n      this.setScale = this.setScale.bind(this);\n      this.map.events.add('boundschange', this.setScale);\n\n      // Edge connects prevVertex, nextVertex, itself.\n      prevVertex.nextVertex = nextVertex;\n      prevVertex.nextEdge = this;\n      nextVertex.prevVertex = prevVertex;\n      nextVertex.prevEdge = this;\n\n      var zIndex = 0;\n\n      // Rectangle vertices will be calculated later\n      this.eventRectangle = new Polygon([], {}, {\n        fillOpacity: 0,\n        strokeOpacity: 0,\n        strokeWidth: 0,\n        zIndex: 9\n      });\n\n      this.firstImage = new Polygon([], {}, { zIndex: 4 });\n      this.secondImage = new Polygon([], {}, { zIndex: 4 });\n\n      this.dividingPoint = null;\n      this.calculateEdgeRectangles();\n      this.setColor('#0000FF'); // firstImage has blue color.\n\n      this.clickNumber = 0;\n\n      this.edgeIsOnMap = false;\n\n      //this.processVertexClick = this.processVertexClick.bind(this);\n\n      this.eventRectangle.events.add('click', function (e) {\n        e.stopPropagation(); // remove standart zoom for click\n        this.processVertexClick(e);\n      }.bind(this));\n    }\n\n    _createClass(Edge, [{\n      key: 'setScale',\n      value: function setScale() {\n        this.scale = Math.pow(2, 16 - this.map.getZoom());\n        this.calculateEdgeRectangles();\n      }\n    }, {\n      key: 'setDividingPoint',\n      value: function setDividingPoint(point) {\n        this.dividingPoint = point;\n        this.calculateEdgeRectangles();\n      }\n    }, {\n      key: 'hideDividingPoint',\n      value: function hideDividingPoint() {\n        this.setDividingPoint(null);\n      }\n    }, {\n      key: 'setColor',\n      value: function setColor(firstColor) {\n        var secondColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        this.firstImage.options.set('strokeColor', firstColor);\n        this.firstImage.options.set('fillColor', firstColor);\n\n        if (secondColor != null) {\n          this.secondImage.options.set('strokeColor', secondColor);\n          this.secondImage.options.set('fillColor', secondColor);\n        }\n      }\n    }, {\n      key: 'addToMap',\n      value: function addToMap() {\n        if (!this.edgeIsOnMap) {\n          this.map.geoObjects.add(this.eventRectangle);\n          this.map.geoObjects.add(this.firstImage);\n          this.map.geoObjects.add(this.secondImage);\n          this.edgeIsOnMap = true;\n        }\n      }\n    }, {\n      key: 'removeFromMap',\n      value: function removeFromMap() {\n        if (this.edgeIsOnMap) {\n          this.map.geoObjects.remove(this.eventRectangle);\n          this.map.geoObjects.remove(this.firstImage);\n          this.map.geoObjects.remove(this.secondImage);\n          this.edgeIsOnMap = false;\n        }\n      }\n\n      /*\r\n      getChuteDirection() {\r\n        return this.chuteDirection;\r\n      }\r\n        getColor() {\r\n        var color = this.chuteDirection ? \"#0000FF\" : \"#000050\";\r\n        return color;\r\n      }  */\n\n      /**\r\n       * Process both click and dblclick on this edge.\r\n       * Single clicking is for adding new Vertex.\r\n       * Double clicking is for changing chute direction\r\n       * on this edge (skydiver can fly with his face directed\r\n       * with or against edge).\r\n       */\n\n    }, {\n      key: 'processVertexClick',\n      value: function processVertexClick(e) {\n        this.clickNumber++;\n        if (this.clickNumber == 1) {\n          setTimeout(function () {\n            if (this.clickNumber == 1) {\n              // Single Click (add Vertex)\n              this.divideEdge(e);\n              this.clickNumber = 0;\n            } else {\n              if (this.clickNumber == 2) {// Double Click (change chute direction)\n                /*\r\n                this.chuteDirection = !this.chuteDirection;\r\n                let color = this.getColor();\r\n                this.image.options.set(\"fillColor\", color);\r\n                this.image.options.set(\"strokeColor\", color);\r\n                this.clickNumber = 0;\r\n                  this.path.calculator.calculateHeight();\r\n                this.path.printHeightsAndWindPoints();  */\n              }\n            }\n          }.bind(this), 200);\n        }\n      }\n\n      /**\r\n       * Here we calculate projection of point = e.get('coords') to\r\n       * line segment {this.pointA, this.pointB} and then\r\n       * send that projection to path.divideEdge.\r\n       * After this operation this Edge will be deleted.\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: 'divideEdge',\n      value: function divideEdge(e) {\n        var point = e.get('coords');\n\n        var pointA = this.prevVertex.getCoordinates(),\n            pointB = this.nextVertex.getCoordinates();\n\n        var vector1 = VectorMath.subVectors(point, pointA),\n            vector2 = VectorMath.subVectors(pointB, pointA);\n        vector2 = VectorMath.normaliseVector(vector2);\n        var c = VectorMath.scalarProduct(vector1, vector2);\n        var vector3 = VectorMath.multVectorConstant(vector2, c);\n\n        var point2 = VectorMath.addVectors(pointA, vector3);\n\n        this.path.divideEdge(this, point2);\n      }\n\n      /**\r\n       * Run this function when geometric parameters of\r\n       * prevVertex or nextVertex are changed.\r\n       * It will recalculate Edge parameters.\r\n       */\n\n    }, {\n      key: 'calculateEdgeRectangles',\n      value: function calculateEdgeRectangles() {\n        var pointA = this.prevVertex.getCoordinates();\n        var pointB = this.nextVertex.imageIsTriangle ? this.nextVertex.image.getEdgePoint() : this.nextVertex.getCoordinates();\n\n        var vertices = this.calculateRectangleVertices(pointA, pointB, this.edgeWidth * this.scale);\n        this.eventRectangle.geometry.setCoordinates([vertices]);\n\n        if (this.dividingPoint == null) {\n          vertices = this.calculateRectangleVertices(pointA, pointB, this.edgeImageWidth * this.scale);\n          this.firstImage.geometry.setCoordinates([vertices]);\n          this.secondImage.geometry.setCoordinates([]);\n        } else {\n          vertices = this.calculateRectangleVertices(pointA, this.dividingPoint, this.edgeImageWidth * this.scale);\n          this.firstImage.geometry.setCoordinates([vertices]);\n\n          vertices = this.calculateRectangleVertices(this.dividingPoint, pointB, this.edgeImageWidth * this.scale);\n          this.secondImage.geometry.setCoordinates([vertices]);\n        }\n      }\n\n      /**\r\n       * @param {number} width - Width of Rectangle, in meters.\r\n       */\n\n    }, {\n      key: 'calculateRectangleVertices',\n      value: function calculateRectangleVertices(pointA, pointB, width) {\n\n        var latitude = pointA[0],\n            geodesicVectorAB = VectorMath.subVectors(pointB, pointA);\n\n        var cartVectorAB = VectorMath.toLocalVector(geodesicVectorAB, latitude);\n\n        var v = VectorMath.normaliseVector(cartVectorAB);\n\n        var w = [-v[1] * width, v[0] * width];\n\n        var wg = VectorMath.toGeodesicVector(w, latitude);\n        var wwg = [wg[0] * -1, wg[1] * -1];\n\n        var vertices = [];\n        vertices[0] = VectorMath.addVectors(pointA, wg);\n        vertices[1] = VectorMath.addVectors(pointB, wg);\n        vertices[2] = VectorMath.addVectors(pointB, wwg);\n        vertices[3] = VectorMath.addVectors(pointA, wwg);\n\n        return vertices;\n      }\n    }]);\n\n    return Edge;\n  }();\n\n  provide(Edge);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Edge.js?");

/***/ }),

/***/ "./src-compiled/scripts/MenuButton.js":
/*!********************************************!*\
  !*** ./src-compiled/scripts/MenuButton.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('MenuButton', ['control.Button'], function (provide, Button) {\n  /**\r\n   * MenuButton creates Yandex.Maps API Button.\r\n   * If you click this Button, then CSS property \r\n   * 'left' of two DOM elements (Element1 with jQuerySelector1 and \r\n   *  Element2 with jQuerySelector2) will be set to be 0. \r\n   * @extends control.Button\r\n   */\n  var MenuButton = function (_Button) {\n    _inherits(MenuButton, _Button);\n\n    /**\r\n     * @param {string} [title] - Button hint.\r\n     * @param {string} [image] - Src for <img> tag of this button.\r\n     * @param {string} [jQuerySelector1] - jQuery selector for Element1. \r\n     * @param {string} [jQuerySelector2] - jQuery selector for Element2. \r\n     * @param {string} [cssclass] - Css for this button.          \r\n     */\n    function MenuButton(title, image, jQuerySelector1, jQuerySelector2) {\n      var cssclass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'inputControlElement';\n\n      _classCallCheck(this, MenuButton);\n\n      // Result of this Button clicking\n      var _this = _possibleConstructorReturn(this, (MenuButton.__proto__ || Object.getPrototypeOf(MenuButton)).call(this, {\n        data: {\n          title: title,\n          image: image,\n          cssclass: cssclass\n        },\n        options: {\n          layout: ymaps.templateLayoutFactory.createClass(\"<div title='{{data.title}}' class='{{data.cssclass}}'>\" + \"<img class='iconimage' src='{{data.image}}'>\" + \"</div>\"),\n          maxWidth: 300\n        }\n      }));\n\n      _this.events.add('click', function () {\n        $(jQuerySelector2).css(\"left\", \"0\");\n        $(jQuerySelector1).css(\"left\", \"0\");\n      });\n      return _this;\n    }\n\n    return MenuButton;\n  }(Button);\n\n  provide(MenuButton);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/MenuButton.js?");

/***/ }),

/***/ "./src-compiled/scripts/OutputElement.js":
/*!***********************************************!*\
  !*** ./src-compiled/scripts/OutputElement.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('OutputElement', ['control.Button', 'templateLayoutFactory'], function (provide, Button, templateLayoutFactory) {\n  var OutputElement = function (_Button) {\n    _inherits(OutputElement, _Button);\n\n    /**\r\n     * @param {string} content\r\n     */\n    function OutputElement() {\n      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      _classCallCheck(this, OutputElement);\n\n      return _possibleConstructorReturn(this, (OutputElement.__proto__ || Object.getPrototypeOf(OutputElement)).call(this, {\n        data: { content: content },\n\n        options: {\n          layout: templateLayoutFactory.createClass(\"<div class='outputControlElement'>{{data.content}}</div>\"),\n          maxWidth: 300\n        }\n      }));\n    }\n\n    /**\r\n     *\r\n     * @param {string} str\r\n     */\n\n\n    _createClass(OutputElement, [{\n      key: 'print',\n      value: function print(str) {\n        this.data.set('content', str);\n      }\n    }]);\n\n    return OutputElement;\n  }(Button);\n\n  provide(OutputElement);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/OutputElement.js?");

/***/ }),

/***/ "./src-compiled/scripts/Path.js":
/*!**************************************!*\
  !*** ./src-compiled/scripts/Path.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('Path', ['Vertex', 'Edge', 'Constant'], function (provide, Vertex, Edge, Constant) {\n  /**\r\n   * List of Vertices and Edges.\r\n   * Image of Last Vertex is Triangle. Images of other Vertices are Circles.\r\n   */\n  var Path = function () {\n    /**\r\n     * @param {Map} map - link to Yandex map.\r\n     */\n    function Path(map) {\n      _classCallCheck(this, Path);\n\n      this.map = map;\n\n      this.firstVertex = null;\n      this.lastVertex = null;\n      this.baseVertex = null;\n\n      this.baseVertexHeight = Constant.defaultBaseHeight;\n      this.length = 0; // number of vertices\n      this.calculator = null;\n    }\n\n    _createClass(Path, [{\n      key: 'setCalculator',\n      value: function setCalculator(calculator) {\n        this.calculator = calculator;\n      }\n\n      /**\r\n       * Add new Vertex to Path and to Map.\r\n       * Add corresponding Edge to Path and to Map.\r\n       * @param {number[]} point - Yandex.Maps coordinates, point = [x, y].\r\n       * @return {Array} New Last Vertex and new Vast Edge of Path.\r\n       */\n\n    }, {\n      key: 'addVertex',\n      value: function addVertex(point, isAddedtoEnd) {\n        var vertex = new Vertex(this.map, point, this);\n        //vertex.chuteImage.setCalculator(this.calculator);\n        vertex.setCalculator(this.calculator);\n\n        var edge = null;\n\n        if (this.length > 0) {\n          if (isAddedtoEnd) {\n            // We should add vertex to the end of path\n            var lastPoint = this.lastVertex.getCoordinates();\n            vertex.setTriangleImage(lastPoint);\n\n            edge = new Edge(this.lastVertex, vertex, this);\n\n            if (this.length > 1) {\n              this.lastVertex.setCircleImage();\n              this.lastVertex.prevEdge.calculateEdgeRectangles();\n            }\n\n            this.lastVertex = vertex;\n            this.lastVertex.setIsBetweenBaseAndLast(true);\n\n            vertex.prevVertex.chuteImage.show();\n          } else {\n            // We should add vertex to the beginning of path\n            vertex.setCircleImage();\n\n            if (this.length == 1) {\n              this.firstVertex.setTriangleImage(point);\n            }\n\n            edge = new Edge(vertex, this.firstVertex, this);\n\n            this.firstVertex = vertex;\n            this.firstVertex.setIsBetweenBaseAndLast(false);\n\n            vertex.chuteImage.show();\n          }\n\n          vertex.addToMap();\n          edge.addToMap();\n          //vertex.prevVertex.chuteImage.show();\n          this.length++;\n\n          this.calculator.calculateHeight(isAddedtoEnd);\n        } else {\n          // this.length == 0;\n          vertex.setStrokeColor('#FFC107'); // Yellow color\n          vertex.setHeightPlacemarkColor('bg-warning'); // Yellow color\n          vertex.setCircleImage();\n          this.firstVertex = vertex;\n          this.lastVertex = vertex;\n          this.baseVertex = vertex;\n          this.firstVertex.setHeight(this.baseVertexHeight);\n          vertex.isBetweenBaseAndLast = null;\n          var str = Math.floor(vertex.height) + '&nbsp;м';\n          vertex.printHint('h=' + str);\n          vertex.printPlacemark(str);\n\n          vertex.addToMap();\n          this.length++;\n        }\n\n        return [vertex, edge];\n      }\n\n      /**\r\n       * You shouldn't setBaseVertex to vertex with height == null\r\n       * or height < 0.\r\n       * @param {Vertex} vertex\r\n       */\n\n    }, {\n      key: 'setBaseVertex',\n      value: function setBaseVertex(newBaseVertex) {\n\n        var isBetweenBaseAndLast = newBaseVertex.isBetweenBaseAndLast;\n\n        var vStart = isBetweenBaseAndLast ? this.baseVertex : newBaseVertex;\n        var vFinal = isBetweenBaseAndLast ? newBaseVertex : this.baseVertex;\n\n        var vertex = vStart;\n        var wind = this.calculator.windList.lastWind;\n        var isVertex = true;\n\n        // Changing directions for part of path (and corresponding winds)\n        // between baseVertex and newBaseVertex (we want calculation results\n        // to be the same for newBaseVertex)\n        while (true) {\n          if (isVertex) {\n            // current list item is path vertex.\n            while (true) {\n              if (vertex.height > wind.vertex.height) {\n                break;\n              } else {\n                wind = wind.prevWind;\n                if (wind == null) break;\n              }\n            }\n\n            if (wind == null || vertex.nextVertex.height >= wind.vertex.height) {\n              isVertex = true;\n              this.copyDirection(vertex, vertex.nextVertex, isBetweenBaseAndLast);\n              vertex = vertex.nextVertex;\n              if (vertex == vFinal) break;\n            } else {\n              isVertex = false;\n              this.copyDirection(vertex, wind.vertex, isBetweenBaseAndLast);\n            }\n          } else {\n            // current list item is wind vertex.\n            while (true) {\n              if (wind.vertex.height > vertex.height) {\n                break;\n              } else {\n                vertex = vertex.nextVertex;\n                if (vertex == null) break;\n              }\n            }\n            var prevWind = wind.prevWind;\n            if (prevWind.vertex.height > vertex.height) {\n              isVertex = false;\n              this.copyDirection(wind.vertex, wind.prevWind.vertex, isBetweenBaseAndLast);\n            } else {\n              isVertex = true;\n              this.copyDirection(wind.vertex, vertex, isBetweenBaseAndLast);\n              if (vertex == vFinal) break;\n            }\n            wind = prevWind;\n          }\n        }\n\n        //this.baseVertex.setStrokeColor(this.baseVertex.color);\n        this.baseVertex.setStrokeColor('#0000FF');\n        this.baseVertex.setHeightPlacemarkColor('bg-info');\n        this.baseVertex.reRender();\n        /*\r\n        if (this.baseVertex.imageIsTriangle) {\r\n          this.baseVertex.setTriangleImage(\r\n              this.baseVertex.prevVertex.getCoordinates(), 'bg-info');\r\n        } else {\r\n          this.baseVertex.setCircleImage('bg-info');\r\n        }  */\n        // Yellow color.\n        newBaseVertex.setStrokeColor('#FFC107');\n        newBaseVertex.setHeightPlacemarkColor('bg-warning');\n        newBaseVertex.reRender();\n        /*\r\n        if (newBaseVertex.imageIsTriangle) {\r\n          newBaseVertex.setTriangleImage(\r\n              newBaseVertex.prevVertex.getCoordinates(), 'bg-warning');\r\n        } else {\r\n          newBaseVertex.setCircleImage('bg-warning');\r\n        } */\n        this.baseVertex = newBaseVertex;\n        //this.setVerticesIsBetweenBaseAndLast();\n\n        // Set isBetweenBaseAndLast for all vertices.\n        this.baseVertex.isBetweenBaseAndLast = null;\n        var v = this.baseVertex;\n        while ((v = v.prevVertex) != null) {\n          v.isBetweenBaseAndLast = false;\n        }\n        var v = this.baseVertex;\n        while ((v = v.nextVertex) != null) {\n          v.isBetweenBaseAndLast = true;\n        }\n\n        $(\"#baseVertexHeight\").val(Math.floor(this.baseVertex.height));\n        this.baseVertexHeight = this.baseVertex.height;\n        this.calculator.calculateHeight();\n      }\n\n      /**\r\n       * We suppose that vertex1.height > vertex2.height.\r\n       */\n\n    }, {\n      key: 'copyDirection',\n      value: function copyDirection(vertex1, vertex2, isBetweenBaseAndLast) {\n        if (isBetweenBaseAndLast) {\n          vertex2.chuteImageBack.chuteDirection = vertex1.chuteImage.chuteDirection;\n          //vertex2.chuteImageBack.show();\n          vertex1.chuteImage.hide();\n        } else {\n          vertex1.chuteImage.chuteDirection = vertex2.chuteImageBack.chuteDirection;\n          //vertex1.chuteImage.show();\n          vertex2.chuteImageBack.hide();\n        }\n      }\n    }, {\n      key: 'setBaseVertexHeight',\n      value: function setBaseVertexHeight(height) {\n        this.baseVertexHeight = height;\n        if (this.length > 0) {\n          this.baseVertex.setHeight(height);\n\n          //this.calculator.clearVertexDirections();\n          this.calculator.calculateHeight();\n        }\n      }\n\n      /*\r\n      setVerticesIsBetweenBaseAndLast() {\r\n        this.baseVertex.isBetweenBaseAndLast = null;\r\n        var v = this.baseVertex;\r\n        while((v = v.prevVertex)!= null) {\r\n          v.isBetweenBaseAndLast = false;\r\n        }\r\n        var v = this.baseVertex;\r\n        while((v = v.nextVertex) != null) {\r\n          v.isBetweenBaseAndLast = true;\r\n        }\r\n      }  */\n\n      /**\r\n       * Divide Edge by point.\r\n       * Point should be on that Edge.\r\n       * @param {Edge} edge\r\n       * @param {number[]} point - Yandex.maps coordinates.\r\n       * @return {Array} New Vertex and two new Edges.\r\n       */\n\n    }, {\n      key: 'divideEdge',\n      value: function divideEdge(edge, point) {\n        var prevVertex = edge.prevVertex,\n            nextVertex = edge.nextVertex;\n\n        var vertex = new Vertex(this.map, point, this);\n        //vertex.chuteImage.setCalculator(this.calculator);\n        vertex.setCalculator(this.calculator);\n\n        vertex.setCircleImage();\n\n        var edge1 = new Edge(prevVertex, vertex, this);\n        var edge2 = new Edge(vertex, nextVertex, this);\n\n        if (vertex.prevVertex.isBetweenBaseAndLast == true || vertex.prevVertex.isBetweenBaseAndLast == null) {\n          vertex.setIsBetweenBaseAndLast(true);\n        } else {\n          vertex.setIsBetweenBaseAndLast(false);\n        }\n\n        this.length++;\n\n        edge.removeFromMap();\n        vertex.addToMap();\n        edge1.addToMap();\n        edge2.addToMap();\n\n        this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\n        return [vertex, edge1, edge2];\n      }\n\n      /**\r\n       * Remove vertex from Path and from map.\r\n       * @param {Vertex} vertex\r\n       */\n\n    }, {\n      key: 'removeVertex',\n      value: function removeVertex(vertex) {\n\n        if (this.length == 1) {\n          vertex.removeFromMap();\n          this.length = 0;\n          this.firstVertex = null;\n          this.lastVertex = null;\n          this.baseVertex = null;\n        } else if (vertex == this.baseVertex) {\n          alert('Нельзя удалить базовую вершину, если число вершин больше одной!');\n        } else {\n          vertex.removeFromMap();\n\n          var prevVertex = vertex.prevVertex;\n          var nextVertex = vertex.nextVertex;\n\n          if (prevVertex != null && nextVertex != null) {\n            var prevEdge = vertex.prevEdge;\n            var nextEdge = vertex.nextEdge;\n            prevEdge.removeFromMap();\n            nextEdge.removeFromMap();\n\n            if (nextVertex == this.lastVertex) {\n              var prevPoint = prevVertex.getCoordinates();\n              nextVertex.setTriangleImage(prevPoint);\n            }\n\n            var edge = new Edge(prevVertex, nextVertex, this);\n            edge.addToMap();\n          } else if (nextVertex == null) {\n            // last vertex case\n            vertex.prevVertex.chuteImage.hide();\n\n            var prevEdge = vertex.prevEdge;\n            prevEdge.removeFromMap();\n\n            this.lastVertex = prevVertex;\n            this.lastVertex.nextVertex = null;\n            this.lastVertex.nextEdge = null;\n\n            if (prevVertex.prevVertex != null) {\n              var prevPrevPoint = prevVertex.prevVertex.getCoordinates();\n              prevVertex.setTriangleImage(prevPrevPoint);\n              prevVertex.prevEdge.calculateEdgeRectangles();\n            }\n          } else {\n            // first vertex case\n            vertex.nextVertex.chuteImageBack.hide();\n            vertex.nextEdge.removeFromMap();\n\n            nextVertex.prevVertex = null;\n            this.firstVertex = nextVertex;\n\n            if (this.length == 2) {\n              nextVertex.setCircleImage();\n            }\n          }\n\n          this.length--;\n          this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\n        }\n      }\n\n      /**\r\n       * Drag vertex with neibour edges.\r\n       * @param {Vertex} vertex\r\n       */\n\n    }, {\n      key: 'dragVertex',\n      value: function dragVertex(vertex) {\n        this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\n\n        if (vertex.nextEdge != null) {\n          vertex.nextEdge.calculateEdgeRectangles();\n        }\n\n        if (vertex.prevEdge != null) {\n          vertex.prevEdge.calculateEdgeRectangles();\n        }\n      }\n\n      /** Remove all vetrices and edges from Path and from map. */\n\n    }, {\n      key: 'clear',\n      value: function clear() {\n        if (this.length > 0) {\n          var vertex = this.lastVertex;\n          vertex.removeFromMap();\n\n          for (var i = 1; i < this.length; i++) {\n            vertex = vertex.prevVertex;\n            vertex.removeFromMap();\n            vertex.nextEdge.removeFromMap();\n          }\n\n          this.length = 0;\n          this.lastVertex = null;\n        }\n\n        this.calculator.windList.clearDirections();\n        this.calculator.calculateHeight();\n      }\n    }]);\n\n    return Path;\n  }();\n\n  provide(Path);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Path.js?");

/***/ }),

/***/ "./src-compiled/scripts/PreVertex.js":
/*!*******************************************!*\
  !*** ./src-compiled/scripts/PreVertex.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('PreVertex', ['Circle', 'Placemark', 'ChuteImage', 'Constant'], function (provide, Circle, Placemark, ChuteImage, Constant) {\n  /**\r\n   * Vertex consists of: Invisible Event Circle (it is used for catching\r\n   * events for Vertex), Vertex Placemark for Output, Chute Placemark.\r\n   */\n  var PreVertex = function () {\n    /**\r\n     * @param {AppMap} map - Yandex.Map.\r\n     * @param {number} scale\r\n     * @param {number[] | null} coordinates - Yandex.Maps coordinates of center.\r\n     */\n    function PreVertex(map, scale) {\n      var coordinates = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      _classCallCheck(this, PreVertex);\n\n      this.map = map;\n\n      var radius = 4;\n      this.eventRadius = Constant.isMobile ? 6 * radius : 3 * radius;\n\n      // Event Circle (invisible)\n      this.eventCircle = new ymaps.Circle([coordinates, this.eventRadius * scale], {}, {\n        fillOpacity: 0,\n        strokeOpacity: 0,\n        strokeWidth: 0,\n        zIndex: 10\n      });\n\n      // Output Placemark\n      this.heightPlacemark = new ymaps.Placemark(coordinates, { iconContent: '' }, { iconOffset: [0, -35], cursor: 'arrow', zIndex: 8 });\n\n      // Image of chute which shows chute direction on the this.nextEdge\n      this.chuteImage = new ChuteImage();\n\n      this.chuteImageBack = new ChuteImage();\n\n      this.hintContent = null;\n      this.placemarkIsVisible = true;\n      this.vertexIsOnMap = false;\n\n      // remove standart map zoom for double click\n      this.eventCircle.events.add('dblclick', function (e) {\n        e.stopPropagation();\n      });\n    }\n\n    /**\r\n     * Set the same coordinates for Event Circle and Vertex Placemark.\r\n     * @param {null | number[]} point\r\n     */\n\n\n    _createClass(PreVertex, [{\n      key: 'setCoordinates',\n      value: function setCoordinates(point) {\n        this.eventCircle.geometry.setCoordinates(point);\n        this.heightPlacemark.geometry.setCoordinates(point);\n      }\n    }, {\n      key: 'setCalculator',\n      value: function setCalculator(calculator) {\n        this.chuteImage.setCalculator(calculator);\n        this.chuteImageBack.setCalculator(calculator);\n      }\n\n      /**\r\n       * Hiding Vertex.\r\n       */\n\n    }, {\n      key: 'hide',\n      value: function hide() {\n        this.setCoordinates(null);\n        //this.chuteImage.setCoordinates(null);\n        this.chuteImage.hide();\n        this.chuteImageBack.hide();\n      }\n    }, {\n      key: 'setScale',\n      value: function setScale(scale) {\n        this.eventCircle.geometry.setRadius(this.eventRadius * scale);\n      }\n    }, {\n      key: 'addToMap',\n      value: function addToMap() {\n        if (!this.vertexIsOnMap) {\n          this.map.geoObjects.add(this.eventCircle);\n          this.map.geoObjects.add(this.heightPlacemark);\n          this.map.geoObjects.add(this.chuteImage);\n          this.map.geoObjects.add(this.chuteImageBack);\n          this.vertexIsOnMap = true;\n        } else {\n          console.warn('Vertex has already been added to Map!');\n        }\n      }\n    }, {\n      key: 'removeFromMap',\n      value: function removeFromMap() {\n        if (this.vertexIsOnMap) {\n          this.map.geoObjects.remove(this.eventCircle);\n          this.map.geoObjects.remove(this.heightPlacemark);\n          this.map.geoObjects.remove(this.chuteImage);\n          this.map.geoObjects.remove(this.chuteImageBack);\n          this.vertexIsOnMap = false;\n        } else {\n          console.warn('Vertex has already been removed from Map!');\n        }\n      }\n    }, {\n      key: 'getCoordinates',\n      value: function getCoordinates() {\n        return this.eventCircle.geometry.getCoordinates();\n      }\n    }, {\n      key: 'switchPlacemarkIsVisible',\n      value: function switchPlacemarkIsVisible() {\n        this.placemarkIsVisible = !this.placemarkIsVisible;\n        this.heightPlacemark.options.set('visible', this.placemarkIsVisible);\n\n        if (this.placemarkIsVisible) {\n          this.map.geoObjects.remove(this.eventCircle);\n          this.eventCircle.properties.set('hintContent', null);\n          this.map.geoObjects.add(this.eventCircle);\n        } else {\n          this.eventCircle.properties.set('hintContent', this.hintContent);\n        }\n      }\n    }, {\n      key: 'printPlacemark',\n      value: function printPlacemark(str) {\n        this.heightPlacemark.properties.set('iconContent', '' + str);\n      }\n    }, {\n      key: 'printHint',\n      value: function printHint(str) {\n        this.hintContent = '' + str;\n        if (!this.placemarkIsVisible) {\n          this.eventCircle.properties.set('hintContent', '' + this.hintContent);\n        }\n      }\n    }, {\n      key: 'printPlacemarkAndHint',\n      value: function printPlacemarkAndHint(str) {\n        this.printPlacemark(str);\n        this.printHint(str);\n      }\n    }]);\n\n    return PreVertex;\n  }();\n\n  provide(PreVertex);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/PreVertex.js?");

/***/ }),

/***/ "./src-compiled/scripts/TriangleVertexImage.js":
/*!*****************************************************!*\
  !*** ./src-compiled/scripts/TriangleVertexImage.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('TriangleVertexImage', ['Polygon', 'VectorMath'], function (provide, Polygon, VectorMath) {\n\n  /**\r\n   * Let point1, point2 - two points with Yandex.maps (geodesic) coordinates.\r\n   * TriangleVertex is Yandex maps triangle,\r\n   * such that vector (point1, point2) and that triangle\r\n   * form arrow (end of path).\r\n   * Size of arrow is about several meters.\r\n   */\n  var TriangleVertexImage = function (_Polygon) {\n    _inherits(TriangleVertexImage, _Polygon);\n\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.\r\n     * @param {number} scale - It defines size of Triangle.\r\n     * @param {number} zIndex - z-index of Polygon.\r\n     */\n    function TriangleVertexImage(point1, point2, scale, color, strokeColor, zIndex) {\n      _classCallCheck(this, TriangleVertexImage);\n\n      // Three vertices of triangle\n      var _this = _possibleConstructorReturn(this, (TriangleVertexImage.__proto__ || Object.getPrototypeOf(TriangleVertexImage)).call(this, [], {}, {\n        fillColor: color,\n        strokeColor: strokeColor,\n        strokeWidth: 2,\n        zIndex: zIndex\n      }));\n      // four square brackets is a must for Polygon constructor,\n      // non empty super constructor is a must\n\n\n      _this.triangleVertices = null;\n      // Point on triangle side to which edge will be connected\n      _this.edgePoint = null;\n\n      _this.scale = scale;\n      _this.point1 = point1;\n      _this.point2 = point2;\n\n      _this.setCoordinates(point1, point2);\n      return _this;\n    }\n\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.\r\n     */\n\n\n    _createClass(TriangleVertexImage, [{\n      key: 'setCoordinates',\n      value: function setCoordinates(point1, point2) {\n        this.point1 = point1;\n        this.point2 = point2;\n\n        var p = this.calculateVertices(point1, point2);\n\n        this.triangleVertices = [p[0], p[1], p[2]];\n        this.edgePoint = p[3];\n\n        this.geometry.setCoordinates([this.triangleVertices]);\n      }\n    }, {\n      key: 'getEdgePoint',\n      value: function getEdgePoint() {\n        return this.edgePoint;\n      }\n    }, {\n      key: 'setScale',\n      value: function setScale(scale) {\n        this.scale = scale;\n        this.setCoordinates(this.point1, this.point2);\n      }\n    }, {\n      key: 'getScale',\n      value: function getScale() {\n        return this.scale;\n      }\n\n      /**\r\n       * @param {number[]} point1 - Yandex.Maps point coordinates.\r\n       * @param {number[]} point2 - Yandex.Maps point coordinates.\r\n       * @return {number[][]} points - First three points of this array are\r\n       * the vertices of triangle; last point is a point at the triangle side\r\n       * to which edge will be connected.\r\n       */\n\n    }, {\n      key: 'calculateVertices',\n      value: function calculateVertices(point1, point2) {\n\n        var latitude = point1[0],\n            geodesicArrowVector = VectorMath.subVectors(point2, point1),\n            localArrowVector = VectorMath.toLocalVector(geodesicArrowVector, latitude);\n\n        localArrowVector = VectorMath.normaliseVector(localArrowVector);\n\n        // Points coordinates in local cartesian coordinate system.\n        // First three point are the vertices of triangle.\n        // Last point is a point at the triangle side\n        // to which edge will be connected.\n        var pointsLocal = [[-2, 0.5], [-2, -0.5], [0, 0], [-2, 0]];\n        for (var i = 0; i < 4; i++) {\n          for (var j = 0; j < 2; j++) {\n            pointsLocal[i][j] *= this.scale;\n          }\n        }\n\n        var points = [];\n        for (var i = 0; i < pointsLocal.length; i++) {\n          points[i] = VectorMath.rotateVector(pointsLocal[i], localArrowVector);\n          points[i] = VectorMath.addVectors(point2, VectorMath.toGeodesicVector(points[i], latitude));\n        }\n\n        return points;\n      }\n    }]);\n\n    return TriangleVertexImage;\n  }(Polygon);\n\n  provide(TriangleVertexImage);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/TriangleVertexImage.js?");

/***/ }),

/***/ "./src-compiled/scripts/VectorMath.js":
/*!********************************************!*\
  !*** ./src-compiled/scripts/VectorMath.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('VectorMath', [], function (provide) {\n  /** Set of functions for working with Sphere (2 dimensional) vectors. */\n  var VectorMath = function () {\n    function VectorMath() {\n      _classCallCheck(this, VectorMath);\n    }\n\n    _createClass(VectorMath, null, [{\n      key: 'toLocalVector',\n\n\n      /**\r\n       * We consider following local cartesian coordinate system: \r\n       *  axis have the same direction as Latitude-Longtitude, \r\n       *  axis have the same length (with each other), \r\n       *  default scale parameter (0.00008) makes this \r\n       *  coordinate system be of the size we need in our tasks.\r\n       * @param {number[]} geodesicVector - Latitude-Longtitude vector coordinates.\r\n       * @param {number} latitude\r\n       * @param {number} scale - Default value is 0.00008\r\n       * @return {number[]} [vx, vy] - Vector coordinates in cartesian coordinate system.\r\n       */\n      value: function toLocalVector(geodesicVector, latitude) {\n        var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.00008;\n\n        var vx = geodesicVector[0] / scale;\n        var vy = geodesicVector[1] / scale * Math.cos(Math.PI / 180 * latitude);\n        return [vx, vy];\n      }\n\n      /**\r\n       * Convert Cartesian coordinate to Latitude-Longtitude coordinates.\r\n       * @param {number[]} localVector - Cartesian vector. \r\n       * @param {number} latitude\r\n       * @param {number} scale \r\n       * @return {number[]|0} [vlat, vlon] - [Latitude, Longtitude] or 0 \r\n       *  (if impossible to convert).       \r\n       */\n\n    }, {\n      key: 'toGeodesicVector',\n      value: function toGeodesicVector(localVector, latitude) {\n        var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.00008;\n\n        var vlat = localVector[0] * scale;\n        var c = Math.cos(Math.PI / 180 * latitude);\n        if (c == 0) return 0;\n        var vlon = localVector[1] * scale / c;\n        return [vlat, vlon];\n      }\n    }, {\n      key: 'normaliseVector',\n      value: function normaliseVector(v) {\n        var d = Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n        if (d > 0) {\n          return [v[0] / d, v[1] / d];\n        } else {\n          return [0, 0];\n        }\n      }\n\n      /**\r\n       * n = (cos(alpha), sin(alpha)), \r\n       * alpha is angle of rotation\r\n       */\n\n    }, {\n      key: 'rotateVector',\n      value: function rotateVector(v, n) {\n        var wx = n[0] * v[0] - n[1] * v[1];\n        var wy = n[1] * v[0] + n[0] * v[1];\n        return [wx, wy];\n      }\n    }, {\n      key: 'addVectors',\n      value: function addVectors(v1, v2) {\n        return [v1[0] + v2[0], v1[1] + v2[1]];\n      }\n    }, {\n      key: 'subVectors',\n      value: function subVectors(v1, v2) {\n        return [v1[0] - v2[0], v1[1] - v2[1]];\n      }\n    }, {\n      key: 'multVectorConstant',\n      value: function multVectorConstant(v, a) {\n        return [v[0] * a, v[1] * a];\n      }\n    }, {\n      key: 'scalarProduct',\n      value: function scalarProduct(v1, v2) {\n        return v1[0] * v2[0] + v1[1] * v2[1];\n      }\n    }, {\n      key: 'length',\n      value: function length(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n      }\n\n      /**\r\n       * pointA + {pointA, pointB} * t\r\n       */\n\n    }, {\n      key: 'findIntermediatePoint',\n      value: function findIntermediatePoint(pointA, pointB, t) {\n        var v = this.subVectors(pointB, pointA);\n        var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\n        v = this.multVectorConstant(v, t);\n        var point = this.addVectors(pointA, v);\n        return point;\n      }\n\n      /**\r\n       * \r\n       * @param {number[]} point - Cartesian coordinates.\r\n       * @returns {Object | null} polarCoordinates - Polar coordinates or null if radius = 0. \r\n       * @returns {number} polarCoordinates.radius\r\n       * @returns {number} polarCoordinates.angle - Here 0 <= angle < 2*PI.\r\n       */\n\n    }, {\n      key: 'getPolarFromCartesian',\n      value: function getPolarFromCartesian(point) {\n        var x = point[0];\n        var y = point[1];\n\n        var r = Math.sqrt(x * x + y * y);\n        if (r == 0) return { radius: null, angle: null };\n\n        var angle = null;\n\n        if (x > 0) {\n          angle = y >= 0 ? Math.atan(y / x) : 2 * Math.PI - Math.atan(-y / x);\n        } else {\n          if (x < 0) {\n            if (y >= 0) {\n              angle = Math.PI - Math.atan(y / -x);\n            } else {\n              angle = Math.PI + Math.atan(y / x);\n            }\n          } else {\n            // x = 0\n            angle = y > 0 ? Math.PI / 2 : Math.PI * (3 / 2);\n          }\n        }\n\n        //angle = 360 * (angle / (Math.PI*2));  \n        var polarCoordinates = { radius: r, angle: angle };\n        return polarCoordinates;\n      }\n    }]);\n\n    return VectorMath;\n  }();\n\n  provide(VectorMath);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/VectorMath.js?");

/***/ }),

/***/ "./src-compiled/scripts/Vertex.js":
/*!****************************************!*\
  !*** ./src-compiled/scripts/Vertex.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('Vertex', ['Circle', 'Rectangle', 'TriangleVertexImage', 'templateLayoutFactory', 'PreVertex'], function (provide, Circle, Rectangle, TriangleVertexImage, templateLayoutFactory, PreVertex) {\n  /**\r\n   * Vertex of Path.\r\n   * Vertex extends PreVertex:\r\n   * we add Vertex Image (Circle or Triangle) and special layouts\r\n   * for Vertex Placemark (with and without closing cross).\r\n   */\n  var Vertex = function (_PreVertex) {\n    _inherits(Vertex, _PreVertex);\n\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {AppMap} map\r\n     * @param {Path} path - Link to parent Path; we need it because some vertex\r\n     * operations (like clicking on Placemark Cross = Path clear) change the Path.\r\n     */\n    function Vertex(map, point, path) {\n      _classCallCheck(this, Vertex);\n\n      var scale = Math.pow(2, 16 - map.getZoom());\n\n      var _this = _possibleConstructorReturn(this, (Vertex.__proto__ || Object.getPrototypeOf(Vertex)).call(this, map, scale, point));\n\n      _this.map = map;\n      _this.path = path;\n      _this.scale = scale;\n\n      _this.type = 'pathVertex';\n\n      _this.setScale = _this.setScale.bind(_this);\n      map.events.add('boundschange', _this.setScale);\n\n      _this.eventCircle.options.set('draggable', true);\n      _this.eventCircle.options.set('zIndex', 120);\n      //console.log(this.eventCircle.options);\n      //this.heightPlacemark.options.set('zIndex', 1);\n\n      // Image of Vertex. Object of classes: ymaps.Circle or TriangleVertexImage.\n      // To set it, use this.setTriangleImage() or this.setCircleImage()\n      // You should not add Vertex to Map until Image is not initialized.\n      _this.image = null;\n      _this.imageZIndex = 5;\n      // null - for undefined (this.image = null),\n      // true - for Triangle Image, false - for Circle Image.\n      // You should use this.imageIsTriangle only if this.image != null.\n      _this.imageIsTriangle = null;\n      _this.circleImageRadius = 4;\n\n      // Blue color\n      _this.color = '#0000FF';\n      _this.strokeColor = '#0000FF';\n\n      _this.heightPlacemarkColor = 'bg-info';\n\n      // References to previous and next Vertices.\n      _this.prevVertex = null;\n      _this.nextVertex = null;\n\n      _this.prevEdge = null;\n      _this.nextEdge = null;\n\n      _this.nextWind = null;\n\n      // true if this Vertex is situated between\n      // Base Vertex and Last Vertex of Path.\n      // null - for Base Vertex itself.\n      _this.isBetweenBaseAndLast = null;\n\n      _this.clickNumber = 0;\n\n      // Turning on/off vertex when conditon\n      // \"reachable/unreachable\" was changed\n      _this.wasTurnOffBecauseUnreachable = false;\n      // The same for back direction\n      _this.wasTurnOffBecauseBackUnreachable = false;\n\n      // Chute height at this vertex. It will be calculated later.\n      // Use this.setHeight to set up this.height.\n      _this.height = null;\n\n      _this.eventCircle.events.add('click', function (e) {\n        e.stopPropagation(); // remove standart zoom for click\n        this.processVertexClick();\n      }.bind(_this));\n\n      _this.eventCircle.events.add('contextmenu', function (e) {\n        e.stopPropagation();\n        if (this.nextVertex != null) {\n          this.switchPlacemarkIsVisible();\n        }\n\n        /*\r\n        if (this.path.baseVertex != this && this.height != null && this.height >= 0) {\r\n          this.path.setBaseVertex(this);\r\n        } else if (this.height < 0) {\r\n          alert('Нельзя вершину с отрицательной высотой делать базовой!');\r\n        } else if (this.height == null) {\r\n          alert('Нельзя вершину с неопределенной высотой делать базовой!');\r\n        }  */\n      }.bind(_this));\n\n      _this.eventCircle.events.add('drag', function (e) {\n        e.stopPropagation();\n        var point = this.eventCircle.geometry.getCoordinates();\n        this.setCoordinates(point);\n        this.path.dragVertex(this);\n      }.bind(_this));\n\n      return _this;\n    }\n\n    /**\r\n     * Set the same coordinates for Event Circle,\r\n     * Vertex Placemark, Vertex Image.\r\n     * Change Direction of Triangle for this Vertex\r\n     * (if this Vertex is Triangle Vertex)\r\n     */\n\n\n    _createClass(Vertex, [{\n      key: 'setCoordinates',\n      value: function setCoordinates(point) {\n        _get(Vertex.prototype.__proto__ || Object.getPrototypeOf(Vertex.prototype), 'setCoordinates', this).call(this, point);\n\n        // Note: it supposed that in case of Triangle Vertex, prevVertex != null.\n        if (this.image != null) {\n          if (this.imageIsTriangle) {\n            var prevPoint = this.prevVertex.getCoordinates();\n            // Here we calculate vertices of Image Triangle\n            this.image.setCoordinates(prevPoint, point);\n          } else {\n            // In this case, this.image is a Circle, so\n            // we can set coordinates of it center.\n            this.image.geometry.setCoordinates(point);\n          }\n        }\n\n        if (this.nextVertex != null && this.nextVertex.imageIsTriangle) {\n          var nextPoint = this.nextVertex.getCoordinates();\n          this.nextVertex.image.setCoordinates(point, nextPoint);\n        }\n      }\n    }, {\n      key: 'setScale',\n      value: function setScale() {\n        var scale = Math.pow(2, 16 - this.map.getZoom());\n        _get(Vertex.prototype.__proto__ || Object.getPrototypeOf(Vertex.prototype), 'setScale', this).call(this, scale);\n        this.scale = scale;\n\n        if (this.image != null) {\n          if (this.imageIsTriangle) {\n            this.image.setScale(scale);\n          } else {\n            this.image.geometry.setRadius(this.circleImageRadius * scale);\n          }\n        }\n      }\n    }, {\n      key: 'setIsBetweenBaseAndLast',\n      value: function setIsBetweenBaseAndLast(isBetweenBaseAndLast) {\n        this.isBetweenBaseAndLast = isBetweenBaseAndLast;\n      }\n\n      /**\r\n       * @param {Vertex | null} vertex\r\n       */\n\n    }, {\n      key: 'setNextVertex',\n      value: function setNextVertex(vertex) {\n        this.nextVertex = vertex;\n        if (vertex != null) {\n          vertex.prevVertex = this;\n        }\n      }\n    }, {\n      key: 'setPrevVertex',\n      value: function setPrevVertex(vertex) {\n        this.prevVertex = vertex;\n        if (vertex != null) {\n          vertex.nextVertex = this;\n        }\n      }\n    }, {\n      key: 'setNextEdge',\n      value: function setNextEdge(edge) {\n        this.nextEdge = edge;\n        if (edge != null) {\n          edge.prevVertex = this;\n          edge.nextVertex = this.nextVertex;\n          if (this.nextVertex != null) {\n            this.nextVertex.prevEdge = edge;\n          }\n        }\n      }\n    }, {\n      key: 'setPrevEdge',\n      value: function setPrevEdge(edge) {\n        this.prevEdge = edge;\n        if (edge != null) {\n          edge.nextVertex = this;\n          edge.prevVertex = this.prevVertex;\n          if (this.prevVertex != null) {\n            this.prevVertex.nextEdge = edge;\n          }\n        }\n      }\n\n      /**\r\n       * @param {number[]} prevPoint - Previuos point that define direction of Triangle.\r\n       */\n\n    }, {\n      key: 'setTriangleImage',\n      value: function setTriangleImage(prevPoint) {\n        this.imageIsTriangle = true;\n        var map = this.map;\n\n        if (this.vertexIsOnMap) {\n          map.geoObjects.remove(this.image);\n          map.geoObjects.remove(this.heightPlacemark);\n        }\n\n        var point1 = prevPoint;\n        var point2 = this.getCoordinates();\n\n        // Set Triangle Image\n        this.image = new TriangleVertexImage(point1, point2, this.scale, this.color, this.strokeColor, this.imageZIndex);\n\n        // Set Placemark with Closing Cross\n        var path = this.path;\n        var MyIconLayout = ymaps.templateLayoutFactory.createClass('<div class=\"px-2 py-1 ' + this.heightPlacemarkColor + ' d-inline-flex rounded border align-items-center\"' + 'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' + '<div class=\"' + this.heightPlacemarkColor + ' pr-2\">$[properties.iconContent]</div>' + '<div class=\"' + this.heightPlacemarkColor + ' placemarkCross placemarkCrossImage\"></div>' +\n        //'<div class=\"p-0 bg-info hoverColor\">&#10006;</div>' +\n        '</div>', {\n          build: function build() {\n            this.constructor.superclass.build.call(this);\n            this.path = path;\n            var elem = this.getData().geoObject;\n            elem.events.add('click', this.clickFunc, this);\n            elem.events.add('mouseenter', this.mouseEnter, this);\n            elem.events.add('mouseleave', this.mouseLeave, this);\n          },\n\n          clear: function clear() {\n            var elem = this.getData().geoObject;\n            elem.events.remove('click', this.clickFunc, this);\n            elem.events.remove('mouseenter', this.mouseEnter, this);\n            elem.events.remove('mouseleave', this.mouseLeave, this);\n\n            this.constructor.superclass.clear.call(this);\n          },\n\n          getShape: function getShape() {\n            var parentElement = this.getParentElement();\n            if (parentElement != null) {\n              var element = $('.d-inline-flex', parentElement);\n              var width = element[0].offsetWidth;\n              var height = element[0].offsetHeight;\n              var position = element.position();\n\n              return new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([[position.left + width - 15, position.top], [position.left + width, position.top + height]]));\n            } else {\n              return null;\n            }\n          },\n\n          clickFunc: function (e) {\n            e.preventDefault();\n            if (this.path.length > 2) {\n              if (confirm(\"Удалить путь? \\n\\n (для удаления только одной вершины дважды щелкните по ней)\")) {\n                this.path.clear();\n              };\n            } else {\n              this.path.clear();\n            }\n          }.bind(this),\n\n          mouseEnter: function mouseEnter() {\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\n            $(elem).removeClass('placemarkCrossImage');\n            $(elem).addClass('placemarkCrossImagePointed');\n          },\n\n          mouseLeave: function mouseLeave() {\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\n            $(elem).removeClass('placemarkCrossImagePointed');\n            $(elem).addClass('placemarkCrossImage');\n          }\n        });\n\n        var MyIconShape = {\n          type: 'Rectangle',\n          coordinates: [[71, 0], [96, 25]]\n        };\n\n        this.heightPlacemark.options.set('iconLayout', MyIconLayout);\n        this.heightPlacemark.options.set('iconShape', MyIconShape);\n\n        if (this.vertexIsOnMap) {\n          map.geoObjects.add(this.image);\n          map.geoObjects.add(this.heightPlacemark);\n        }\n      }\n    }, {\n      key: 'setCircleImage',\n      value: function setCircleImage() {\n        this.imageIsTriangle = false;\n        var map = this.map;\n\n        if (this.vertexIsOnMap) {\n          map.geoObjects.remove(this.image);\n          map.geoObjects.remove(this.heightPlacemark);\n        }\n\n        var point = this.getCoordinates();\n        this.image = new ymaps.Circle([point, this.circleImageRadius * this.scale], {}, {\n          fillColor: this.color,\n          strokeColor: this.strokeColor,\n          strokeWidth: 2,\n          zIndex: this.imageZIndex\n        });\n\n        // Set Placemark without Closing Cross\n        var MyIconLayout = ymaps.templateLayoutFactory.createClass('<div class=\"px-2 py-1 ' + this.heightPlacemarkColor + ' text-center rounded border d-inline-block\"' + 'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' + '$[properties.iconContent]' + '</div>');\n\n        this.heightPlacemark.options.set('iconLayout', MyIconLayout);\n        this.heightPlacemark.options.set('iconShape', null);\n\n        if (this.vertexIsOnMap) {\n          map.geoObjects.add(this.image);\n          map.geoObjects.add(this.heightPlacemark);\n        }\n      }\n    }, {\n      key: 'addToMap',\n      value: function addToMap() {\n        if (this.image != null) {\n          if (!this.vertexIsOnMap) {\n            this.map.geoObjects.add(this.image);\n          }\n          _get(Vertex.prototype.__proto__ || Object.getPrototypeOf(Vertex.prototype), 'addToMap', this).call(this);\n        } else {\n          console.warn('The image was not initialized yet!');\n        }\n      }\n    }, {\n      key: 'removeFromMap',\n      value: function removeFromMap() {\n        if (this.vertexIsOnMap) {\n          this.map.geoObjects.remove(this.image);\n        }\n        _get(Vertex.prototype.__proto__ || Object.getPrototypeOf(Vertex.prototype), 'removeFromMap', this).call(this);\n      }\n\n      /**\r\n       * Process both click and dblclick on this vertex.\r\n       * Single clicking is for showing/hiding Placemark.\r\n       * Double clicking is for vertex removing.\r\n       */\n\n    }, {\n      key: 'processVertexClick',\n      value: function processVertexClick() {\n        this.clickNumber++;\n        if (this.clickNumber == 1) {\n          setTimeout(function () {\n            if (this.clickNumber == 1) {\n              // Single Click (show/hide Placemark)\n              //if (this.nextVertex != null) {\n              //  this.switchPlacemarkIsVisible();\n              //}\n\n              if (this.path.baseVertex != this && this.height != null && this.height >= 0) {\n                this.path.setBaseVertex(this);\n              } else if (this.height < 0) {\n                alert('Нельзя вершину с отрицательной высотой делать базовой!');\n              } else if (this.height == null) {\n                alert('Нельзя вершину с неопределенной высотой делать базовой!');\n              }\n              this.clickNumber = 0;\n            } else {\n              // Double Click (remove Vertex)\n              this.path.removeVertex(this);\n              this.clickNumber = 0;\n            }\n          }.bind(this), 200);\n        }\n      }\n\n      /**\r\n       *\r\n       * @param {String} color - RGB.\r\n       * Note: You should reRenderImageColors() or reRender() Vertex\r\n       * or setTriangleImage() or setCircleImage()\r\n       * after changing heightPlacemarkColor.\r\n       */\n\n    }, {\n      key: 'setColor',\n      value: function setColor(color) {\n        this.color = color;\n        /*\r\n        if (this.image != null) {\r\n          this.image.options.set('fillColor', color);\r\n        } else {\r\n          console.warn('The image was not initialized yet!');\r\n        } */\n      }\n\n      /**\r\n       *\r\n       * @param {String} color - RGB.\r\n       */\n\n    }, {\n      key: 'setStrokeColor',\n      value: function setStrokeColor(color) {\n        this.strokeColor = color;\n        /*\r\n        if (this.image != null) {\r\n          this.image.options.set('strokeColor', color);\r\n        } else {\r\n          console.warn('The image was not initialized yet!');\r\n        }  */\n      }\n    }, {\n      key: 'reRenderImageColors',\n      value: function reRenderImageColors() {\n        if (this.image != null) {\n          this.image.options.set('fillColor', this.color);\n          this.image.options.set('strokeColor', this.strokeColor);\n        } else {\n          console.warn('The image was not initialized yet!');\n        }\n      }\n\n      /**\r\n       * @param {String} color - Boostrap color class:\r\n       * bg-info, bg-warning, ...\r\n       * Note: You should reRender() Vertex or setTriangleImage() or\r\n       * setCircleImage() after changing heightPlacemarkColor.\r\n       */\n\n    }, {\n      key: 'setHeightPlacemarkColor',\n      value: function setHeightPlacemarkColor(color) {\n        this.heightPlacemarkColor = color;\n      }\n    }, {\n      key: 'reRender',\n      value: function reRender() {\n        if (this.image != null) {\n          if (this.imageIsTriangle) {\n            this.setTriangleImage(this.prevVertex.getCoordinates());\n          } else {\n            this.setCircleImage();\n          }\n        } else {\n          console.warn('The image was not initialized yet!');\n        }\n      }\n    }, {\n      key: 'setHeight',\n      value: function setHeight(height) {\n        this.height = height;\n\n        if (typeof height == 'number') {\n          this.printPlacemarkAndHint(Math.floor(height) + '&nbsp;м');\n\n          // Blue color.\n          this.setColor('#0000FF');\n          if (this.path.baseVertex == this) {\n            // Yellow color.\n            this.setStrokeColor('#FFC107');\n          } else {\n            this.setStrokeColor('#0000FF');\n          }\n        } else {\n          this.printPlacemarkAndHint('&#x26D4;');\n          // Red color.\n          this.setColor('#FF0000');\n          this.setStrokeColor('#FF0000');\n        }\n        this.reRenderImageColors();\n      }\n    }]);\n\n    return Vertex;\n  }(PreVertex);\n\n  provide(Vertex);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Vertex.js?");

/***/ }),

/***/ "./src-compiled/scripts/Wind.js":
/*!**************************************!*\
  !*** ./src-compiled/scripts/Wind.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('Wind', ['WindVertex'], function (provide, WindVertex) {\n\n  /**\r\n   * Wind at particular height.\r\n   */\n  var Wind = function () {\n    /**\r\n     * Wind at special height.\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     * @param {number} angle - Angle between current wind and West wind; in degrees.\r\n     * @param {(number | null)} height - In meters; height must be >= 0.\r\n     */\n    function Wind(value, angle, height, map) {\n      _classCallCheck(this, Wind);\n\n      this.value = value;\n      this.setAngle(angle);\n\n      this.prevWind = null;\n      this.nextWind = null;\n\n      this.vertex = new WindVertex(map, height);\n      this.setHeight(height);\n    }\n\n    _createClass(Wind, [{\n      key: 'setNextWind',\n      value: function setNextWind(wind) {\n        this.nextWind = wind;\n        if (wind != null) {\n          wind.prevWind = this;\n        }\n      }\n    }, {\n      key: 'setPrevWind',\n      value: function setPrevWind(wind) {\n        this.prevWind = wind;\n        if (wind != null) {\n          wind.nextWind = this;\n        }\n      }\n\n      /**\r\n       * @param {number} value - In m/sec; value must be >= 0.\r\n       */\n\n    }, {\n      key: 'setValue',\n      value: function setValue(value) {\n        this.value = value;\n      }\n\n      /**\r\n       * angle will be reduced to interval (-180, 180] degrees.\r\n       * @param {number} angle\r\n       */\n\n    }, {\n      key: 'setAngle',\n      value: function setAngle(angle) {\n        angle = Math.floor(angle);\n\n        if (angle != -180) {\n          // we want to differ -180 degree and 180 degree at wind menu scale\n          if (angle >= 0) {\n            angle = angle % 360;\n          } else {\n            // negative angle case\n            angle = angle * -1;\n            angle = angle % 360;\n            angle = 360 - angle;\n          }\n\n          if (angle > 180) {\n            angle -= 360;\n          }\n        }\n        this.angle = angle;\n      }\n\n      /**\r\n       * Set this.height and print it to Arrow Output Icon.\r\n       * @param {(number | null)} height - In meters; height must be >= 0.\r\n       */\n\n    }, {\n      key: 'setHeight',\n      value: function setHeight(height) {\n        this.height = height;\n        this.vertex.height = height;\n        this.vertex.printPlacemarkAndHint(Math.floor(height));\n      }\n    }, {\n      key: 'getAngle',\n      value: function getAngle() {\n        return this.angle;\n      }\n    }, {\n      key: 'getValue',\n      value: function getValue() {\n        return this.value;\n      }\n    }, {\n      key: 'getHeight',\n      value: function getHeight() {\n        return this.height;\n      }\n    }, {\n      key: 'toString',\n      value: function toString() {\n        var str = this.height == 0 ? 'Поверхностный ветер: ' : 'h=' + this.height + 'м';\n        str += this.value + ' м/с, ' + this.getDirection();\n        return str;\n      }\n\n      /**\r\n       * Calculate wind coordinates in cartesian coordinate system.\r\n       * @return {number[]} [vx, vy] - coordinates, in m/sec.\r\n       */\n\n    }, {\n      key: 'getXY',\n      value: function getXY() {\n        var radiandirection = this.angle * (2 * Math.PI / 360);\n        var vx = this.value * Math.cos(radiandirection);\n        var vy = this.value * Math.sin(radiandirection);\n        return [vx, vy];\n      }\n\n      /**\r\n       * Get name of wind direction (E, EN, N, NW, W, WS, S, SE)\r\n       */\n\n    }, {\n      key: 'getDirection',\n      value: function getDirection() {\n        var angleSwitch = Math.floor((this.angle + 180 + 22) / 45);\n        var direction;\n\n        switch (angleSwitch) {\n          case 0:\n            direction = \"В\";break;\n          case 1:\n            direction = \"СВ\";break;\n          case 2:\n            direction = \"С\";break;\n          case 3:\n            direction = \"СЗ\";break;\n          case 4:\n            direction = \"З\";break;\n          case 5:\n            direction = \"ЮЗ\";break;\n          case 6:\n            direction = \"Ю\";break;\n          case 7:\n            direction = \"ЮВ\";break;\n          case 8:\n            direction = \"В\";break;\n        }\n\n        return direction;\n      }\n    }]);\n\n    return Wind;\n  }();\n\n  provide(Wind);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/Wind.js?");

/***/ }),

/***/ "./src-compiled/scripts/WindList.js":
/*!******************************************!*\
  !*** ./src-compiled/scripts/WindList.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('WindList', ['Wind'], function (provide, Wind) {\n\n  /**\r\n   * List of winds at different heights;\r\n   * always contains wind at height = 0m (surface wind);\r\n   * that surface wind is always first and cannot be removed.\r\n   * All winds must have number height.\r\n   * List will be sorted for height (from bottom to top);\r\n   * all winds should have different heights.\r\n   */\n  var WindList = function () {\n    function WindList(map) {\n      _classCallCheck(this, WindList);\n\n      this.map = map;\n\n      // Surface wind: 5 m/sec, West\n      var angle = 0;\n      this.firstWind = new Wind(5, angle, 0, map);\n      this.firstWind.vertex.addToMap();\n      map.windOutput.print(this.firstWind.toString());\n      map.arrow.rotate(angle);\n\n      this.lastWind = this.firstWind;\n      this.numberOfWinds = 1;\n\n      this.calculator = null;\n    }\n\n    _createClass(WindList, [{\n      key: 'setCalculator',\n      value: function setCalculator(calculator) {\n        this.calculator = calculator;\n        var wind = this.firstWind;\n        while (wind != null) {\n          //wind.vertex.chuteImage.setCalculator(calculator);\n          wind.vertex.setCalculator(calculator);\n          wind = wind.nextWind;\n        }\n      }\n\n      /**\r\n       * Add wind to the List and sort List.\r\n       * Note: wind.height must be a number.\r\n       * @param {Wind} wind\r\n       */\n\n    }, {\n      key: 'addWind',\n      value: function addWind(wind) {\n        wind.vertex.addToMap();\n        this.lastWind.setNextWind(wind);\n        this.lastWind = wind;\n        this.numberOfWinds++;\n        //wind.vertex.chuteImage.setCalculator(this.calculator);\n        wind.vertex.setCalculator(this.calculator);\n        this.sortList();\n      }\n\n      /**\r\n       * Remove wind from WindList.\r\n       * Note: you cannot remove firstWind by construction.\r\n       * @param {Wind} wind - It is supposed that wind belongs to WindList.\r\n       */\n\n    }, {\n      key: 'removeWind',\n      value: function removeWind(wind) {\n        // First wind, that is, surface wind, cannot be removed\n        if (wind == this.firstWind) {\n          console.warn(\"This wind was not removed, because it was firstWind.\");\n          return;\n        }\n\n        if (wind.vertex.vertexIsOnMap) {\n          wind.vertex.removeFromMap();\n        }\n\n        wind.prevWind.setNextWind(wind.nextWind);\n        if (wind == this.lastWind) {\n          this.lastWind = this.lastWind.prevWind;\n        }\n        this.numberOfWinds--;\n      }\n\n      /**\r\n       * Check if this list has a wind with given height.\r\n       * @param {number} height\r\n       */\n\n    }, {\n      key: 'heightIsInList',\n      value: function heightIsInList(height) {\n        var wind = this.firstWind;\n        while (wind != null) {\n          if (wind.getHeight() == height) return true;\n          wind = wind.nextWind;\n        }\n        return false;\n      }\n\n      /**\r\n       * Bubble sort (it is practical for small list)\r\n       */\n\n    }, {\n      key: 'sortList',\n      value: function sortList() {\n        while (true) {\n          var wind = this.firstWind;\n          var swapped = false;\n\n          while (wind != this.lastWind) {\n            if (wind.height > wind.nextWind.height) {\n              this.swapWindAndNextWind(wind);\n              swapped = true;\n            } else {\n              wind = wind.nextWind;\n            }\n          }\n          if (!swapped) break;\n        }\n      }\n\n      /**\r\n       * Print List in console (for development needs)\r\n       */\n\n    }, {\n      key: 'printList',\n      value: function printList() {\n        console.log('\\n\\n\\n');\n        var wind = this.firstWind;\n        var i = 0;\n        while (wind != null) {\n          console.log('wind #' + i + ':');\n          console.log(wind);\n          i++;\n          wind = wind.nextWind;\n        }\n      }\n\n      /**\r\n       * Swap wind and wind.nextWind.\r\n       */\n\n    }, {\n      key: 'swapWindAndNextWind',\n      value: function swapWindAndNextWind(wind) {\n        var nextWind = wind.nextWind;\n        if (nextWind == null) return;\n\n        nextWind.setPrevWind(wind.prevWind);\n        var nextWindNextWind = nextWind.nextWind;\n        nextWind.setNextWind(wind);\n        wind.setNextWind(nextWindNextWind);\n\n        if (this.firstWind == wind) {\n          this.firstWind = nextWind;\n        }\n        if (this.lastWind == nextWind) {\n          this.lastWind = wind;\n        }\n      }\n    }, {\n      key: 'hide',\n      value: function hide() {\n        var wind = this.firstWind;\n        while (wind != null) {\n          wind.vertex.hide();\n          wind = wind.nextWind;\n        }\n      }\n\n      /**\r\n       * Clearing directions: skydiver will fly face forward.\r\n       */\n\n    }, {\n      key: 'clearDirections',\n      value: function clearDirections() {\n        var wind = this.firstWind;\n        while (true) {\n          wind.vertex.chuteImage.chuteDirection = true;\n          wind.vertex.chuteImageBack.chuteDirection = true;\n          wind = wind.nextWind;\n          if (wind == null) break;\n        }\n      }\n    }]);\n\n    return WindList;\n  }();\n\n  provide(WindList);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/WindList.js?");

/***/ }),

/***/ "./src-compiled/scripts/WindPointsList.js":
/*!************************************************!*\
  !*** ./src-compiled/scripts/WindPointsList.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nymaps.modules.define('WindPointsList', [], function (provide) {\n  var WindPointsList = function () {\n    function WindPointsList(point) {\n      _classCallCheck(this, WindPointsList);\n\n      this.firstPoint = point;\n      this.firstPoint.nextPoint = null;\n      this.length = 1;\n      this.currentPoint = point;\n    }\n\n    _createClass(WindPointsList, [{\n      key: 'addPoint',\n      value: function addPoint(point) {\n        this.currentPoint.nextPoint = point;\n        this.currentPoint = point;\n        this.length++;\n      }\n    }]);\n\n    return WindPointsList;\n  }();\n\n  provide(WindPointsList);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/WindPointsList.js?");

/***/ }),

/***/ "./src-compiled/scripts/WindVertex.js":
/*!********************************************!*\
  !*** ./src-compiled/scripts/WindVertex.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nymaps.modules.define('WindVertex', ['Circle', 'templateLayoutFactory', 'PreVertex'], function (provide, Circle, templateLayoutFactory, PreVertex) {\n  /**\r\n   * WindVertex extends PrevVertex:\r\n   * we add Vertex Image (Circle) and special layout for Vertex Placemark.\r\n   */\n  var WindVertex = function (_PreVertex) {\n    _inherits(WindVertex, _PreVertex);\n\n    /**\r\n     * @param {AppMap} map\r\n     */\n    function WindVertex(map, height) {\n      _classCallCheck(this, WindVertex);\n\n      var scale = Math.pow(2, 16 - map.getZoom());\n\n      var _this = _possibleConstructorReturn(this, (WindVertex.__proto__ || Object.getPrototypeOf(WindVertex)).call(this, map, scale));\n\n      _this.map = map;\n      _this.height = height;\n      _this.scale = scale;\n\n      _this.type = 'windVertex';\n\n      _this.setScale = _this.setScale.bind(_this);\n      _this.map.events.add('boundschange', _this.setScale);\n\n      _this.imageRadius = 4;\n\n      _this.image = new ymaps.Circle([null, _this.imageRadius * _this.scale], {}, {\n        fillColor: '#0000FF', // Blue color\n        strokeColor: '#00FF00', // Green color\n        strokeWidth: 2,\n        zIndex: 6\n      });\n\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass('<div class=\"px-2 py-1 bg-success text-center rounded border d-inline-block\"' + 'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' + '$[properties.iconContent]' + '</div>');\n\n      _this.heightPlacemark.options.set('iconLayout', MyIconLayout);\n      //this.heightPlacemark.options.set('zIndex', 7);\n\n      _this.prevVertex = null;\n      _this.nextVertex = null;\n      _this.edge = null;\n\n      _this.eventCircle.events.add('contextmenu', function (e) {\n        e.stopPropagation();\n        this.switchPlacemarkIsVisible();\n      }.bind(_this));\n\n      /*\r\n      this.eventCircle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.switchPlacemarkIsVisible();\r\n      }.bind(this));  */\n      return _this;\n    }\n\n    _createClass(WindVertex, [{\n      key: 'setCoordinates',\n      value: function setCoordinates(point) {\n        _get(WindVertex.prototype.__proto__ || Object.getPrototypeOf(WindVertex.prototype), 'setCoordinates', this).call(this, point);\n        this.image.geometry.setCoordinates(point);\n      }\n\n      /**\r\n       * Hiding Vertex.\r\n       */\n\n    }, {\n      key: 'hide',\n      value: function hide() {\n        _get(WindVertex.prototype.__proto__ || Object.getPrototypeOf(WindVertex.prototype), 'hide', this).call(this);\n        this.image.geometry.setCoordinates(null);\n        //this.setCoordinates(null);\n        //this.chuteImage.setCoordinates(null);\n      }\n    }, {\n      key: 'addToMap',\n      value: function addToMap() {\n        if (!this.vertexIsOnMap) {\n          this.map.geoObjects.add(this.image);\n        }\n        _get(WindVertex.prototype.__proto__ || Object.getPrototypeOf(WindVertex.prototype), 'addToMap', this).call(this);\n      }\n    }, {\n      key: 'removeFromMap',\n      value: function removeFromMap() {\n        if (this.vertexIsOnMap) {\n          this.map.geoObjects.remove(this.image);\n        }\n        _get(WindVertex.prototype.__proto__ || Object.getPrototypeOf(WindVertex.prototype), 'removeFromMap', this).call(this);\n      }\n    }, {\n      key: 'setScale',\n      value: function setScale() {\n        var scale = Math.pow(2, 16 - this.map.getZoom());\n        _get(WindVertex.prototype.__proto__ || Object.getPrototypeOf(WindVertex.prototype), 'setScale', this).call(this, scale);\n        this.scale = scale;\n        this.image.geometry.setRadius(this.imageRadius * this.scale);\n      }\n    }, {\n      key: 'setColor',\n      value: function setColor(color) {\n        this.image.options.set('fillColor', color);\n      }\n    }, {\n      key: 'setStrokeColor',\n      value: function setStrokeColor(color) {\n        this.image.options.set('strokeColor', color);\n      }\n    }, {\n      key: 'printPlacemarkAndHint',\n      value: function printPlacemarkAndHint(str) {\n        _get(WindVertex.prototype.__proto__ || Object.getPrototypeOf(WindVertex.prototype), 'printPlacemarkAndHint', this).call(this, str + '&nbsp;м');\n      }\n    }]);\n\n    return WindVertex;\n  }(PreVertex);\n\n  provide(WindVertex);\n});\n\n//# sourceURL=webpack:///./src-compiled/scripts/WindVertex.js?");

/***/ }),

/***/ "./src-compiled/scripts/index.js":
/*!***************************************!*\
  !*** ./src-compiled/scripts/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Program calculate heights of Glider (Chute) for\r\n * Vertices of the Path. Path is a set of Vertices and Edges.\r\n * You can input Path by clicking on the Yandex Map.\r\n */\nymaps.ready(init);\nfunction init() {\n  ymaps.modules.require(['AppMap', 'WindList', 'Chute', 'Path', 'Calculator', 'DialogWindows']).spread(function (AppMap, WindList, Chute, Path, Calculator, DialogWindows) {\n    // Yandex map\n    var map = new AppMap();\n\n    // Chute velocity = (10, 5) m/s\n    var chute = new Chute(10, 5);\n\n    // Winds at several heights\n    var windList = new WindList(map);\n\n    // List of Vertices and Edges\n    var path = new Path(map);\n    map.setPath(path);\n\n    // Calculator will make all computations\n    var calculator = new Calculator(path, chute, windList);\n    path.setCalculator(calculator);\n    windList.setCalculator(calculator);\n\n    // Click on the map will add vertice to the end of the Path,\n    // double click on the map will add vertice to the beginning of the Path.\n    var clickNumber = 0;\n    map.events.add('click', function (e) {\n      var point = e.get('coords');\n      clickNumber++;\n      if (clickNumber == 1) {\n        setTimeout(function () {\n          if (clickNumber == 1) {\n            // Single Click\n            // We add vertex to the end of the Path\n            path.addVertex(point, true);\n          } else {\n            // Double Click\n            // We add new vertex to the beginning of the Path\n            path.addVertex(point, false);\n          }\n          clickNumber = 0;\n        }, 200);\n      }\n    });\n\n    map.events.add('boundschange', function () {\n      calculator.calculateHeight();\n    });\n\n    /**\r\n     * Menu initialization\r\n     */\n    DialogWindows.initMenu(map, chute, windList, path, calculator);\n  });\n}\n\n//# sourceURL=webpack:///./src-compiled/scripts/index.js?");

/***/ }),

/***/ 0:
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src-compiled/scripts/AppMap.js ./src-compiled/scripts/Arrow.js ./src-compiled/scripts/Calculator.js ./src-compiled/scripts/Chute.js ./src-compiled/scripts/ChuteImage.js ./src-compiled/scripts/Constant.js ./src-compiled/scripts/DialogWindows.js ./src-compiled/scripts/Edge.js ./src-compiled/scripts/index.js ./src-compiled/scripts/MenuButton.js ./src-compiled/scripts/OutputElement.js ./src-compiled/scripts/Path.js ./src-compiled/scripts/PreVertex.js ./src-compiled/scripts/TriangleVertexImage.js ./src-compiled/scripts/VectorMath.js ./src-compiled/scripts/Vertex.js ./src-compiled/scripts/Wind.js ./src-compiled/scripts/WindList.js ./src-compiled/scripts/WindPointsList.js ./src-compiled/scripts/WindVertex.js ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src-compiled/scripts/AppMap.js */\"./src-compiled/scripts/AppMap.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Arrow.js */\"./src-compiled/scripts/Arrow.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Calculator.js */\"./src-compiled/scripts/Calculator.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Chute.js */\"./src-compiled/scripts/Chute.js\");\n__webpack_require__(/*! ./src-compiled/scripts/ChuteImage.js */\"./src-compiled/scripts/ChuteImage.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Constant.js */\"./src-compiled/scripts/Constant.js\");\n__webpack_require__(/*! ./src-compiled/scripts/DialogWindows.js */\"./src-compiled/scripts/DialogWindows.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Edge.js */\"./src-compiled/scripts/Edge.js\");\n__webpack_require__(/*! ./src-compiled/scripts/index.js */\"./src-compiled/scripts/index.js\");\n__webpack_require__(/*! ./src-compiled/scripts/MenuButton.js */\"./src-compiled/scripts/MenuButton.js\");\n__webpack_require__(/*! ./src-compiled/scripts/OutputElement.js */\"./src-compiled/scripts/OutputElement.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Path.js */\"./src-compiled/scripts/Path.js\");\n__webpack_require__(/*! ./src-compiled/scripts/PreVertex.js */\"./src-compiled/scripts/PreVertex.js\");\n__webpack_require__(/*! ./src-compiled/scripts/TriangleVertexImage.js */\"./src-compiled/scripts/TriangleVertexImage.js\");\n__webpack_require__(/*! ./src-compiled/scripts/VectorMath.js */\"./src-compiled/scripts/VectorMath.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Vertex.js */\"./src-compiled/scripts/Vertex.js\");\n__webpack_require__(/*! ./src-compiled/scripts/Wind.js */\"./src-compiled/scripts/Wind.js\");\n__webpack_require__(/*! ./src-compiled/scripts/WindList.js */\"./src-compiled/scripts/WindList.js\");\n__webpack_require__(/*! ./src-compiled/scripts/WindPointsList.js */\"./src-compiled/scripts/WindPointsList.js\");\nmodule.exports = __webpack_require__(/*! ./src-compiled/scripts/WindVertex.js */\"./src-compiled/scripts/WindVertex.js\");\n\n\n//# sourceURL=webpack:///multi_./src-compiled/scripts/AppMap.js_./src-compiled/scripts/Arrow.js_./src-compiled/scripts/Calculator.js_./src-compiled/scripts/Chute.js_./src-compiled/scripts/ChuteImage.js_./src-compiled/scripts/Constant.js_./src-compiled/scripts/DialogWindows.js_./src-compiled/scripts/Edge.js_./src-compiled/scripts/index.js_./src-compiled/scripts/MenuButton.js_./src-compiled/scripts/OutputElement.js_./src-compiled/scripts/Path.js_./src-compiled/scripts/PreVertex.js_./src-compiled/scripts/TriangleVertexImage.js_./src-compiled/scripts/VectorMath.js_./src-compiled/scripts/Vertex.js_./src-compiled/scripts/Wind.js_./src-compiled/scripts/WindList.js_./src-compiled/scripts/WindPointsList.js_./src-compiled/scripts/WindVertex.js?");

/***/ })

/******/ });