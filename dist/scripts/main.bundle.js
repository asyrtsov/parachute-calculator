/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/AppMap.js":
/*!*******************************!*\
  !*** ./src/scripts/AppMap.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('AppMap', [\r\n  'Map',\r\n  'control.ZoomControl',\r\n  'Constant',\r\n  'MenuButton',\r\n  'OutputElement',\r\n  'Arrow'\r\n],\r\nfunction(provide, Map, ZoomControl, Constant,\r\n    MenuButton, OutputElement, Arrow) {\r\n  /**\r\n   * @extends Map\r\n   */\r\n  class AppMap extends Map {\r\n\r\n    constructor() {\r\n\r\n      // Array of Dropzones and their coordinates.\r\n      var dz = [\r\n        {name: \"Коломна\", mapCenter: [55.091289443603706, 38.917269584802675]},\r\n        {name: \"Пущино\", mapCenter: [54.78929269708931,37.64268598670033]},\r\n        {name: \"Ватулино\", mapCenter: [55.663193308717396,36.14121807608322]}\r\n      ];\r\n\r\n      super(\"map\", {\r\n        center: dz[0].mapCenter,\r\n        zoom: Constant.defaultZoom\r\n      }, {\r\n        suppressMapOpenBlock: true  // remove button 'open in yandex maps'\r\n      });\r\n\r\n      this.dz = dz;\r\n\r\n      // view from space\r\n      this.setType(\"yandex#satellite\");\r\n      this.cursors.push('arrow');\r\n      this.controls.remove('trafficControl');\r\n      this.controls.remove('zoomControl');\r\n      var zoomControl = new ZoomControl({options: {\r\n        position: { right: 10, top: 105 },\r\n        size: 'small'\r\n      }});\r\n      this.controls.add(zoomControl);\r\n      this.controls.remove('geolocationControl');\r\n      this.controls.remove('fullscreenControl');\r\n\r\n      this.searchControl = this.controls.get('searchControl');\r\n      this.searchControl.options.set('size', 'small');\r\n      this.searchControl.options.set('noPlacemark', true);\r\n      this.searchControl.options.set('noSelect', true);\r\n      this.searchControl.options.set('position', {top: 10, left: 45});\r\n\r\n      // Settings menu (ymaps.Button)\r\n      var settingsButton = new MenuButton(\"Настройки\", \"images/icon_menu.svg\",\r\n        \"#settingsMenu\", \"#settingsMenuDarkScreen\");\r\n      //this.controls.add(settingsButton, {position: {top: 45, left: 10}});\r\n      this.controls.add(settingsButton, {position: {top: 10, left: 10}});\r\n\r\n      // Output for Surface wind parameters (ymaps.Button)\r\n      this.windOutput = new OutputElement();\r\n      this.controls.add(this.windOutput, {position: {bottom: 30, left: 10}});\r\n\r\n      // Wind arrow (Windsock)\r\n      this.arrow = new Arrow(this.getCenter());\r\n      this.geoObjects.add(this.arrow);\r\n\r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.preventDefault();\r\n      });\r\n\r\n      //this.menu = null;\r\n    }\r\n\r\n    /**\r\n     * Processing of yandex.maps search\r\n     */   /*\r\n    setSearchProcessor(calculator) {\r\n\r\n      this.calculator = calculator;\r\n      this.path = calculator.path;\r\n      this.windList = calculator.windList;\r\n\r\n      this.defaultZoom = Constant.defaultZoom;\r\n\r\n      this.searchControl.events.add('resultshow', function(e) {\r\n\r\n        this.path.clear();\r\n        this.setZoom(this.defaultZoom);\r\n        //this.windList.shiftList(this.getCenter());\r\n        this.map.arrow.setCoordinates(this.map.getCenter());\r\n\r\n        var index = e.get('index');\r\n        var geoObjectsArray = this.searchControl.getResultsArray();\r\n        var resultName = geoObjectsArray[index].properties.get('name');\r\n\r\n        var newDz = {\r\n          name: resultName,\r\n          mapCenter: this.getCenter()\r\n        };\r\n        this.dz.push(newDz);\r\n        $(\"#dz\").append(\"<option>\" + newDz.name + \"</option>\");\r\n        $(\"#dz\").children()[this.dz.length - 1].selected = true;\r\n      }.bind(this));\r\n    }  */\r\n\r\n  }\r\n  provide(AppMap);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/AppMap.js?");

/***/ }),

/***/ "./src/scripts/Arrow.js":
/*!******************************!*\
  !*** ./src/scripts/Arrow.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Arrow', [\r\n  'Placemark',\r\n  'templateLayoutFactory',\r\n  'Constant'\r\n],\r\nfunction(provide, Placemark, templateLayoutFactory, Constant) {\r\n  /**\r\n   * Wind Arrow (Yandex Maps API Placemark).\r\n   * You can: rotate it, change its size and coordinates.\r\n   */\r\n  class Arrow extends Placemark {\r\n\r\n    constructor(coordinates = null) {\r\n      var arrowStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var arrowStartRadius = Constant.isMobile ?\r\n          arrowStartSize : arrowStartSize/2;\r\n\r\n      super([], {\r\n          arrowClass: 'arrow',\r\n          rotation: 0,\r\n          size: arrowStartSize\r\n        }, {\r\n          draggable: true,\r\n          iconLayout: templateLayoutFactory.createClass(\r\n              '<div class=\"$[properties.arrowClass]\" ' +\r\n                  'style=\"transform: rotate($[properties.rotation]deg);' +\r\n                      'width: $[properties.size]px; height: $[properties.size]px;\"/>'),\r\n          iconShape: {\r\n            type: 'Circle',\r\n            coordinates: [arrowStartSize/2, arrowStartSize/2],\r\n            radius: arrowStartRadius\r\n          }\r\n        }\r\n      );\r\n\r\n      this.arrowStartSize = arrowStartSize;\r\n      this.arrowStartRadius = arrowStartRadius;\r\n\r\n      if (coordinates != null) {\r\n        this.setCoordinates(coordinates);\r\n      }\r\n\r\n      this.boundChange = this.boundChange.bind(this);\r\n    }\r\n\r\n    setCoordinates(coordinates) {\r\n      this.geometry.setCoordinates(coordinates);\r\n    }\r\n\r\n   /**\r\n    * Rotate arrow\r\n    * @param {Number} angle - In degrees.\r\n    */\r\n    rotate(angle) {\r\n      this.properties.set('rotation', (-1)*angle);\r\n    }\r\n\r\n    /**\r\n     * Arrow can have different size for different Zoom.\r\n     */\r\n    changeSize(newZoom) {\r\n      var size = (2**(newZoom - Constant.defaultZoom))*(this.arrowStartSize);\r\n\r\n      var shape = {\r\n        type: 'Circle',\r\n        coordinates: [size/2, size/2],\r\n        radius: (2**(newZoom - Constant.defaultZoom))*(this.arrowStartRadius)\r\n      };\r\n\r\n      this.options.set('iconShape', shape);\r\n      this.properties.set('size', size);\r\n      // properties.set call rebuild of Placemark,\r\n      // so, properties.set should stay after options.set\r\n    }\r\n\r\n    /**\r\n     * If Yandex Maps Zoom is changed we will call this.changeSize() function.\r\n     * @param {Event} e - Yandex Maps 'boundschange' event.\r\n     */\r\n    boundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        this.changeSize(newZoom);\r\n      }\r\n    }\r\n  }\r\n\r\n  provide(Arrow);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Arrow.js?");

/***/ }),

/***/ "./src/scripts/Calculator.js":
/*!***********************************!*\
  !*** ./src/scripts/Calculator.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Calculator', [\r\n  'VectorMath',\r\n  'Constant',\r\n],\r\nfunction(provide, VectorMath, Constant) {\r\n  /**\r\n   * This class calculates:\r\n   * a) heights at all vertices of the Path\r\n   * (it will be kept in vertex.height varialables where vertex belongs\r\n   * to Path),\r\n   * b) points on the Path where wind changes (it will be kept in\r\n   * wind.vertex varialables where wind belongs to WindList).\r\n   */\r\n  class Calculator {\r\n    /**\r\n     * @param {Path} path - list of vertices and edges of Chute Path.\r\n     * @param {Chute} chute - Chute velocity.\r\n     * @param {WindList} windList\r\n     */\r\n    constructor(path, chute, windList) {\r\n      this.path = path;\r\n      this.chute = chute;\r\n      this.windList = windList;\r\n\r\n      // If edgeChuteVelocity is positive and less than this value,\r\n      // will will suppose that edgeChuteVelocity is equals this value. In m/s.\r\n      this.minEdgeChuteVelocity = 0.001;\r\n    }\r\n\r\n\r\n    /**\r\n     * Main calculation function.\r\n     */\r\n    calculateHeight(fromBaseToLast = null) {\r\n      if (this.path.length == 0) {\r\n        this.windList.hide();\r\n        return;\r\n      }\r\n\r\n      switch(fromBaseToLast) {\r\n        case true:\r\n          this.calculateHeightForward();\r\n          break;\r\n\r\n        case false:\r\n          this.calculateHeightBack();\r\n          break;\r\n\r\n        case null:\r\n          this.calculateHeightForward();\r\n          this.calculateHeightBack();\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Case: calculation from Base Vertex to Last Vertex.\r\n     */\r\n    calculateHeightForward() {\r\n      var path = this.path,\r\n          chute = this.chute,\r\n          windList = this.windList;\r\n\r\n      var vertexA = path.baseVertex;\r\n      var pointA = vertexA.getCoordinates();\r\n\r\n      var zeroHeightIsReached = false;\r\n      var wind = windList.lastWind;\r\n\r\n      // Skip to wind corresponding to base vertex\r\n      // (first wind, such that wind.height < vertexA.height)\r\n      // Note: height in base vertex should be >= 0.\r\n      if (vertexA.height > 0) {\r\n        while(wind.height >= vertexA.height) {\r\n\r\n          if (wind.height == vertexA.height) {\r\n            wind.vertex.setCoordinates(pointA);\r\n          }\r\n\r\n          wind = wind.prevWind;\r\n        }\r\n      } else {\r\n        wind = windList.firstWind;\r\n        if (vertexA.height == 0) {\r\n          wind.vertex.setCoordinates(pointA);\r\n        }\r\n      }\r\n\r\n      // If there is nothing to calculate in forward direction,\r\n      // we should hide nearby wind vertex and return.\r\n      if (vertexA == path.lastVertex) {\r\n        while(wind != null) {\r\n         wind.vertex.hide();\r\n         wind = wind.prevWind;\r\n        }\r\n        return;\r\n      }\r\n\r\n      var vertexB = vertexA.nextVertex;\r\n      // Later, pointA can be any point of edge,\r\n      // pointB always will be vertex,\r\n      // pointA and pointB belong to the one edge\r\n      var pointB = vertexB.getCoordinates();\r\n      var pointAHeight = vertexA.height;\r\n\r\n      var edgeChuteDirection;\r\n\r\n      var pointAIsPathVertex = true;\r\n      var chutePolarAngle;\r\n\r\n      while(true) {\r\n        // edgeChuteVelocity is velocity along edge [pointA, pointB] at pointA.\r\n        // 'wind' is a wind in pointA.\r\n        // Our aim is to calculate height in pointB.\r\n        edgeChuteDirection = vertexA.chuteImage.chuteDirection;\r\n        var calcResults =\r\n            this.calculateChuteVelocity(\r\n                pointA, pointB, chute, wind, edgeChuteDirection);\r\n\r\n        var edgeChuteVelocity = calcResults.chuteEdgeVelocity;\r\n        chutePolarAngle = calcResults.chutePolarAngle;\r\n        // Convert from Radians to Degrees.\r\n        chutePolarAngle = (chutePolarAngle / Math.PI) * 180;\r\n        var chuteCanFlyAlongLine = calcResults.chuteCanFlyAlongLine;\r\n\r\n        if (!chuteCanFlyAlongLine) {\r\n          //console.log('chuteCanNotFlyAlongLine');\r\n          break;\r\n        }\r\n\r\n        if (edgeChuteVelocity < 0) {\r\n          //console.log('edgeVelocity < 0');\r\n          break;\r\n        }\r\n\r\n        if (edgeChuteVelocity < this.minEdgeChuteVelocity) {\r\n          console.log('edgeChuteVelocity:' + edgeChuteVelocity);\r\n          edgeChuteVelocity = this.minEdgeChuteVelocity;\r\n        }\r\n\r\n        if (edgeChuteVelocity > 0) {\r\n          var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n          var t1 = dist / edgeChuteVelocity;\r\n\r\n          if (wind != windList.firstWind) {\r\n            var t2 = (pointAHeight - wind.getHeight()) / chute.verticalVel;\r\n            if (t2 >= t1) {\r\n              // Case: with current wind, chute will reach (vertexB) pointB\r\n              vertexB.setHeight(pointAHeight - t1 * this.chute.verticalVel);\r\n              vertexB.prevEdge.hideDividingPoint();\r\n              vertexB.prevEdge.setColor('#0000FF');  // Blue color.\r\n\r\n              if (t2 == t1) {\r\n                wind.vertex.setCoordinates(pointB);\r\n                wind = wind.prevWind;\r\n              }\r\n\r\n              vertexA.chuteImage.setPosition(pointA, pointB, chutePolarAngle);\r\n              vertexA.chuteImage.show();\r\n\r\n              vertexA = vertexB;\r\n              pointAIsPathVertex = true;\r\n              vertexB = vertexB.nextVertex;\r\n              if (vertexB == null) break;\r\n\r\n              pointA = vertexA.getCoordinates();\r\n              pointB = vertexB.getCoordinates();\r\n              pointAHeight = vertexA.height;\r\n              continue;\r\n            } else {\r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n\r\n              var pointC = pointA;\r\n\r\n              pointA =\r\n                  VectorMath.findIntermediatePoint(\r\n                      pointA, pointB, (t2 * edgeChuteVelocity)/dist);\r\n\r\n              // pointAHeight = wind.getHeight();\r\n              pointAHeight -= t2 * this.chute.verticalVel;\r\n\r\n              vertexA.chuteImage.setPosition(pointC, pointA, chutePolarAngle);\r\n              vertexA.chuteImage.show();\r\n\r\n              wind.vertex.setCoordinates(pointA);\r\n              vertexA = wind.vertex;\r\n              pointAIsPathVertex = false;\r\n              wind = wind.prevWind;\r\n              continue;\r\n            }\r\n          } else {\r\n            // case: wind = windList.firstWind\r\n            //if (t1 > Constant.maxFlightTime) break;\r\n            if (edgeChuteVelocity == this.minEdgeChuteVelocity) break;\r\n\r\n            vertexB.setHeight(pointAHeight - t1 * this.chute.verticalVel);\r\n            vertexB.prevEdge.hideDividingPoint();\r\n            vertexB.prevEdge.setColor('#0000FF');  // Blue color.\r\n\r\n            if (!zeroHeightIsReached) {\r\n              if (vertexB.height == 0) {\r\n                wind.vertex.setCoordinates(pointB);\r\n                zeroHeightIsReached = true;\r\n              }\r\n\r\n              if ((pointAHeight > 0) && (vertexB.height < 0)) {\r\n                var pointC =\r\n                    VectorMath.findIntermediatePoint(\r\n                        pointA, pointB, pointAHeight/(pointAHeight - vertexB.height));\r\n\r\n                wind.vertex.setCoordinates(pointC);\r\n\r\n                vertexA.chuteImage.setPosition(pointA, pointC, chutePolarAngle);\r\n                vertexA.chuteImage.show();\r\n\r\n                zeroHeightIsReached = true;\r\n\r\n                vertexA = wind.vertex;\r\n                pointAIsPathVertex = false;\r\n\r\n                pointA = vertexA.getCoordinates();\r\n                pointAHeight = vertexA.height;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            vertexA.chuteImage.setPosition(pointA, pointB, chutePolarAngle);\r\n            vertexA.chuteImage.show();\r\n\r\n            vertexA = vertexB;\r\n            pointAIsPathVertex = true;\r\n\r\n            vertexB = vertexB.nextVertex;\r\n            if (vertexB == null) break;\r\n\r\n            pointA = vertexA.getCoordinates();\r\n            pointB = vertexB.getCoordinates();\r\n            pointAHeight = vertexA.height;\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (vertexB != null) {\r\n        vertexB.setHeight(null);\r\n\r\n        if (pointAIsPathVertex) {\r\n          vertexA.nextEdge.hideDividingPoint();\r\n          vertexA.nextEdge.setColor('#FF0000');\r\n        } else {  // pointA is a wind vertex\r\n          vertexB.prevEdge.setDividingPoint(pointA);\r\n          vertexB.prevEdge.setColor('#0000FF', '#FF0000');\r\n        }\r\n\r\n        vertexA.chuteImage.setPosition(pointA, pointA, chutePolarAngle);\r\n\r\n        var vertex = vertexB.nextVertex;\r\n        while(vertex != null) {\r\n          vertex.setHeight(null);\r\n          vertex.prevEdge.hideDividingPoint();\r\n          vertex.prevEdge.setColor('#FF0000');  // Red color.\r\n          vertex.prevVertex.chuteImage.hide();\r\n          vertex = vertex.nextVertex;\r\n        };\r\n      }\r\n\r\n      // Hide last wind points.\r\n      if (!zeroHeightIsReached) {\r\n        while(wind != null) {\r\n          wind.vertex.hide();\r\n          wind = wind.prevWind;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Case: calculation from Base Vertex to First Vertex.\r\n     */\r\n    calculateHeightBack() {\r\n      var path = this.path,\r\n          chute = this.chute,\r\n          windList = this.windList;\r\n\r\n      var vertexB = path.baseVertex;\r\n      var pointB = vertexB.getCoordinates();\r\n\r\n      // true iff lastWindPoint will be on the Path after calculation.\r\n      //var lastWindPointIsShown = false;\r\n\r\n      //var wind = windList.firstWind;\r\n\r\n      /*\r\n      if (wind.getHeight() < vertexB.height) {\r\n        // that is, 0 < vertexB.height\r\n        while(true) {\r\n          //wind.setVertexCoordinates(null);\r\n\r\n          if (wind.nextWind == null) break;\r\n          //if (wind.nextWind.getHeight() == null) break;\r\n\r\n          if (wind.nextWind.getHeight() > vertexB.height) break;\r\n\r\n          if (wind.nextWind.getHeight() == vertexB.height) {\r\n            wind = wind.nextWind;\r\n            //wind.setVertexCoordinates(pointB);\r\n            wind.vertex.setCoordinates(pointB);\r\n            break;\r\n          }\r\n          wind = wind.nextWind;\r\n        }\r\n      } */\r\n\r\n      var wind = windList.lastWind;\r\n\r\n      if (vertexB.height >= 0) {\r\n        while(wind.height > vertexB.height) {\r\n          wind = wind.prevWind;\r\n        }\r\n\r\n        if (wind.height == vertexB.height) {\r\n          wind.vertex.setCoordinates(pointB);\r\n        }\r\n\r\n      } else {\r\n        wind = windList.firstWind;\r\n        //if (vertexB.height == 0) {\r\n        //  wind.vertex.setCoordinates(pointB);\r\n        //}\r\n      }\r\n\r\n\r\n\r\n      if (vertexB == path.firstVertex) {\r\n        wind = wind.nextWind;\r\n        while(wind != null) {\r\n          //wind.nextWind.setVertexCoordinates(null);\r\n          wind.vertex.hide();\r\n          wind = wind.nextWind;\r\n        }\r\n        return;\r\n      }\r\n\r\n      var vertexA = vertexB.prevVertex;\r\n      // pointA will always be vertex,\r\n      // pointB can be vertex or point on the edge\r\n      var pointA = vertexA.getCoordinates();\r\n      var pointBHeight = vertexB.height;\r\n\r\n      var edgeChuteDirection;\r\n      var pointBIsPathVertex = true;\r\n      var chutePolarAngle;\r\n\r\n      while(true) {\r\n        // Note: here pointA is only for setting direction;\r\n        // if there will be changing wind on the edge,\r\n        // the chute will fly with following velocity only after\r\n        // last changing (in the direction, determined by\r\n        // vector pointApointB)\r\n\r\n        edgeChuteDirection = vertexA.chuteImage.chuteDirection;\r\n\r\n\r\n        var edgeChuteVelocity =\r\n            this.calculateChuteVelocity(\r\n                pointA, pointB, chute,\r\n                wind, edgeChuteDirection).chuteEdgeVelocity;\r\n\r\n        // In this case it is impossible to flight this edge\r\n        if (edgeChuteVelocity < 0) break;\r\n\r\n        // Case: chute is hanging above pointB.\r\n        // This is bottom boundary of current wind\r\n        if (edgeChuteVelocity == 0) {\r\n          if (wind == windList.lastWind) break;\r\n          wind = wind.nextWind;\r\n          pointBHeight = wind.getHeight();\r\n          //wind.setVertexCoordinates(pointB);\r\n          wind.vertex.setCoordinates(pointB);\r\n          continue;\r\n        }\r\n\r\n        if (edgeChuteVelocity > 0) {\r\n          if (wind != windList.lastWind) {\r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n            var t1 = dist / edgeChuteVelocity;\r\n            var t2 =\r\n              (wind.nextWind.getHeight() - pointBHeight) / chute.verticalVel;\r\n\r\n            if (t2 >= t1) {\r\n              // Case: with current wind, pointB is reachable from pointA\r\n\r\n              //if (t1 > Constant.maxFlightTime) break;\r\n\r\n              vertexA.setHeight(pointBHeight + t1 * this.chute.verticalVel);\r\n              // Blue color.\r\n              vertexA.nextEdge.setColor('#0000FF');\r\n\r\n              if (wind == windList.firstWind &&\r\n                  pointBHeight < 0 &&\r\n                  vertexA.height > 0) {\r\n                var pointC =\r\n                    VectorMath.findIntermediatePoint(\r\n                        pointA, pointB,\r\n                        vertexA.height/(vertexA.height - pointBHeight));\r\n\r\n                //wind.setVertexCoordinates(pointC);\r\n                wind.vertex.setCoordinates(pointC);\r\n              }\r\n\r\n              vertexB = vertexA;\r\n              vertexA = vertexA.prevVertex;\r\n              if (vertexA == null) break;\r\n              //if (vertexA == path.firstVertex) break;\r\n\r\n              pointA = vertexA.getCoordinates();\r\n              pointB = vertexB.getCoordinates();\r\n              pointBHeight = vertexB.height;\r\n\r\n              edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n              continue;\r\n            } else {\r\n              // Case: with current wind, pointB is NOT reachable from pointA\r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n\r\n              pointB =\r\n                  VectorMath.findIntermediatePoint(\r\n                      pointB, pointA, (t2 * edgeChuteVelocity)/dist);\r\n\r\n              pointBHeight += t2 * this.chute.verticalVel;\r\n\r\n              wind = wind.nextWind;\r\n              //wind.setVertexCoordinates(pointB);\r\n              wind.vertex.setCoordinates(pointC);\r\n              continue;\r\n            }\r\n          } else {\r\n            // case: wind == windList.lastWind\r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n            var t1 = dist / edgeChuteVelocity;\r\n            if (t1 > Constant.maxFlightTime) break;\r\n\r\n            vertexA.setHeight(pointBHeight + (t1 * this.chute.verticalVel));\r\n            // Blue color.\r\n            vertexA.nextEdge.setColor('#0000FF');\r\n            //vertexA.height = pointBHeight + (t1 * this.chute.verticalVel);\r\n\r\n            if (\r\n                wind == windList.firstWind &&\r\n                (pointBHeight < 0) &&\r\n                (vertexA.height > 0)) {\r\n              var pointC =\r\n                  VectorMath.findIntermediatePoint(\r\n                      pointA, pointB,\r\n                      vertexA.height/(vertexA.height - pointBHeight));\r\n\r\n              //wind.setVertexCoordinates(pointC);\r\n              wind.vertex.setCoordinates(pointC);\r\n            }\r\n\r\n            vertexB = vertexA;\r\n            vertexA = vertexA.prevVertex;\r\n            if (vertexA == null) break;\r\n            //if (vertexA == path.firstVertex) break;\r\n\r\n            pointA = vertexA.getCoordinates();\r\n            pointB = vertexB.getCoordinates();\r\n            pointBHeight = vertexB.height;\r\n            edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n\r\n      while(vertexA != null) {\r\n        vertexA.setHeight(null);\r\n        // Red color.\r\n        vertexA.nextEdge.setColor('#FF0000');\r\n        vertexA = vertexA.prevVertex;\r\n      }\r\n\r\n      wind = wind.nextWind;\r\n      while(wind != null) {\r\n        //wind.setVertexCoordinates(null);\r\n        wind.vertex.hide();\r\n        wind = wind.nextWind;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Calculate Polar angle of Chute Velocity and\r\n     * Absolute (relatively to Earth) Chute Velocity along Line Segment\r\n     * (we suppose that chute is flying along this line segment).\r\n     * @param {number[]} pointA - Yandex Maps Coordinates: (latitude, longitude).\r\n     * @param {number[]} pointB - Yandex Maps Coordinates: (latitude, longitude).\r\n     * @param {Chute} chute\r\n     * @param {Wind} wind\r\n     * @param [boolean] edgeChuteDirection - Skydiver can fly with his face directed\r\n     * with or against edge.\r\n     * @returns {Object} Object\r\n     * @returns {number} Object.chuteEdgeVelocity - Absolute Chute Velocity along\r\n     * line segment [pointA, pointB]; in m/sec;\r\n     * Cases: chuteEdgeVelocity < 0 - In this case it is impossible to fly this segment;\r\n     * chuteEdgeVelocity == 0 - hanging above pointA;\r\n     * chuteEdgeVelocity > 0 - chute will fly from pointA to pointB.\r\n     * @returns {number} Object.chutePolarAngle - Polar angle of Chute Velocity, in Radians.\r\n     * @returns {boolean} Object.chuteCanFlyAlongLine - Is true iff chute velotity\r\n     * is greater or equal to wind velocity projection to direction that is\r\n     * perpendicula to the Line Segment.\r\n     */\r\n    calculateChuteVelocity(\r\n        pointA, pointB, chute, wind, edgeChuteDirection = true) {\r\n\r\n      /*\r\n       * Let's find right orthonormal basis (e, f), first vector of which (e)\r\n       * has the same direction with vector [pointA, pointB].\r\n       * Yandex Maps Coordinates: (latitude, longitude)\r\n       * Latitude is increasing from bottom to top (-90deg, 90deg)\r\n       * Longitude is increasing from West to East (-180deg, 180deg)\r\n       */\r\n\r\n      function sign(a) {\r\n        if (a>0) return 1;\r\n        if (a==0) return 0;\r\n        return -1;\r\n      }\r\n\r\n      var sx = sign(pointB[1] - pointA[1]);\r\n      var sy = sign(pointB[0] - pointA[0]);\r\n\r\n      var pointC = [pointA[0], pointB[1]];\r\n\r\n      // now (ex, ey) are coordinates of vector e in standart orthonormal basis:\r\n      // x has direction from left to right,\r\n      // y has direction from bottom to top,\r\n      // scale: 1 meter\r\n      var ex = sx * ymaps.coordSystem.geo.getDistance(pointC, pointA);\r\n      var ey = sy * ymaps.coordSystem.geo.getDistance(pointC, pointB);\r\n\r\n      // Polar angle of vector (pointA, pointB)\r\n      var angle1 =  VectorMath.getPolarFromCartesian([ex, ey]).angle;\r\n\r\n      var d = Math.sqrt(ex*ex + ey*ey);\r\n      ex = ex / d;\r\n      ey = ey / d;\r\n\r\n      var fx = -ey;\r\n      var fy = ex;\r\n\r\n      // Let's find coordinates (we, wf) of vector 'wind' in basis (e, f).\r\n      // (e, f) is orthogonal basis, so we = (wind, e), wf = (wind, f).\r\n      var [wx, wy] = wind.getXY();\r\n\r\n      var we = wx * ex + wy * ey;\r\n      var wf = wx * fx + wy * fy;\r\n\r\n      // Let's find coordinates (ce, cf) of chute velocity\r\n      // in basis (e, f):\r\n      var cf = (-1)*wf;\r\n\r\n      // it is impossible to fly this segment\r\n      if (chute.horizontalVel < Math.abs(cf)) {\r\n        let chutePolarAngle =\r\n            (VectorMath.getPolarFromCartesian(\r\n                 [0, sign(cf)*chute.horizontalVel])).angle;\r\n        chutePolarAngle += angle1;\r\n        return({\r\n          chuteEdgeVelocity: 0,\r\n          chutePolarAngle: chutePolarAngle,\r\n          chuteCanFlyAlongLine: false\r\n        });\r\n      }\r\n\r\n      var directionSign = edgeChuteDirection ? 1 : -1;\r\n      var ce = directionSign * Math.sqrt(chute.horizontalVel**2 - cf**2);\r\n\r\n      // Polar angle of Chute velocity relative to bases {e, f}\r\n      var chutePolarAngle = (VectorMath.getPolarFromCartesian([ce, cf])).angle;\r\n      // Polar angle of Chute velocity\r\n      chutePolarAngle += angle1;\r\n\r\n      var chuteEdgeVelocity = ce + we;\r\n      return({\r\n        chuteEdgeVelocity: chuteEdgeVelocity,\r\n        chutePolarAngle: chutePolarAngle,\r\n        chuteCanFlyAlongLine: true\r\n      });\r\n    }\r\n  }\r\n\r\n  provide(Calculator);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Calculator.js?");

/***/ }),

/***/ "./src/scripts/Chute.js":
/*!******************************!*\
  !*** ./src/scripts/Chute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Chute', [],\r\nfunction(provide) {\r\n\r\n  class Chute {\r\n    /**\r\n     * @param {number} horizontalVel - Horizontal chute velocity, in m/sec.\r\n     * @param {number} verticalVel - Vertical chute velocity, in m/sec.\r\n     */\r\n    constructor(horizontalVel, verticalVel) {\r\n      this.horizontalVel = horizontalVel;\r\n      this.verticalVel = verticalVel;\r\n    }\r\n  }\r\n\r\n  provide(Chute);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Chute.js?");

/***/ }),

/***/ "./src/scripts/ChuteImage.js":
/*!***********************************!*\
  !*** ./src/scripts/ChuteImage.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('ChuteImage', [\r\n  'Placemark',\r\n  'templateLayoutFactory',\r\n  'Constant'\r\n],\r\nfunction(provide, Placemark, templateLayoutFactory, Constant) {\r\n\r\n  /**\r\n   * Chute Image (Yandex Maps API Placemark).\r\n   * You can: rotate it and change its coordinates.\r\n   */\r\n  class ChuteImage extends Placemark {\r\n\r\n    /**\r\n     * @param {null | Number[]} coordinates\r\n     */\r\n    constructor(coordinates = null) {\r\n      var chuteStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var chuteStartRadius = Constant.isMobile ? chuteStartSize : chuteStartSize/2;\r\n\r\n      super(coordinates, {\r\n            chuteClass: 'chute',\r\n            rotation: 0,\r\n            size: chuteStartSize\r\n          }, {\r\n            iconLayout: templateLayoutFactory.createClass(\r\n                '<div class=\"$[properties.chuteClass]\" style=\"transform: rotate($[properties.rotation]deg);' +\r\n                'width: $[properties.size]px; height: $[properties.size]px;\"/>'),\r\n            iconOffset: [-12, -12],\r\n            iconShape: {\r\n              type: 'Circle',\r\n              coordinates: [chuteStartSize/2, chuteStartSize/2],\r\n              radius: chuteStartRadius\r\n            },\r\n            zIndex: 7\r\n          });\r\n\r\n      // If this.chuteDirection = true, chute flyes along wind,\r\n      // else - opposite wind.\r\n      this.chuteDirection = true;\r\n      this.calculator = null;\r\n\r\n      this.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processChuteImageClick(e);\r\n      }.bind(this));\r\n    }\r\n\r\n\r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n\r\n    processChuteImageClick() {\r\n      this.chuteDirection = !this.chuteDirection;\r\n      if (this.calculator != null) {\r\n        this.calculator.calculateHeight();\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {Number[]} point\r\n     */\r\n    setCoordinates(point) {\r\n      this.geometry.setCoordinates(point);\r\n    }\r\n\r\n    hide() {\r\n      this.options.set('visible', false);\r\n    }\r\n\r\n    show() {\r\n      this.options.set('visible', true);\r\n    }\r\n\r\n   /**\r\n    * Rotate arrow\r\n    * @param {Number} angle - In degrees.\r\n    */\r\n    rotate(angle) {\r\n      this.properties.set('rotation', (-1)*angle);\r\n    }\r\n\r\n    /**\r\n     * angle in degrees.\r\n     */\r\n    setPosition(pointA, pointB, angle) {\r\n      this.setCoordinates([\r\n        (pointA[0] + pointB[0])/2,\r\n        (pointA[1] + pointB[1])/2\r\n      ]);\r\n      this.rotate(angle);\r\n    }\r\n  }\r\n\r\n  provide(ChuteImage);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/ChuteImage.js?");

/***/ }),

/***/ "./src/scripts/Constant.js":
/*!*********************************!*\
  !*** ./src/scripts/Constant.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Constant */\r\nymaps.modules.define('Constant', [],\r\nfunction(provide) {\r\n\r\n// Determine mobile or desktop case.\r\nvar isMobile = false;\r\nif (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\r\n  isMobile = true;\r\n}\r\n  /** These varialables are constants for app */\r\n  var Constant = {\r\n    defaultBaseHeight: 300,\r\n    defaultStartHeight: 300,\r\n    defaultFinalHeight: 0,\r\n    defaultZoom: 16,\r\n    defaultCalculationDirection: true,\r\n    // We will not consider the cases when horizontal velocity\r\n    // is more than maxChuteHorizontalVelocity\r\n    maxChuteHorizontalVelocity: 100,  // wingsuit\r\n    maxChuteVerticalVelocity: 50,  // free fall\r\n    maxHeight: 15000,\r\n    maxWindValue: 40,\r\n    // If we will fly more than maxFlightTime, then\r\n    // it is impossible to fly this path\r\n    maxFlightTime: 3600, // 1 hour\r\n    isMobile: isMobile\r\n  }\r\n\r\n  provide(Constant);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Constant.js?");

/***/ }),

/***/ "./src/scripts/DialogWindows.js":
/*!**************************************!*\
  !*** ./src/scripts/DialogWindows.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('DialogWindows', ['Constant', 'Wind'],\r\nfunction(provide, Constant, Wind) {\r\n\r\n  var DialogWindows = {};\r\n  /**\r\n   * @param {AppMap} map\r\n   * @param {Chute} chute\r\n   * @param {WindList} windList\r\n   * @param {Path} path\r\n   * @param {Calculator} calculator\r\n   */\r\n  DialogWindows.initMenu = function(map, chute, windList, path, calculator) {\r\n\r\n    // First active link in Menu will be Dz link\r\n    this.prevLinkId = 'helpLink';\r\n\r\n    initMenuWindow();\r\n    initDzWindow();\r\n    initChuteWindow();\r\n    initHeightWindow();\r\n    initWindWindow();\r\n\r\n    /**\r\n     * Settings Menu initialization\r\n     */\r\n    function initMenuWindow() {\r\n\r\n      $('#helpLinkContent').css('display', 'block');\r\n      $('#helpLink').addClass('active');\r\n\r\n      $('nav a').on('click', function(e) {\r\n        e.preventDefault();\r\n\r\n        let currentLinkId = $(this).attr('id');\r\n\r\n        $('#' + DialogWindows.prevLinkId + \"Content\").css('display', 'none');\r\n        $('#' + currentLinkId + \"Content\").css('display', 'block');\r\n\r\n        $('#' + DialogWindows.prevLinkId).removeClass('active');\r\n        $(this).addClass('active');\r\n\r\n        DialogWindows.prevLinkId = currentLinkId;\r\n      });\r\n\r\n      // Close Settings Menu after clicking Cross or Dark screen\r\n      $(\"#settingsMenuHeaderRectangle, #settingsMenuDarkScreenClickable\").click(function() {\r\n\r\n        $(\"#settingsMenuDarkScreen\").css(\"left\", \"-100%\");\r\n\r\n        if (window.matchMedia(\"(min-width: 768px)\").matches) {\r\n          $(\"#settingsMenu\").css(\"left\", \"-50%\");\r\n        } else {\r\n          $(\"#settingsMenu\").css(\"left\", \"-100%\");\r\n        }\r\n      });\r\n\r\n      // Loose focus after pressing Enter on input field.\r\n      $(\"input\").keypress(function(e) {\r\n        if (e.keyCode === 13 || e.keyCode === 9) {  // Enter keycode\r\n          $(\"input\").blur();     // Forced loose of focus\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    /**\r\n     * Dz Window initialization\r\n     */\r\n    function initDzWindow() {\r\n      // Set default options: dz array\r\n      for(var i=0; i<map.dz.length; i++) {\r\n        $(\"#dz\").append(\"<option>\" + map.dz[i].name + \"</option>\");\r\n      }\r\n\r\n      $(\"#dz\").on(\"change\", function() {\r\n        var mapCenter = map.dz[this.selectedIndex].mapCenter;\r\n        map.setCenter(mapCenter, Constant.defaultZoom);\r\n        map.arrow.setCoordinates(mapCenter);\r\n        // path.clear() will print results too\r\n        path.clear();\r\n      });\r\n    }\r\n\r\n\r\n    /**\r\n     * Chute Window initialization.\r\n     */\r\n    function initChuteWindow() {\r\n      $(\"#chutehorvel\").val(chute.horizontalVel);\r\n      $(\"#chutevervel\").val(chute.verticalVel);\r\n\r\n      $(\"#chutehorvel\").on(\"change\", function () {\r\n        var chutehorvel = Number.parseFloat($(\"#chutehorvel\").val());\r\n        if ((chutehorvel>=0) && (chutehorvel<=Constant.maxChuteHorizontalVelocity)) {\r\n          chute.horizontalVel = chutehorvel;\r\n          $(\"#chutehorvel\").val(chutehorvel);\r\n        } else {\r\n          if (Number.isNaN(chutehorvel)) {\r\n            alert('Недопустимое значение!');\r\n          } else {\r\n            if (chutehorvel < 0) {\r\n              alert('Скорость должна быть неотрицательной!');\r\n            } else {\r\n              alert('Скорость должна быть не больше ' + Constant.maxChuteHorizontalVelocity + 'м/с !');\r\n            }\r\n          }\r\n          $(\"#chutehorvel\").val(chute.horizontalVel);\r\n          return;\r\n        }\r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n        }\r\n      });\r\n\r\n      $(\"#chutevervel\").on(\"change\", function () {\r\n        var chutevervel = Number.parseFloat($(\"#chutevervel\").val());\r\n        if (( chutevervel>=0) && (chutevervel<=Constant.maxChuteVerticalVelocity)) {\r\n          chute.verticalVel = chutevervel;\r\n          $(\"#chutevervel\").val(chutevervel);\r\n        } else {\r\n          if (Number.isNaN(chutevervel)) {\r\n            alert('Недопустимое значение!');\r\n          } else {\r\n            if (chutevervel < 0) {\r\n              alert('Скорость должна быть неотрицательной!');\r\n            } else {\r\n              alert('Скорость должна быть не больше ' + Constant.maxChuteVerticalVelocity + 'м/с !');\r\n            }\r\n          }\r\n          $(\"#chutevervel\").val(chute.verticalVel);\r\n          return;\r\n        }\r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n    /**\r\n     * Height Window initialization.\r\n     */\r\n    function initHeightWindow() {\r\n      $(\"#baseVertexHeight\").val(Math.floor(Constant.defaultBaseHeight));\r\n\r\n      $(\"#baseVertexHeight\").on(\"change\", function() {\r\n        var n = Number.parseFloat($(\"#baseVertexHeight\").val());\r\n\r\n        if ((n >= 0) && (n <= Constant.maxHeight)) {\r\n            path.setBaseVertexHeight(n);\r\n            $(\"#baseVertexHeight\").val(Math.floor(n));\r\n        } else {\r\n\r\n          if (Number.isNaN(n)) {\r\n            alert('Недопустимое значение!');\r\n          } else {\r\n            if (n < 0) {\r\n              alert('Высота в базовой точке должна быть неотрицательной!');\r\n            } else {\r\n              alert('Высота в базовой точке должна быть не больше ' + Constant.maxHeight + 'м !');\r\n            }\r\n          }\r\n\r\n          if (path.length > 0) {\r\n            $(\"#baseVertexHeight\").val(Math.floor(path.baseVertex.height));\r\n          } else {\r\n            $(\"#baseVertexHeight\").val(Math.floor(path.baseVertexHeight));\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Wind Window initialization.\r\n     */\r\n    function initWindWindow() {\r\n\r\n      $(\"#windValueInput\").prop(\"max\", \"\" + Constant.maxWindValue);\r\n      // Draw scales for Range Input Sliders in WindInput window\r\n      drawWindScales();\r\n\r\n\r\n      drawWindScreen();\r\n\r\n      /**\r\n       * Draw WindScreen window in Wind Menu\r\n       */\r\n      function drawWindScreen() {\r\n        $(\"#windInput\").addClass(\"displayNone\");\r\n        $(\"#windScreen\").removeClass(\"displayNone\");\r\n\r\n        var windTable = document.getElementById(\"windTable\");\r\n        windTable.innerHTML = '';\r\n        var funcArray = [];\r\n        var row = [];\r\n        var wind = windList.firstWind;\r\n        for(var i=0; i < windList.numberOfWinds; i++) {\r\n          row[i] = windTable.insertRow(i);\r\n          funcArray[i] = createRowClickListener(wind);\r\n          row[i].addEventListener(\"click\", funcArray[i]);\r\n          var cell1 = row[i].insertCell(0);\r\n          var cell2 = row[i].insertCell(1);\r\n          var cell3 = row[i].insertCell(2);\r\n          cell1.innerHTML = (wind.height == null)? \"?\" : wind.height + \" м\";\r\n          cell2.innerHTML = '<div class=\\\"arrow\\\"></div>';\r\n          cell2.firstChild.style.transform = \"rotate(\" + (-1)*wind.getAngle() + \"deg)\";\r\n          cell3.innerHTML = wind.value + \" м/c\";\r\n          wind = wind.nextWind;\r\n        }\r\n\r\n        // Button Add Wind in WindScreen window\r\n        $(\"#addWind\").click(function() {\r\n          var w = new Wind(5, 0, null, map);\r\n\r\n          $(\"#addWind\").off('click');\r\n          for(var i=0; i < row.length; i++) {\r\n            row[i].removeEventListener('click', funcArray[i]);\r\n          }\r\n          drawWindInput(w);\r\n        });\r\n\r\n        function createRowClickListener(w) {\r\n          return (function(e) {\r\n            $(\"#windScreen\").addClass(\"displayNone\");\r\n            windList.currentWind = w;\r\n            $(\"#windInput\").removeClass(\"displayNone\");\r\n\r\n            $(\"#addWind\").off('click');\r\n            for(var i=0; i < row.length; i++) {\r\n              row[i].removeEventListener('click', funcArray[i]);\r\n            }\r\n\r\n            drawWindInput(w);\r\n          });\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Draw WindInput window in Wind Menu\r\n       */\r\n      function drawWindInput(wind) {\r\n        $(\"#windScreen\").addClass(\"displayNone\");\r\n        $(\"#windInput\").removeClass(\"displayNone\");\r\n\r\n        if (wind == windList.firstWind) {\r\n          $(\"#windHeightInput\").prop(\"disabled\", true);\r\n          $(\"#removeWind\").addClass(\"displayNone\");\r\n        } else {\r\n          $(\"#windHeightInput\").prop(\"disabled\", false);\r\n          $(\"#removeWind\").removeClass(\"displayNone\");\r\n        }\r\n        $(\"#windHeightInput\").val(wind.getHeight());\r\n        $(\"#windDirectionInput\").val(wind.getAngle());\r\n        $(\"#windValueInput\").val(wind.getValue());\r\n        var angle = wind.getAngle();\r\n        $(\"#menuArrow\").css(\"transform\", \"rotate(\" + (-1)*angle + \"deg)\");\r\n        $(\"#menuWindValue\").html(wind.getValue() + \" м/с\");\r\n\r\n\r\n        // Button 'Back to WindScreen' in WindInput window\r\n        $(\"#windInputHeaderArrowRectangle\").click(function() {\r\n          $(\"#windHeightInput\").off(\"change\");\r\n          $(\"#windDirectionInput\").off('input change');\r\n          $(\"#windValueInput\").off('input change');\r\n          $(\"#removeWind\").off('click');\r\n          $(\"#windInputHeaderArrowRectangle\").off('click');\r\n          drawWindScreen();\r\n        });\r\n\r\n        // Button 'Remove current wind' in WindInput window\r\n        $(\"#removeWind\").click(function() {\r\n          if (wind.getHeight() != null) {\r\n            windList.removeWind(wind);\r\n\r\n            if (path.length > 0) {\r\n              calculator.calculateHeight();\r\n            }\r\n          }\r\n          $(\"#windHeightInput\").off(\"change\");\r\n          $(\"#windDirectionInput\").off('input change');\r\n          $(\"#windValueInput\").off('input change');\r\n          $(\"#removeWind\").off('click');\r\n          $(\"#windInputHeaderArrowRectangle\").off('click');\r\n          drawWindScreen();\r\n        });\r\n\r\n\r\n        // Input for WindHeight in WindInput window\r\n        $(\"#windHeightInput\").on(\"change\", function() {\r\n\r\n          var heightString = $(\"#windHeightInput\").val();\r\n          var height = Number.parseFloat(heightString);\r\n\r\n          if (!Number.isNaN(height)) {\r\n            if (height > 0) {\r\n              if (height <= Constant.maxHeight) {\r\n                if (!windList.heightIsInList(height)) {\r\n                  if (wind.height == null) {\r\n                    wind.setHeight(height);\r\n                    windList.addWind(wind);\r\n                  } else {\r\n                    wind.setHeight(height);\r\n                    windList.sortList();\r\n                  }\r\n\r\n                  if (path.length > 0) {\r\n                    calculator.calculateHeight();\r\n                  }\r\n                } else {\r\n                  alertError('Такая высота уже была!');\r\n                }\r\n              } else {  // height > Constant.maxHeight\r\n                alertError('Высота должны быть не больше ' + Constant.maxHeight + ' м!');\r\n              }\r\n            } else {  // height <= 0\r\n              if (height == 0) {\r\n                alertError('Поверхностный ветер уже задан!');\r\n              } else {  // height < 0\r\n                alertError('Высота должна быть больше нуля!');\r\n              }\r\n            }\r\n          } else {\r\n            alertError('Недопустимое значение!');\r\n          }\r\n\r\n          function alertError(str) {\r\n            alert(str);\r\n            $(\"#windHeightInput\").val(Math.floor(wind.height));\r\n          }\r\n        });\r\n\r\n\r\n        // Range Input Slider for Wind Direction in WindInput window.\r\n        $(\"#windDirectionInput\").on('input change', function() {\r\n          var angleStr = $(\"#windDirectionInput\").val();\r\n          var angle = Number.parseInt(angleStr);\r\n\r\n          wind.setAngle(angle);\r\n          if (wind == windList.firstWind) {\r\n            map.windOutput.print(wind.toString());\r\n            map.arrow.rotate(angle);\r\n          }\r\n\r\n          $(\"#menuArrow\").css(\"transform\", \"rotate(\" + (-1)*angle + \"deg)\");\r\n\r\n          if ((wind.height != null) && (path.length > 0)) {\r\n            calculator.calculateHeight();\r\n          }\r\n        });\r\n\r\n        // Range Input Slider for  Wind Value in WindInput window.\r\n        $(\"#windValueInput\").on('input change', function() {\r\n          var valueStr = $(\"#windValueInput\").val();\r\n          var value = Number.parseInt(valueStr);\r\n\r\n          wind.setValue(value);\r\n          if (wind == windList.firstWind) {\r\n            map.windOutput.print(wind.toString());\r\n          }\r\n\r\n          $(\"#menuWindValue\").html(value + \" м/с\");\r\n\r\n          if ((wind.height != null) && (path.length > 0)) {\r\n            calculator.calculateHeight();\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw scales for Wind Window:\r\n     *   wind direction scale (E, N, W, S, E),\r\n     *   wind velocity scale (0, ..., Constant.maxWindValue m/s)\r\n     */\r\n    function drawWindScales() {\r\n\r\n      // Create legend for direction range input\r\n      var directionPlateSpan = 5;\r\n      var directionPlateNumber = 4*directionPlateSpan + 1;\r\n      var windValuePlateNumber = 0;\r\n\r\n      for(var i=0; i<directionPlateNumber; i++) {\r\n        var str = \"\";\r\n        switch (i) {\r\n          case 0:\r\n            str = \"В\";\r\n            break;\r\n          case directionPlateSpan:\r\n            str = \"С\";\r\n            break;\r\n          case directionPlateSpan*2:\r\n            str = \"З\";\r\n            break;\r\n          case directionPlateSpan*3:\r\n            str = \"Ю\";\r\n            break;\r\n          case directionPlateSpan*4:\r\n            str = \"В\";\r\n            break;\r\n          default:\r\n            str = \"&nbsp\";\r\n        }\r\n        $(\"#windDirectionInputScale\").append(\"<div class='directionPlate'>\" + str + \"</div>\");\r\n\r\n        var str2;\r\n        if (i % 5 == 0) {\r\n          str2 = windValuePlateNumber;\r\n          windValuePlateNumber += (Constant.maxWindValue / 4);\r\n        } else {\r\n          str2 = \"&nbsp\";\r\n        }\r\n        $(\"#windValueInputScale\").append(\"<div class='directionPlate'>\" + str2 + \"</div>\");\r\n\r\n      }\r\n      $(\".directionPlate\").css({\r\n        \"width\": 100/(directionPlateNumber) + \"%\",\r\n        \"float\": \"left\",\r\n        \"text-align\": \"center\"\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  provide(DialogWindows);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/DialogWindows.js?");

/***/ }),

/***/ "./src/scripts/Edge.js":
/*!*****************************!*\
  !*** ./src/scripts/Edge.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Edge', [\r\n  'Polygon',\r\n  'VectorMath',\r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n  /**\r\n   * PathEdge consists of two Rectangles:\r\n   * Image Rectangle and Invisible Event Rectangle.\r\n   * Invisible Event Rectangle is aimed for catching events\r\n   * (we use it to make GUI more friendly for Users in mobile case).\r\n   * Image Rectange consists of Blue Rectangle and Red Rectangle.\r\n   */\r\n  class Edge {\r\n    /**\r\n     * @param {Vertex} prevVertex\r\n     * @param {Vertex} nextVertex\r\n     * @param {Path} edgeImageWidthWidth\r\n     * @param {boolean} chuteDirection\r\n     */\r\n    constructor(prevVertex, nextVertex, path, chuteDirection = true) {\r\n      this.prevVertex = prevVertex;\r\n      this.nextVertex = nextVertex;\r\n      this.path = path;\r\n      this.map = path.map;\r\n      // true - if Chute motion and Edge has the same direction\r\n      this.chuteDirection = chuteDirection;\r\n\r\n      this.edgeWidth = 1;\r\n      this.edgeImageWidth = this.edgeWidth / 10; // edgeImageWidth;\r\n\r\n      this.scale = 2**(16 - this.map.getZoom());\r\n      this.setScale = this.setScale.bind(this);\r\n      this.map.events.add('boundschange', this.setScale);\r\n\r\n      // Edge connects prevVertex, nextVertex, itself.\r\n      prevVertex.nextVertex = nextVertex;\r\n      prevVertex.nextEdge = this;\r\n      nextVertex.prevVertex  = prevVertex;\r\n      nextVertex.prevEdge = this;\r\n\r\n      var zIndex = 0;\r\n\r\n      // Rectangle vertices will be calculated later\r\n      this.eventRectangle = new Polygon([], {}, {\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0,\r\n        strokeWidth: 0,\r\n        zIndex: 9\r\n      });\r\n\r\n      this.firstImage = new Polygon([], {}, {zIndex: 4});\r\n      this.secondImage = new Polygon([], {}, {zIndex: 4});\r\n\r\n      this.dividingPoint = null;\r\n      this.calculateEdgeRectangles();\r\n      this.setColor('#0000FF');  // firstImage has blue color.\r\n\r\n      this.clickNumber = 0;\r\n\r\n      this.edgeIsOnMap = false;\r\n\r\n      //this.processVertexClick = this.processVertexClick.bind(this);\r\n\r\n      this.eventRectangle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick(e);\r\n      }.bind(this));\r\n    }\r\n\r\n\r\n    setScale() {\r\n      this.scale = 2**(16 - this.map.getZoom());\r\n      this.calculateEdgeRectangles();\r\n    }\r\n\r\n\r\n    setDividingPoint(point) {\r\n      this.dividingPoint = point;\r\n      this.calculateEdgeRectangles();\r\n    }\r\n\r\n    hideDividingPoint() {\r\n      this.setDividingPoint(null);\r\n    }\r\n\r\n    setColor(firstColor, secondColor = null) {\r\n      this.firstImage.options.set('strokeColor', firstColor);\r\n      this.firstImage.options.set('fillColor', firstColor);\r\n\r\n      if (secondColor != null) {\r\n        this.secondImage.options.set('strokeColor', secondColor);\r\n        this.secondImage.options.set('fillColor', secondColor);\r\n      }\r\n    }\r\n\r\n\r\n    addToMap() {\r\n      if (!this.edgeIsOnMap) {\r\n        this.map.geoObjects.add(this.eventRectangle);\r\n        this.map.geoObjects.add(this.firstImage);\r\n        this.map.geoObjects.add(this.secondImage);\r\n        this.edgeIsOnMap = true;\r\n      }\r\n    }\r\n\r\n    removeFromMap() {\r\n      if (this.edgeIsOnMap) {\r\n        this.map.geoObjects.remove(this.eventRectangle);\r\n        this.map.geoObjects.remove(this.firstImage);\r\n        this.map.geoObjects.remove(this.secondImage);\r\n        this.edgeIsOnMap = false;\r\n      }\r\n    }\r\n\r\n\r\n    getChuteDirection() {\r\n      return this.chuteDirection;\r\n    }\r\n\r\n    getColor() {\r\n      var color = this.chuteDirection ? \"#0000FF\" : \"#000050\";\r\n      return color;\r\n    }\r\n\r\n\r\n    /**\r\n     * Process both click and dblclick on this edge.\r\n     * Single clicking is for adding new Vertex.\r\n     * Double clicking is for changing chute direction\r\n     * on this edge (skydiver can fly with his face directed\r\n     * with or against edge).\r\n     */\r\n    processVertexClick(e) {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {\r\n          if (this.clickNumber == 1) {  // Single Click (add Vertex)\r\n            this.divideEdge(e);\r\n            this.clickNumber = 0;\r\n          } else {\r\n            if (this.clickNumber == 2) {  // Double Click (change chute direction)\r\n              this.chuteDirection = !this.chuteDirection;\r\n              let color = this.getColor();\r\n              this.image.options.set(\"fillColor\", color);\r\n              this.image.options.set(\"strokeColor\", color);\r\n              this.clickNumber = 0;\r\n\r\n              this.path.calculator.calculateHeight();\r\n              this.path.printHeightsAndWindPoints();\r\n            }\r\n          }\r\n        }.bind(this), 200);\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Here we calculate projection of point = e.get('coords') to\r\n     * line segment {this.pointA, this.pointB} and then\r\n     * send that projection to path.divideEdge.\r\n     * After this operation this Edge will be deleted.\r\n     * @param {Event} e\r\n     */\r\n    divideEdge(e) {\r\n      var point = e.get('coords');\r\n\r\n      var pointA = this.prevVertex.getCoordinates(),\r\n          pointB = this.nextVertex.getCoordinates();\r\n\r\n      var vector1 = VectorMath.subVectors(point, pointA),\r\n          vector2 = VectorMath.subVectors(pointB, pointA);\r\n      vector2 = VectorMath.normaliseVector(vector2);\r\n      var c = VectorMath.scalarProduct(vector1, vector2);\r\n      var vector3 = VectorMath.multVectorConstant(vector2, c);\r\n\r\n      var point2 = VectorMath.addVectors(pointA, vector3);\r\n\r\n      this.path.divideEdge(this, point2);\r\n    }\r\n\r\n    /**\r\n     * Run this function when geometric parameters of\r\n     * prevVertex or nextVertex are changed.\r\n     * It will recalculate Edge parameters.\r\n     */\r\n    calculateEdgeRectangles() {\r\n      var pointA = this.prevVertex.getCoordinates();\r\n      var pointB =\r\n          this.nextVertex.imageIsTriangle ?\r\n              this.nextVertex.image.getEdgePoint() :\r\n              this.nextVertex.getCoordinates();\r\n\r\n      var vertices =\r\n          this.calculateRectangleVertices(pointA, pointB,\r\n              this.edgeWidth * this.scale);\r\n      this.eventRectangle.geometry.setCoordinates([vertices]);\r\n\r\n      if (this.dividingPoint == null) {\r\n        vertices =\r\n            this.calculateRectangleVertices(pointA, pointB,\r\n                this.edgeImageWidth * this.scale);\r\n        this.firstImage.geometry.setCoordinates([vertices]);\r\n        this.secondImage.geometry.setCoordinates([]);\r\n      } else {\r\n        vertices =\r\n            this.calculateRectangleVertices(pointA, this.dividingPoint,\r\n                this.edgeImageWidth * this.scale);\r\n        this.firstImage.geometry.setCoordinates([vertices]);\r\n\r\n        vertices =\r\n            this.calculateRectangleVertices(this.dividingPoint, pointB,\r\n                this.edgeImageWidth * this.scale);\r\n        this.secondImage.geometry.setCoordinates([vertices]);\r\n      }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {number} width - Width of Rectangle, in meters.\r\n     */\r\n    calculateRectangleVertices (pointA, pointB, width) {\r\n\r\n      var latitude = pointA[0],\r\n          geodesicVectorAB = VectorMath.subVectors(pointB, pointA);\r\n\r\n      var cartVectorAB =\r\n              VectorMath.toLocalVector(geodesicVectorAB, latitude);\r\n\r\n      var v = VectorMath.normaliseVector(cartVectorAB);\r\n\r\n      var w = [(-v[1])*width , v[0]*width];\r\n\r\n      var wg = VectorMath.toGeodesicVector(w, latitude);\r\n      var wwg = [wg[0]*(-1), wg[1]*(-1)];\r\n\r\n      var vertices = [];\r\n      vertices[0] = VectorMath.addVectors(pointA, wg);\r\n      vertices[1] = VectorMath.addVectors(pointB, wg);\r\n      vertices[2] = VectorMath.addVectors(pointB, wwg);\r\n      vertices[3] = VectorMath.addVectors(pointA, wwg);\r\n\r\n      return vertices;\r\n    }\r\n  }\r\n  provide(Edge);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Edge.js?");

/***/ }),

/***/ "./src/scripts/MenuButton.js":
/*!***********************************!*\
  !*** ./src/scripts/MenuButton.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('MenuButton', [\r\n  'control.Button'       \r\n],\r\nfunction(provide, Button) {\r\n  /**\r\n   * MenuButton creates Yandex.Maps API Button.\r\n   * If you click this Button, then CSS property \r\n   * 'left' of two DOM elements (Element1 with jQuerySelector1 and \r\n   *  Element2 with jQuerySelector2) will be set to be 0. \r\n   * @extends control.Button\r\n   */\r\n  class MenuButton extends Button {\r\n    /**\r\n     * @param {string} [title] - Button hint.\r\n     * @param {string} [image] - Src for <img> tag of this button.\r\n     * @param {string} [jQuerySelector1] - jQuery selector for Element1. \r\n     * @param {string} [jQuerySelector2] - jQuery selector for Element2. \r\n     * @param {string} [cssclass] - Css for this button.          \r\n     */ \r\n    constructor(\r\n      title, \r\n      image, \r\n      jQuerySelector1,\r\n      jQuerySelector2,\r\n      cssclass='inputControlElement' \r\n    ) {\r\n      super({\r\n        data: {\r\n          title: title,\r\n          image: image, \r\n          cssclass: cssclass        \r\n        },  \r\n        options: {\r\n          layout: ymaps.templateLayoutFactory.createClass(\r\n            \"<div title='{{data.title}}' class='{{data.cssclass}}'>\" + \r\n              \"<img class='iconimage' src='{{data.image}}'>\" +           \r\n            \"</div>\"\r\n          ),\r\n          maxWidth: 300\r\n        }\r\n      });\r\n                      \r\n      // Result of this Button clicking\r\n      this.events.add('click', function() {         \r\n        $(jQuerySelector2).css(\"left\", \"0\");\r\n        $(jQuerySelector1).css(\"left\", \"0\");      \r\n      });    \r\n    }        \r\n  } \r\n  provide(MenuButton);  \r\n});\r\n\n\n//# sourceURL=webpack:///./src/scripts/MenuButton.js?");

/***/ }),

/***/ "./src/scripts/OutputElement.js":
/*!**************************************!*\
  !*** ./src/scripts/OutputElement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('OutputElement', [\r\n  'control.Button',\r\n  'templateLayoutFactory'\r\n],\r\nfunction(provide, Button, templateLayoutFactory) {\r\n\r\n  class OutputElement extends Button {\r\n    /**\r\n     * @param {string} content\r\n     */\r\n    constructor(content='') {\r\n      super({\r\n        data: {content: content},\r\n\r\n        options: {\r\n          layout: templateLayoutFactory.createClass(\r\n            \"<div class='outputControlElement'>{{data.content}}</div>\"\r\n          ),\r\n         maxWidth: 300\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} str\r\n     */\r\n    print(str) {\r\n      this.data.set('content', str);\r\n    }\r\n  }\r\n  provide(OutputElement);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/OutputElement.js?");

/***/ }),

/***/ "./src/scripts/Path.js":
/*!*****************************!*\
  !*** ./src/scripts/Path.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Path', [\r\n  'Vertex',\r\n  'Edge',\r\n  'Constant',\r\n],\r\nfunction(provide, Vertex, Edge, Constant) {\r\n  /**\r\n   * List of Vertices and Edges.\r\n   * Image of Last Vertex is Triangle. Images of other Vertices are Circles.\r\n   */\r\n  class Path {\r\n    /**\r\n     * @param {Map} map - link to Yandex map.\r\n     */\r\n    constructor(map) {\r\n      this.map = map;\r\n\r\n      this.firstVertex = null;\r\n      this.lastVertex = null;\r\n      this.baseVertex = null;\r\n\r\n      this.baseVertexHeight = Constant.defaultBaseHeight;\r\n      this.length = 0;    // number of vertices\r\n      this.calculator = null;\r\n    }\r\n\r\n\r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n\r\n\r\n    /**\r\n     * Add new Vertex to Path and to Map.\r\n     * Add corresponding Edge to Path and to Map.\r\n     * @param {number[]} point - Yandex.Maps coordinates, point = [x, y].\r\n     * @return {Array} New Last Vertex and new Vast Edge of Path.\r\n     */\r\n    addVertex(point, isAddedtoEnd) {\r\n      var vertex = new Vertex(this.map, point, this);\r\n      vertex.chuteImage.setCalculator(this.calculator);\r\n\r\n      var edge = null;\r\n\r\n      if (this.length > 0) {\r\n        if (isAddedtoEnd) {\r\n          // We should add vertex to the end of path\r\n          var lastPoint = this.lastVertex.getCoordinates();\r\n          vertex.setTriangleImage(lastPoint);\r\n\r\n          edge = new Edge(this.lastVertex, vertex, this);\r\n\r\n          if (this.length > 1) {\r\n            this.lastVertex.setCircleImage();\r\n            this.lastVertex.prevEdge.calculateEdgeRectangles();\r\n          }\r\n\r\n          this.lastVertex = vertex;\r\n          this.lastVertex.setIsBetweenBaseAndLast(true);\r\n        } else {\r\n          // We should add vertex to the beginning of path\r\n          vertex.setCircleImage();\r\n\r\n          if (this.length == 1) {\r\n            this.firstVertex.setTriangleImage(point);\r\n          }\r\n\r\n          edge = new Edge(vertex, this.firstVertex, this);\r\n\r\n          this.firstVertex = vertex;\r\n          this.firstVertex.setIsBetweenBaseAndLast(false);\r\n        }\r\n\r\n        vertex.addToMap();\r\n        edge.addToMap();\r\n        vertex.prevVertex.chuteImage.show();\r\n        this.length++;\r\n\r\n        this.calculator.calculateHeight(isAddedtoEnd);\r\n\r\n      } else {  // this.length == 0;\r\n        vertex.setCircleImage();\r\n        this.firstVertex = vertex;\r\n        this.lastVertex = vertex;\r\n        this.baseVertex = vertex;\r\n        this.firstVertex.setHeight(this.baseVertexHeight);\r\n        vertex.setStrokeColor('#FFFF00');  // Yellow color\r\n        vertex.isBetweenBaseAndLast = null;\r\n        var str = Math.floor(vertex.height) + '&nbsp;м';\r\n        vertex.printHint('h=' + str);\r\n        vertex.printPlacemark(str);\r\n\r\n        vertex.addToMap();\r\n        this.length++;\r\n      }\r\n\r\n      return([vertex, edge]);\r\n    }\r\n\r\n    /**\r\n     * You shouldn't setBaseVertex to vertex with height == null\r\n     * or height < 0.\r\n     * @param {Vertex} vertex\r\n     */\r\n    setBaseVertex(vertex) {\r\n      this.baseVertex.setStrokeColor(this.baseVertex.color);\r\n      this.baseVertex = vertex;\r\n      // Yellow color.\r\n      this.baseVertex.setStrokeColor('#FFFF00');\r\n      this.setVerticesIsBetweenBaseAndLast();\r\n      $(\"#baseVertexHeight\").val(Math.floor(this.baseVertex.height));\r\n      this.baseVertexHeight = this.baseVertex.height;\r\n      //this.calculator.calculateHeight();\r\n    }\r\n\r\n\r\n    setBaseVertexHeight(height) {\r\n      this.baseVertexHeight = height;\r\n      if (this.length > 0) {\r\n        this.baseVertex.setHeight(height);\r\n        this.calculator.calculateHeight();\r\n      }\r\n    }\r\n\r\n\r\n    setVerticesIsBetweenBaseAndLast() {\r\n      this.baseVertex.isBetweenBaseAndLast = null;\r\n      var v = this.baseVertex;\r\n      while((v = v.prevVertex)!= null) {\r\n        v.isBetweenBaseAndLast = false;\r\n      }\r\n      var v = this.baseVertex;\r\n      while((v = v.nextVertex) != null) {\r\n        v.isBetweenBaseAndLast = true;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Divide Edge by point.\r\n     * Point should be on that Edge.\r\n     * @param {Edge} edge\r\n     * @param {number[]} point - Yandex.maps coordinates.\r\n     * @return {Array} New Vertex and two new Edges.\r\n     */\r\n    divideEdge(edge, point) {\r\n      var prevVertex = edge.prevVertex,\r\n          nextVertex = edge.nextVertex;\r\n\r\n      var edgeChuteDirection = edge.getChuteDirection();\r\n\r\n      var vertex = new Vertex(this.map, point, this);\r\n      vertex.chuteImage.setCalculator(this.calculator);\r\n\r\n      vertex.setCircleImage();\r\n\r\n      var edge1 = new Edge(prevVertex, vertex, this, edgeChuteDirection);\r\n      var edge2 = new Edge(vertex, nextVertex, this, edgeChuteDirection);\r\n\r\n      if (vertex.prevVertex.isBetweenBaseAndLast == true ||\r\n          vertex.prevVertex.isBetweenBaseAndLast == null) {\r\n        vertex.setIsBetweenBaseAndLast(true);\r\n      } else {\r\n        vertex.setIsBetweenBaseAndLast(false);\r\n      }\r\n\r\n      this.length++;\r\n\r\n      edge.removeFromMap();\r\n      vertex.addToMap();\r\n      edge1.addToMap();\r\n      edge2.addToMap();\r\n\r\n      this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\r\n      return([vertex, edge1, edge2]);\r\n    }\r\n\r\n    /**\r\n     * Remove vertex from Path and from map.\r\n     * @param {Vertex} vertex\r\n     * @return {(Edge|null)} Edge between previous and next vertices.\r\n     */\r\n    removeVertex(vertex) {\r\n\r\n      if ((vertex == this.baseVertex) && (this.length > 1)) {\r\n        alert('Вы не можете удалить базовую вершину!');\r\n        return;\r\n      }\r\n\r\n      vertex.removeFromMap();\r\n      if (vertex == this.lastVertex && vertex.prevVertex != null) {\r\n        //vertex.prevVertex.setChuteImageCoordinates(null);\r\n        //vertex.prevVertex.chuteImage.setCoordinates(null);\r\n        vertex.prevVertex.chuteImage.hide();\r\n      }\r\n\r\n      var prevVertex = vertex.prevVertex;\r\n      var nextVertex = vertex.nextVertex;\r\n\r\n      var edge = null;\r\n\r\n      if (this.length > 1) {\r\n        if ((prevVertex != null) && (nextVertex != null)) {\r\n\r\n          var prevEdge = vertex.prevEdge;\r\n          var nextEdge = vertex.nextEdge;\r\n\r\n          var edgeChuteDirection =\r\n              prevEdge.getChuteDirection() || nextEdge.getChuteDirection();\r\n\r\n          prevEdge.removeFromMap();\r\n          nextEdge.removeFromMap();\r\n\r\n          var prevPoint = prevVertex.getCoordinates();\r\n\r\n          if (nextVertex == this.lastVertex) {\r\n            nextVertex.setTriangleImage(prevPoint);\r\n          }\r\n\r\n          edge = new Edge(prevVertex, nextVertex, this, edgeChuteDirection);\r\n          edge.addToMap();\r\n\r\n        } else if (nextVertex == null) {  // last vertex case\r\n          var prevEdge = vertex.prevEdge;\r\n\r\n          prevEdge.removeFromMap();\r\n\r\n          this.lastVertex = prevVertex;\r\n          this.lastVertex.nextVertex = null;\r\n          this.lastVertex.nextEdge = null;\r\n\r\n          if (prevVertex.prevVertex != null) {\r\n            var prevPrevPoint = prevVertex.prevVertex.getCoordinates();\r\n            prevVertex.setTriangleImage(prevPrevPoint);\r\n            prevVertex.prevEdge.calculateEdgeRectangles();\r\n          }\r\n        } else {  // first vertex case\r\n          vertex.nextEdge.removeFromMap();\r\n\r\n          nextVertex.prevVertex = null;\r\n          this.firstVertex = nextVertex;\r\n\r\n          if (this.length == 2) {\r\n            nextVertex.setCircleImage();\r\n          }\r\n        }\r\n      } else {  // case: only one circle\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.length--;\r\n\r\n      if (this.length > 0) {\r\n        this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\r\n      }\r\n\r\n      return(edge);\r\n    }\r\n\r\n    /**\r\n     * Drag vertex with neibour edges.\r\n     * @param {Vertex} vertex\r\n     */\r\n    dragVertex(vertex) {\r\n      this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\r\n\r\n      if (vertex.nextEdge != null) {\r\n        vertex.nextEdge.calculateEdgeRectangles();\r\n      }\r\n\r\n      if (vertex.prevEdge != null) {\r\n        vertex.prevEdge.calculateEdgeRectangles();\r\n      }\r\n    }\r\n\r\n\r\n    /** Remove all vetrices and edges from Path and from map. */\r\n    clear() {\r\n      if (this.length > 0 ) {\r\n        var vertex = this.lastVertex;\r\n        vertex.removeFromMap();\r\n\r\n        for(var i=1; i < this.length; i++) {\r\n          vertex = vertex.prevVertex;\r\n          vertex.removeFromMap();\r\n          vertex.nextEdge.removeFromMap();\r\n        }\r\n\r\n        this.length = 0;\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.calculator.calculateHeight();\r\n    }\r\n\r\n  }\r\n  provide(Path);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Path.js?");

/***/ }),

/***/ "./src/scripts/PreVertex.js":
/*!**********************************!*\
  !*** ./src/scripts/PreVertex.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('PreVertex', [\r\n  'Circle',\r\n  'Placemark',\r\n  'ChuteImage',\r\n  'Constant',\r\n],\r\nfunction(provide, Circle, Placemark, ChuteImage, Constant) {\r\n  /**\r\n   * Vertex consists of: Invisible Event Circle (it is used for catching\r\n   * events for Vertex), Vertex Placemark for Output, Chute Placemark.\r\n   */\r\n  class PreVertex {\r\n    /**\r\n     * @param {AppMap} map - Yandex.Map.\r\n     * @param {number} scale\r\n     * @param {number[] | null} coordinates - Yandex.Maps coordinates of center.\r\n     */\r\n    constructor(map, scale, coordinates = null) {\r\n      this.map = map;\r\n\r\n      var radius = 4;\r\n      this.eventRadius = Constant.isMobile ? 6*radius : 3*radius;\r\n\r\n      // Event Circle (invisible)\r\n      this.eventCircle = new ymaps.Circle(\r\n          [coordinates, this.eventRadius * scale], {}, {\r\n            fillOpacity: 0,\r\n            strokeOpacity: 0,\r\n            strokeWidth: 0,\r\n            zIndex: 10\r\n          });\r\n\r\n      // Output Placemark\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        coordinates,\r\n        {iconContent: ''},\r\n        {iconOffset: [0, -35], cursor: 'arrow', zIndex: 8});\r\n\r\n      // Image of chute which shows chute direction on the this.nextEdge\r\n      this.chuteImage = new ChuteImage();\r\n\r\n      this.hintContent = null;\r\n      this.placemarkIsVisible = true;\r\n      this.vertexIsOnMap = false;\r\n\r\n      // remove standart map zoom for double click\r\n      this.eventCircle.events.add('dblclick', function(e) {\r\n        e.stopPropagation();\r\n      });\r\n    }\r\n\r\n\r\n    /**\r\n     * Set the same coordinates for Event Circle and Vertex Placemark.\r\n     * @param {null | number[]} point\r\n     */\r\n    setCoordinates(point) {\r\n      this.eventCircle.geometry.setCoordinates(point);\r\n      this.heightPlacemark.geometry.setCoordinates(point);\r\n    }\r\n\r\n\r\n    /**\r\n     * Hiding Vertex.\r\n     */\r\n    hide() {\r\n      this.setCoordinates(null);\r\n      //this.chuteImage.setCoordinates(null);\r\n      this.chuteImage.hide();\r\n    }\r\n\r\n\r\n    setScale(scale) {\r\n      this.eventCircle.geometry.setRadius(this.eventRadius * scale);\r\n    }\r\n\r\n\r\n    addToMap() {\r\n      if (!this.vertexIsOnMap) {\r\n        this.map.geoObjects.add(this.eventCircle);\r\n        this.map.geoObjects.add(this.heightPlacemark);\r\n        this.map.geoObjects.add(this.chuteImage);\r\n        this.vertexIsOnMap = true;\r\n      } else {\r\n        console.warn('Vertex has already been added to Map!');\r\n      }\r\n    }\r\n\r\n\r\n    removeFromMap() {\r\n      if (this.vertexIsOnMap) {\r\n        this.map.geoObjects.remove(this.eventCircle);\r\n        this.map.geoObjects.remove(this.heightPlacemark);\r\n        this.map.geoObjects.remove(this.chuteImage);\r\n        this.vertexIsOnMap = false;\r\n      } else {\r\n        console.warn('Vertex has already been removed from Map!');\r\n      }\r\n    }\r\n\r\n\r\n    getCoordinates() {\r\n      return this.eventCircle.geometry.getCoordinates();\r\n    }\r\n\r\n\r\n    switchPlacemarkIsVisible() {\r\n      this.placemarkIsVisible = !this.placemarkIsVisible;\r\n      this.heightPlacemark.options.set('visible', this.placemarkIsVisible);\r\n\r\n      if (this.placemarkIsVisible) {\r\n        this.map.geoObjects.remove(this.eventCircle);\r\n        this.eventCircle.properties.set('hintContent', null);\r\n        this.map.geoObjects.add(this.eventCircle);\r\n      } else {\r\n        this.eventCircle.properties.set('hintContent', this.hintContent);\r\n      }\r\n    }\r\n\r\n\r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set('iconContent', '' + str);\r\n    }\r\n\r\n    printHint(str) {\r\n      this.hintContent = '' + str;\r\n      if (!this.placemarkIsVisible) {\r\n        this.eventCircle.properties.set('hintContent', '' + this.hintContent);\r\n      }\r\n    }\r\n\r\n    printPlacemarkAndHint(str) {\r\n      this.printPlacemark(str);\r\n      this.printHint(str);\r\n    }\r\n  }\r\n\r\n  provide(PreVertex);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/PreVertex.js?");

/***/ }),

/***/ "./src/scripts/TriangleVertexImage.js":
/*!********************************************!*\
  !*** ./src/scripts/TriangleVertexImage.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('TriangleVertexImage', [\r\n  'Polygon',\r\n  'VectorMath'\r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n\r\n  /**\r\n   * Let point1, point2 - two points with Yandex.maps (geodesic) coordinates.\r\n   * TriangleVertex is Yandex maps triangle,\r\n   * such that vector (point1, point2) and that triangle\r\n   * form arrow (end of path).\r\n   * Size of arrow is about several meters.\r\n   */\r\n  class TriangleVertexImage extends Polygon {\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.\r\n     * @param {number} scale - It defines size of Triangle.\r\n     * @param {number} zIndex - z-index of Polygon.\r\n     */\r\n    constructor(point1, point2, scale, color, strokeColor, zIndex) {\r\n      // four square brackets is a must for Polygon constructor,\r\n      // non empty super constructor is a must\r\n      super([], {}, {\r\n        fillColor: color,\r\n        strokeColor: strokeColor,\r\n        strokeWidth: 2,\r\n        zIndex: zIndex\r\n      });\r\n\r\n      // Three vertices of triangle\r\n      this.triangleVertices = null;\r\n      // Point on triangle side to which edge will be connected\r\n      this.edgePoint = null;\r\n\r\n      this.scale = scale;\r\n      this.point1 = point1;\r\n      this.point2 = point2;\r\n\r\n      this.setCoordinates(point1, point2);\r\n    }\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.\r\n     */\r\n    setCoordinates (point1, point2) {\r\n      this.point1 = point1;\r\n      this.point2 = point2;\r\n\r\n      var p = this.calculateVertices(point1, point2);\r\n\r\n      this.triangleVertices = [p[0], p[1], p[2]];\r\n      this.edgePoint = p[3];\r\n\r\n      this.geometry.setCoordinates([this.triangleVertices]);\r\n    }\r\n\r\n    getEdgePoint() {\r\n      return(this.edgePoint);\r\n    }\r\n\r\n\r\n    setScale(scale) {\r\n      this.scale = scale;\r\n      this.setCoordinates(this.point1, this.point2);\r\n    }\r\n\r\n\r\n    getScale() {\r\n      return this.scale;\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps point coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps point coordinates.\r\n     * @return {number[][]} points - First three points of this array are\r\n     * the vertices of triangle; last point is a point at the triangle side\r\n     * to which edge will be connected.\r\n     */\r\n    calculateVertices (point1, point2) {\r\n\r\n      var latitude = point1[0],\r\n          geodesicArrowVector = VectorMath.subVectors(point2, point1),\r\n          localArrowVector =\r\n            VectorMath.toLocalVector(geodesicArrowVector, latitude);\r\n\r\n      localArrowVector = VectorMath.normaliseVector(localArrowVector);\r\n\r\n      // Points coordinates in local cartesian coordinate system.\r\n      // First three point are the vertices of triangle.\r\n      // Last point is a point at the triangle side\r\n      // to which edge will be connected.\r\n      var pointsLocal = [[-2, 0.5], [-2, -0.5], [0, 0], [-2,0]];\r\n      for(var i=0; i<4; i++) {\r\n        for(var j=0; j<2; j++) {\r\n          pointsLocal[i][j] *= this.scale;\r\n        }\r\n      }\r\n\r\n      var points = [];\r\n      for(var i=0; i<pointsLocal.length; i++) {\r\n        points[i] = VectorMath.rotateVector(pointsLocal[i], localArrowVector);\r\n        points[i] = VectorMath.addVectors(\r\n          point2,\r\n          VectorMath.toGeodesicVector(points[i], latitude)\r\n        );\r\n      }\r\n\r\n      return(points);\r\n    }\r\n  }\r\n\r\n  provide(TriangleVertexImage);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/TriangleVertexImage.js?");

/***/ }),

/***/ "./src/scripts/VectorMath.js":
/*!***********************************!*\
  !*** ./src/scripts/VectorMath.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('VectorMath', [],\r\nfunction(provide) {\r\n  /** Set of functions for working with Sphere (2 dimensional) vectors. */\r\n  class VectorMath {\r\n       \r\n    /**\r\n     * We consider following local cartesian coordinate system: \r\n     *  axis have the same direction as Latitude-Longtitude, \r\n     *  axis have the same length (with each other), \r\n     *  default scale parameter (0.00008) makes this \r\n     *  coordinate system be of the size we need in our tasks.\r\n     * @param {number[]} geodesicVector - Latitude-Longtitude vector coordinates.\r\n     * @param {number} latitude\r\n     * @param {number} scale - Default value is 0.00008\r\n     * @return {number[]} [vx, vy] - Vector coordinates in cartesian coordinate system.\r\n     */      \r\n    static toLocalVector(geodesicVector, latitude, scale=0.00008) {  \r\n      var vx = geodesicVector[0]/scale;\r\n      var vy = (geodesicVector[1]/scale) * \r\n                Math.cos((Math.PI/180)*latitude);\r\n      return([vx, vy]);\r\n    }\r\n    \r\n    /**\r\n     * Convert Cartesian coordinate to Latitude-Longtitude coordinates.\r\n     * @param {number[]} localVector - Cartesian vector. \r\n     * @param {number} latitude\r\n     * @param {number} scale \r\n     * @return {number[]|0} [vlat, vlon] - [Latitude, Longtitude] or 0 \r\n     *  (if impossible to convert).       \r\n     */\r\n    static toGeodesicVector(localVector, latitude, scale=0.00008) {\r\n      var vlat = localVector[0]*scale;\r\n      var c = Math.cos((Math.PI/180)*latitude);\r\n      if (c == 0) return 0;\r\n      var vlon = (localVector[1]*scale) / c;\r\n      return([vlat, vlon]);\r\n    }\r\n\r\n    static normaliseVector(v) {\r\n      var d = Math.sqrt(v[0]**2 + v[1]**2);\r\n      if (d>0) {\r\n        return ([v[0]/d, v[1]/d]);\r\n      } else {        \r\n        return ([0, 0]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * n = (cos(alpha), sin(alpha)), \r\n     * alpha is angle of rotation\r\n     */\r\n    static rotateVector(v, n) {\r\n      var wx = n[0]*v[0] - n[1]*v[1];\r\n      var wy = n[1]*v[0] + n[0]*v[1];\r\n      return ([wx, wy]);        \r\n    }\r\n\r\n    static addVectors(v1, v2) {\r\n      return([v1[0] + v2[0], v1[1] + v2[1]]);\r\n    } \r\n    \r\n    static subVectors(v1, v2) {\r\n      return([v1[0] - v2[0], v1[1] - v2[1]]);\r\n    }\r\n\r\n    static multVectorConstant(v, a) {\r\n      return([v[0]*a, v[1]*a]);\r\n    }\r\n\r\n    static scalarProduct(v1, v2) {\r\n      return(v1[0]*v2[0] + v1[1]*v2[1]);      \r\n    }\r\n    \r\n    static length(v) {\r\n      return(Math.sqrt(v[0]*v[0] + v[1]*v[1]));\r\n    }\r\n    \r\n    /**\r\n     * pointA + {pointA, pointB} * t\r\n     */       \r\n    static findIntermediatePoint(pointA, pointB, t) {\r\n      var v = this.subVectors(pointB, pointA);      \r\n      var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);      \r\n      v = this.multVectorConstant(v, t);                   \r\n      var point = this.addVectors(pointA, v);\r\n      return(point);  \r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number[]} point - Cartesian coordinates.\r\n     * @returns {Object | null} polarCoordinates - Polar coordinates or null if radius = 0. \r\n     * @returns {number} polarCoordinates.radius\r\n     * @returns {number} polarCoordinates.angle - Here 0 <= angle < 2*PI.\r\n     */\r\n    static getPolarFromCartesian(point) {\r\n      var x = point[0]; \r\n      var y = point[1];\r\n\r\n      var r = Math.sqrt(x*x + y*y);      \r\n      if (r == 0) return {radius: null, angle: null};\r\n        \r\n      var angle = null;\r\n\r\n      if (x > 0) {\r\n        angle = (y >= 0) ? Math.atan(y/x) : (2*Math.PI - Math.atan((-y)/x));\r\n      } else {\r\n        if (x < 0) {\r\n          if (y >= 0) {\r\n            angle = Math.PI - Math.atan(y/(-x));\r\n          } else {\r\n            angle = Math.PI + Math.atan(y/x);\r\n          }\r\n        } else {  // x = 0\r\n          angle = (y > 0) ? Math.PI/2  : Math.PI*(3/2);  \r\n        }\r\n      }  \r\n\r\n      //angle = 360 * (angle / (Math.PI*2));  \r\n      var polarCoordinates = {radius: r, angle: angle};\r\n      return polarCoordinates;\r\n    }\r\n                  \r\n  }      \r\n  provide(VectorMath);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/VectorMath.js?");

/***/ }),

/***/ "./src/scripts/Vertex.js":
/*!*******************************!*\
  !*** ./src/scripts/Vertex.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Vertex', [\r\n  'Circle',\r\n  'Rectangle',\r\n  'TriangleVertexImage',\r\n  'templateLayoutFactory',\r\n  'PreVertex',\r\n],\r\nfunction(provide, Circle, Rectangle, TriangleVertexImage,\r\n    templateLayoutFactory, PreVertex) {\r\n  /**\r\n   * Vertex of Path.\r\n   * Vertex extends PreVertex:\r\n   * we add Vertex Image (Circle or Triangle) and special layouts\r\n   * for Vertex Placemark (with and without closing cross).\r\n   */\r\n  class Vertex extends PreVertex {\r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {AppMap} map\r\n     * @param {Path} path - Link to parent Path; we need it because some vertex\r\n     * operations (like clicking on Placemark Cross = Path clear) change the Path.\r\n     */\r\n    constructor(map, point, path) {\r\n      var scale = 2**(16 - map.getZoom());\r\n\r\n      super(map, scale, point);\r\n\r\n      this.map = map;\r\n      this.path = path;\r\n      this.scale = scale;\r\n\r\n      this.setScale = this.setScale.bind(this);\r\n      map.events.add('boundschange', this.setScale);\r\n\r\n      this.eventCircle.options.set('draggable', true);\r\n      this.eventCircle.options.set('zIndex', 12);\r\n      //this.heightPlacemark.options.set('zIndex', 1);\r\n\r\n      // Image of Vertex. Object of classes: ymaps.Circle or TriangleVertexImage.\r\n      // To set it, use this.setTriangleImage() or this.setCircleImage()\r\n      // You should not add Vertex to Map until Image is not initialized.\r\n      this.image = null;\r\n      this.imageZIndex = 5;\r\n      // null - for undefined (this.image = null),\r\n      // true - for Triangle Image, false - for Circle Image.\r\n      this.imageIsTriangle = null;\r\n      this.circleImageRadius = 4;\r\n\r\n      // Blue color\r\n      this.color = '#0000FF';\r\n      this.strokeColor = '#0000FF';\r\n\r\n      // References to some another Vertices.\r\n      this.prevVertex = null;\r\n      this.nextVertex = null;\r\n\r\n      this.prevEdge = null;\r\n      this.nextEdge = null;\r\n\r\n      // true if this Vertex is situated between\r\n      // Base Vertex and Last Vertex of Path.\r\n      // null - for Base Vertex itself.\r\n      this.isBetweenBaseAndLast = null;\r\n\r\n      this.clickNumber = 0;\r\n\r\n      // Turning on/off vertex when conditon\r\n      // \"reachable/unreachable\" was changed\r\n      this.wasTurnOffBecauseUnreachable = false;\r\n      // The same for back direction\r\n      this.wasTurnOffBecauseBackUnreachable = false;\r\n\r\n      // Chute height at this vertex. It will be calculated later.\r\n      // Use this.setHeight to set up this.height.\r\n      this.height = null;\r\n\r\n      this.eventCircle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n\r\n\r\n      this.eventCircle.events.add('contextmenu', function(e) {\r\n        e.stopPropagation();\r\n        if (this.path.baseVertex != this && this.height != null && this.height >= 0) {\r\n          this.path.setBaseVertex(this);\r\n        } else if (this.height < 0) {\r\n          alert('Нельзя вершину с отрицательной высотой делать базовой');\r\n        }\r\n      }.bind(this));\r\n\r\n\r\n      this.eventCircle.events.add('drag', function(e) {\r\n        e.stopPropagation();\r\n        var point = this.eventCircle.geometry.getCoordinates();\r\n        this.setCoordinates(point);\r\n        this.path.dragVertex(this);\r\n      }.bind(this));\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Set the same coordinates for Event Circle,\r\n     * Vertex Placemark, Vertex Image.\r\n     * Change Direction of Triangle for this Vertex\r\n     * (if this Vertex is Triangle Vertex)\r\n     */\r\n    setCoordinates(point) {\r\n      super.setCoordinates(point);\r\n\r\n      // Note: it supposed that in case of Triangle Vertex, prevVertex != null.\r\n      if (this.image != null) {\r\n        if (this.imageIsTriangle) {\r\n          var prevPoint = this.prevVertex.getCoordinates();\r\n          // Here we calculate vertices of Image Triangle\r\n          this.image.setCoordinates(prevPoint, point);\r\n        } else {\r\n          // In this case, this.image is a Circle, so\r\n          // we can set coordinates of it center.\r\n          this.image.geometry.setCoordinates(point);\r\n        }\r\n      }\r\n\r\n      if (this.nextVertex != null && this.nextVertex.imageIsTriangle) {\r\n        var nextPoint = this.nextVertex.getCoordinates();\r\n        this.nextVertex.image.setCoordinates(point, nextPoint);\r\n      }\r\n    }\r\n\r\n\r\n    setScale() {\r\n      var scale = 2**(16 - this.map.getZoom());\r\n      super.setScale(scale);\r\n      this.scale = scale;\r\n\r\n      if (this.imageIsTriangle) {\r\n        this.image.setScale(scale);\r\n      } else {\r\n        this.image.geometry.setRadius(this.circleImageRadius * scale);\r\n      }\r\n    }\r\n\r\n    setIsBetweenBaseAndLast(isBetweenBaseAndLast) {\r\n      this.isBetweenBaseAndLast = isBetweenBaseAndLast;\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {Vertex | null} vertex\r\n     */\r\n    setNextVertex(vertex) {\r\n      this.nextVertex = vertex;\r\n      if (vertex != null) {\r\n        vertex.prevVertex = this;\r\n      }\r\n    }\r\n\r\n    setPrevVertex(vertex) {\r\n      this.prevVertex = vertex;\r\n      if (vertex != null) {\r\n        vertex.nextVertex = this;\r\n      }\r\n    }\r\n\r\n\r\n    setNextEdge(edge) {\r\n      this.nextEdge = edge;\r\n      if (edge != null) {\r\n        edge.prevVertex = this;\r\n        edge.nextVertex = this.nextVertex;\r\n        if (this.nextVertex != null) {\r\n          this.nextVertex.prevEdge = edge;\r\n        }\r\n      }\r\n    }\r\n\r\n    setPrevEdge(edge) {\r\n      this.prevEdge = edge;\r\n      if (edge != null) {\r\n        edge.nextVertex = this;\r\n        edge.prevVertex = this.prevVertex;\r\n        if (this.prevVertex != null) {\r\n          this.prevVertex.nextEdge = edge;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {number[]} prevPoint - Previuos point that define direction of Triangle.\r\n     */\r\n    setTriangleImage(prevPoint) {\r\n      this.imageIsTriangle = true;\r\n      var map = this.map;\r\n\r\n      if (this.vertexIsOnMap) {\r\n        map.geoObjects.remove(this.image);\r\n        map.geoObjects.remove(this.heightPlacemark);\r\n      }\r\n\r\n      var point1 = prevPoint;\r\n      var point2 = this.getCoordinates();\r\n\r\n      // Set Triangle Image\r\n      this.image =\r\n          new TriangleVertexImage(point1, point2, this.scale,\r\n              this.color, this.strokeColor, this.imageZIndex);\r\n\r\n      // Set Placemark with Closing Cross\r\n      var path = this.path;\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(\r\n        '<div class=\"px-2 py-1 bg-info d-inline-flex rounded border align-items-center\"' +\r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' +\r\n          '<div class=\"bg-info pr-2\">$[properties.iconContent]</div>' +\r\n          '<div class=\"bg-info placemarkCross placemarkCrossImage\"></div>' +\r\n          //'<div class=\"p-0 bg-info hoverColor\">&#10006;</div>' +\r\n        '</div>', {\r\n          build: function () {\r\n            this.constructor.superclass.build.call(this);\r\n            this.path = path;\r\n            var elem = this.getData().geoObject;\r\n            elem.events.add('click', this.clickFunc, this);\r\n            elem.events.add('mouseenter', this.mouseEnter, this);\r\n            elem.events.add('mouseleave', this.mouseLeave, this);\r\n          },\r\n\r\n          clear: function () {\r\n            var elem = this.getData().geoObject;\r\n            elem.events.remove('click', this.clickFunc, this);\r\n            elem.events.remove('mouseenter', this.mouseEnter, this);\r\n            elem.events.remove('mouseleave', this.mouseLeave, this);\r\n\r\n            this.constructor.superclass.clear.call(this);\r\n          },\r\n\r\n          getShape: function () {\r\n            var parentElement = this.getParentElement();\r\n            if (parentElement != null) {\r\n              var element = $('.d-inline-flex', parentElement);\r\n              var width = element[0].offsetWidth;\r\n              var height = element[0].offsetHeight;\r\n              var position = element.position();\r\n\r\n              return new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([\r\n                [position.left + width - 15, position.top],\r\n                [position.left + width, position.top + height]\r\n              ]));\r\n            } else {\r\n              return null;\r\n            }\r\n          },\r\n\r\n          clickFunc: function(e) {\r\n            e.preventDefault();\r\n            if (this.path.length > 2) {\r\n              if (confirm(\"Удалить все метки? \\n\\n (для удаления только одной метки дважды щелкните по ней)\")) {\r\n                this.path.clear();\r\n              };\r\n            } else {\r\n              this.path.clear();\r\n            }\r\n          }.bind(this),\r\n\r\n          mouseEnter: function() {\r\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\r\n            $(elem).removeClass('placemarkCrossImage');\r\n            $(elem).addClass('placemarkCrossImagePointed');\r\n\r\n          },\r\n\r\n          mouseLeave: function() {\r\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\r\n            $(elem).removeClass('placemarkCrossImagePointed');\r\n            $(elem).addClass('placemarkCrossImage');\r\n          }\r\n        }\r\n      );\r\n\r\n      var MyIconShape = {\r\n        type: 'Rectangle',\r\n        coordinates: [[71, 0], [96, 25]]\r\n      };\r\n\r\n      this.heightPlacemark.options.set('iconLayout', MyIconLayout);\r\n      this.heightPlacemark.options.set('iconShape', MyIconShape);\r\n\r\n      if (this.vertexIsOnMap) {\r\n        map.geoObjects.add(this.image);\r\n        map.geoObjects.add(this.heightPlacemark);\r\n      }\r\n    }\r\n\r\n\r\n    setCircleImage() {\r\n      this.imageIsTriangle = false;\r\n      var map = this.map;\r\n\r\n      if (this.vertexIsOnMap) {\r\n        map.geoObjects.remove(this.image);\r\n        map.geoObjects.remove(this.heightPlacemark);\r\n      }\r\n\r\n      var point = this.getCoordinates();\r\n      this.image = new ymaps.Circle(\r\n          [point, this.circleImageRadius * this.scale], {}, {\r\n            fillColor: this.color,\r\n            strokeColor: this.strokeColor,\r\n            strokeWidth: 2,\r\n            zIndex: this.imageZIndex\r\n          });\r\n\r\n      // Set Placemark without Closing Cross\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(\r\n        '<div class=\"px-2 py-1 bg-info text-center rounded border d-inline-block\"' +\r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' +\r\n          '$[properties.iconContent]' +\r\n        '</div>'\r\n      );\r\n\r\n      this.heightPlacemark.options.set('iconLayout', MyIconLayout);\r\n      this.heightPlacemark.options.set('iconShape', null);\r\n\r\n      if (this.vertexIsOnMap) {\r\n        map.geoObjects.add(this.image);\r\n        map.geoObjects.add(this.heightPlacemark);\r\n      }\r\n    }\r\n\r\n\r\n    addToMap() {\r\n      if (this.image != null) {\r\n        if (!this.vertexIsOnMap) {\r\n          this.map.geoObjects.add(this.image);\r\n        }\r\n        super.addToMap();\r\n      } else {\r\n        console.warn('The image was not initialized yet!');\r\n      }\r\n    }\r\n\r\n\r\n    removeFromMap() {\r\n      if (this.vertexIsOnMap) {\r\n        this.map.geoObjects.remove(this.image);\r\n      }\r\n      super.removeFromMap();\r\n    }\r\n\r\n\r\n    /**\r\n     * Process both click and dblclick on this vertex.\r\n     * Single clicking is for showing/hiding Placemark.\r\n     * Double clicking is for vertex removing.\r\n     */\r\n    processVertexClick() {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {\r\n          if (this.clickNumber == 1) {  // Single Click (show/hide Placemark)\r\n            if (this.nextVertex != null) {\r\n              this.switchPlacemarkIsVisible();\r\n            }\r\n            this.clickNumber = 0;\r\n          } else {  // Double Click (remove Vertex)\r\n            this.path.removeVertex(this);\r\n            this.clickNumber = 0;\r\n          }\r\n        }.bind(this), 200);\r\n      }\r\n    }\r\n\r\n    setColor(color) {\r\n      this.color = color;\r\n      if (this.image != null) {\r\n        this.image.options.set('fillColor', color);\r\n      } else {\r\n        console.warn('The image was not initialized yet!');\r\n      }\r\n    }\r\n\r\n\r\n    setStrokeColor(color) {\r\n      this.strokeColor = color;\r\n      if (this.image != null) {\r\n        this.image.options.set('strokeColor', color);\r\n      } else {\r\n        console.warn('The image was not initialized yet!');\r\n      }\r\n    }\r\n\r\n\r\n    setHeight(height) {\r\n      this.height = height;\r\n\r\n      if (typeof(height) == 'number') {\r\n        this.printPlacemarkAndHint(Math.floor(height) + '&nbsp;м');\r\n\r\n        // Blue color.\r\n        this.setColor('#0000FF');\r\n        if (this.path.baseVertex == this) {\r\n          // Yellow color.\r\n          this.setStrokeColor('#FFFF00');\r\n        } else {\r\n          this.setStrokeColor('#0000FF');\r\n        }\r\n      } else {\r\n        this.printPlacemarkAndHint('&#x26D4;');\r\n        // Red color.\r\n        this.setColor('#FF0000');\r\n        this.setStrokeColor('#FF0000');\r\n      }\r\n    }\r\n  }\r\n\r\n  provide(Vertex);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Vertex.js?");

/***/ }),

/***/ "./src/scripts/Wind.js":
/*!*****************************!*\
  !*** ./src/scripts/Wind.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Wind', [\r\n  'WindVertex'\r\n],\r\nfunction(provide, WindVertex) {\r\n\r\n  /**\r\n   * Wind at particular height.\r\n   */\r\n  class Wind {\r\n    /**\r\n     * Wind at special height.\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     * @param {number} angle - Angle between current wind and West wind; in degrees.\r\n     * @param {(number | null)} height - In meters; height must be >= 0.\r\n     */\r\n    constructor(value, angle, height, map) {\r\n      this.value = value;\r\n      this.setAngle(angle);\r\n\r\n      this.prevWind = null;\r\n      this.nextWind = null;\r\n\r\n      this.vertex = new WindVertex(map, height);\r\n      this.setHeight(height);\r\n    }\r\n\r\n\r\n    setNextWind(wind) {\r\n      this.nextWind = wind;\r\n      if (wind != null) {\r\n        wind.prevWind = this;\r\n      }\r\n    }\r\n\r\n    setPrevWind(wind) {\r\n      this.prevWind = wind;\r\n      if (wind != null) {\r\n        wind.nextWind = this;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     */\r\n    setValue(value) {\r\n      this.value = value;\r\n    }\r\n\r\n    /**\r\n     * angle will be reduced to interval (-180, 180] degrees.\r\n     * @param {number} angle\r\n     */\r\n    setAngle(angle) {\r\n      angle = Math.floor(angle);\r\n\r\n      if (angle != -180) {  // we want to differ -180 degree and 180 degree at wind menu scale\r\n        if (angle >= 0) {\r\n          angle = angle % 360;\r\n        } else {\r\n          // negative angle case\r\n          angle = angle * (-1);\r\n          angle = angle % 360;\r\n          angle = 360 - angle;\r\n        }\r\n\r\n        if (angle > 180) {\r\n          angle -= 360;\r\n        }\r\n      }\r\n      this.angle = angle;\r\n    }\r\n\r\n    /**\r\n     * Set this.height and print it to Arrow Output Icon.\r\n     * @param {(number | null)} height - In meters; height must be >= 0.\r\n     */\r\n    setHeight(height) {\r\n      this.height = height;\r\n      this.vertex.printPlacemarkAndHint(Math.floor(height));\r\n    }\r\n\r\n    getAngle() {\r\n      return(this.angle);\r\n    }\r\n\r\n    getValue() {\r\n      return(this.value);\r\n    }\r\n\r\n    getHeight() {\r\n      return(this.height);\r\n    }\r\n\r\n    toString() {\r\n      var str = (this.height == 0) ? 'Поверхностный ветер: ' : ('h=' + this.height + 'м');\r\n      str += (this.value + ' м/с, ' + this.getDirection());\r\n      return str;\r\n    }\r\n\r\n    /**\r\n     * Calculate wind coordinates in cartesian coordinate system.\r\n     * @return {number[]} [vx, vy] - coordinates, in m/sec.\r\n     */\r\n    getXY () {\r\n      var radiandirection = this.angle * ((2*Math.PI)/360);\r\n      var vx = this.value * Math.cos(radiandirection);\r\n      var vy = this.value * Math.sin(radiandirection);\r\n      return [vx, vy];\r\n    }\r\n\r\n    /**\r\n     * Get name of wind direction (E, EN, N, NW, W, WS, S, SE)\r\n     */\r\n    getDirection() {\r\n      var angleSwitch = Math.floor((this.angle + 180 + 22)/45);\r\n      var direction;\r\n\r\n      switch(angleSwitch) {\r\n        case 0: direction = \"В\"; break;\r\n        case 1: direction = \"СВ\"; break;\r\n        case 2: direction = \"С\"; break;\r\n        case 3: direction = \"СЗ\"; break;\r\n        case 4: direction = \"З\"; break;\r\n        case 5: direction = \"ЮЗ\"; break;\r\n        case 6: direction = \"Ю\"; break;\r\n        case 7: direction = \"ЮВ\"; break;\r\n        case 8: direction = \"В\"; break;\r\n      }\r\n\r\n      return(direction);\r\n    }\r\n  }\r\n\r\n  provide(Wind);\r\n});\r\n\n\n//# sourceURL=webpack:///./src/scripts/Wind.js?");

/***/ }),

/***/ "./src/scripts/WindList.js":
/*!*********************************!*\
  !*** ./src/scripts/WindList.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindList', ['Wind'],\r\nfunction(provide, Wind) {\r\n\r\n  /**\r\n   * List of winds at different heights;\r\n   * always contains wind at height = 0m (surface wind);\r\n   * that surface wind is always first and cannot be removed.\r\n   * All winds must have number height.\r\n   * List will be sorted for height (from bottom to top);\r\n   * all winds should have different heights.\r\n   */\r\n  class WindList {\r\n    constructor(map) {\r\n      this.map = map;\r\n\r\n      // Surface wind: 5 m/sec, West\r\n      var angle = 0;\r\n      this.firstWind = new Wind(5, angle, 0, map);\r\n      this.firstWind.vertex.addToMap();\r\n      map.windOutput.print(this.firstWind.toString());\r\n      map.arrow.rotate(angle);\r\n\r\n      this.lastWind = this.firstWind;\r\n      this.numberOfWinds = 1;\r\n\r\n      this.calculator = null;\r\n    }\r\n\r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        wind.vertex.chuteImage.setCalculator(calculator);\r\n        wind = wind.nextWind;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Add wind to the List and sort List.\r\n     * Note: wind.height must be a number.\r\n     * @param {Wind} wind\r\n     */\r\n    addWind(wind) {\r\n      wind.vertex.addToMap();\r\n      this.lastWind.setNextWind(wind);\r\n      this.lastWind = wind;\r\n      this.numberOfWinds++;\r\n      wind.vertex.chuteImage.setCalculator(this.calculator);\r\n      this.sortList();\r\n    }\r\n\r\n\r\n    /**\r\n     * Remove wind from WindList.\r\n     * Note: you cannot remove firstWind by construction.\r\n     * @param {Wind} wind - It is supposed that wind belongs to WindList.\r\n     */\r\n    removeWind(wind) {\r\n      // First wind, that is, surface wind, cannot be removed\r\n      if (wind == this.firstWind) {\r\n        console.warn(\"This wind was not removed, because it was firstWind.\");\r\n        return;\r\n      }\r\n\r\n      if (wind.vertex.vertexIsOnMap) {\r\n        wind.vertex.removeFromMap();\r\n      }\r\n\r\n      wind.prevWind.setNextWind(wind.nextWind);\r\n      if (wind == this.lastWind) {\r\n        this.lastWind = this.lastWind.prevWind;\r\n      }\r\n      this.numberOfWinds--;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check if this list has a wind with given height.\r\n     * @param {number} height\r\n     */\r\n    heightIsInList(height) {\r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        if (wind.getHeight() == height) return true;\r\n        wind = wind.nextWind;\r\n      }\r\n      return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Bubble sort (it is practical for small list)\r\n     */\r\n    sortList() {\r\n      while(true) {\r\n        var wind = this.firstWind;\r\n        var swapped = false;\r\n\r\n        while(wind != this.lastWind) {\r\n          if (wind.height > wind.nextWind.height) {\r\n            this.swapWindAndNextWind(wind);\r\n            swapped = true;\r\n          } else {\r\n            wind = wind.nextWind;\r\n          }\r\n        }\r\n        if (!swapped) break;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Print List in console (for development needs)\r\n     */\r\n    printList() {\r\n      console.log('\\n\\n\\n');\r\n      var wind = this.firstWind;\r\n      var i=0;\r\n      while(wind != null) {\r\n        console.log('wind #' + i + ':');\r\n        console.log(wind);\r\n        i++;\r\n        wind = wind.nextWind;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Swap wind and wind.nextWind.\r\n     */\r\n    swapWindAndNextWind(wind) {\r\n      var nextWind = wind.nextWind;\r\n      if (nextWind == null) return;\r\n\r\n      nextWind.setPrevWind(wind.prevWind);\r\n      var nextWindNextWind = nextWind.nextWind;\r\n      nextWind.setNextWind(wind);\r\n      wind.setNextWind(nextWindNextWind);\r\n\r\n      if (this.firstWind == wind) {\r\n        this.firstWind = nextWind;\r\n      }\r\n      if (this.lastWind == nextWind) {\r\n        this.lastWind = wind;\r\n      }\r\n    }\r\n\r\n\r\n    hide() {\r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        wind.vertex.hide();\r\n        wind = wind.nextWind;\r\n      }\r\n    }\r\n  }\r\n\r\n  provide(WindList);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindList.js?");

/***/ }),

/***/ "./src/scripts/WindPointsList.js":
/*!***************************************!*\
  !*** ./src/scripts/WindPointsList.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindPointsList', [],\r\nfunction(provide) {\r\n\r\n  class WindPointsList {\r\n    constructor(point) {\r\n      this.firstPoint = point;\r\n      this.firstPoint.nextPoint = null;\r\n      this.length = 1;\r\n      this.currentPoint = point;\r\n    }  \r\n\r\n    addPoint(point) {\r\n      this.currentPoint.nextPoint = point;\r\n      this.currentPoint = point;\r\n      this.length++;\r\n    }    \r\n  }      \r\n  provide(WindPointsList);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindPointsList.js?");

/***/ }),

/***/ "./src/scripts/WindVertex.js":
/*!***********************************!*\
  !*** ./src/scripts/WindVertex.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindVertex', [\r\n  'Circle',\r\n  'templateLayoutFactory',\r\n  'PreVertex',\r\n],\r\nfunction(provide, Circle, templateLayoutFactory, PreVertex) {\r\n  /**\r\n   * WindVertex extends PrevVertex:\r\n   * we add Vertex Image (Circle) and special layout for Vertex Placemark.\r\n   */\r\n  class WindVertex extends PreVertex {\r\n    /**\r\n     * @param {AppMap} map\r\n     */\r\n    constructor(map, height) {\r\n      var scale = 2**(16 - map.getZoom());\r\n      super(map, scale);\r\n\r\n      this.map = map;\r\n      this.height = height;\r\n      this.scale = scale;\r\n\r\n      this.setScale = this.setScale.bind(this);\r\n      this.map.events.add('boundschange', this.setScale);\r\n\r\n      this.imageRadius = 4;\r\n\r\n      this.image = new ymaps.Circle(\r\n          [null, this.imageRadius * this.scale], {}, {\r\n            fillColor: '#0000FF',  // Blue color\r\n            strokeColor: '#00FF00',  // Green color\r\n            strokeWidth: 2,\r\n            zIndex: 6\r\n          });\r\n\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(\r\n        '<div class=\"px-2 py-1 bg-success text-center rounded border d-inline-block\"' +\r\n            'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' +\r\n          '$[properties.iconContent]' +\r\n        '</div>');\r\n\r\n      this.heightPlacemark.options.set('iconLayout', MyIconLayout);\r\n      //this.heightPlacemark.options.set('zIndex', 7);\r\n\r\n      this.prevVertex = null;\r\n      this.nextVertex = null;\r\n      this.edge = null;\r\n\r\n      this.eventCircle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.switchPlacemarkIsVisible();\r\n      }.bind(this));\r\n    }\r\n\r\n\r\n    setCoordinates(point) {\r\n      super.setCoordinates(point);\r\n      this.image.geometry.setCoordinates(point);\r\n    }\r\n\r\n    /**\r\n     * Hiding Vertex.\r\n     */\r\n    hide() {\r\n      super.hide();\r\n      this.image.geometry.setCoordinates(null);\r\n      //this.setCoordinates(null);\r\n      //this.chuteImage.setCoordinates(null);\r\n    }\r\n\r\n\r\n    addToMap() {\r\n      if (!this.vertexIsOnMap) {\r\n        this.map.geoObjects.add(this.image);\r\n      }\r\n      super.addToMap();\r\n    }\r\n\r\n    removeFromMap() {\r\n      if (this.vertexIsOnMap) {\r\n        this.map.geoObjects.remove(this.image);\r\n      }\r\n      super.removeFromMap();\r\n    }\r\n\r\n    setScale() {\r\n      var scale = 2**(16 - this.map.getZoom());\r\n      super.setScale(scale);\r\n      this.scale = scale;\r\n      this.image.geometry.setRadius(this.imageRadius * this.scale);\r\n    }\r\n\r\n\r\n    setColor(color) {\r\n      this.image.options.set('fillColor', color);\r\n    }\r\n\r\n\r\n    setStrokeColor(color) {\r\n      this.image.options.set('strokeColor', color);\r\n    }\r\n\r\n\r\n    printPlacemarkAndHint(str) {\r\n      super.printPlacemarkAndHint(str + '&nbsp;м');\r\n    }\r\n  }\r\n\r\n  provide(WindVertex);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindVertex.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Program calculate heights of Glider (Chute) for\r\n * Vertices of the Path. Path is a set of Vertices and Edges.\r\n * You can input Path by clicking on the Yandex Map.\r\n */\r\nymaps.ready(init);\r\nfunction init() {\r\n  ymaps.modules.require([\r\n    'AppMap',\r\n    'WindList',\r\n    'Chute',\r\n    'Path',\r\n    'Calculator',\r\n    'DialogWindows',\r\n  ]).spread(function (\r\n    AppMap,\r\n    WindList,\r\n    Chute,\r\n    Path,\r\n    Calculator,\r\n    DialogWindows\r\n  ) {\r\n    // Yandex map\r\n    var map = new AppMap();\r\n\r\n    // Chute velocity = (10, 5) m/s\r\n    var chute = new Chute(10, 5);\r\n\r\n    // Winds at several heights\r\n    var windList = new WindList(map);\r\n\r\n    // List of Vertices and Edges\r\n    var path = new Path(map);\r\n\r\n    // Calculator will make all computations\r\n    var calculator = new Calculator(path, chute, windList);\r\n    path.setCalculator(calculator);\r\n    windList.setCalculator(calculator);\r\n\r\n    // Click on the map will add vertice to the end of the Path,\r\n    // double click on the map will add vertice to the beginning of the Path.\r\n    var clickNumber = 0;\r\n    map.events.add('click', function(e) {\r\n      var point = e.get('coords');\r\n      clickNumber++;\r\n      if (clickNumber == 1) {\r\n        setTimeout(function() {\r\n          if (clickNumber == 1) {  // Single Click\r\n            // We add vertex to the end of the Path\r\n            path.addVertex(point, true);\r\n          } else {  // Double Click\r\n            // We add new vertex to the beginning of the Path\r\n            path.addVertex(point, false);\r\n          }\r\n          clickNumber = 0;\r\n        }, 200);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Menu initialization\r\n     */\r\n    DialogWindows.initMenu(map, chute, windList, path, calculator);\r\n  });\r\n}\n\n//# sourceURL=webpack:///./src/scripts/index.js?");

/***/ }),

/***/ 0:
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/scripts/AppMap.js ./src/scripts/Arrow.js ./src/scripts/Calculator.js ./src/scripts/Chute.js ./src/scripts/ChuteImage.js ./src/scripts/Constant.js ./src/scripts/DialogWindows.js ./src/scripts/Edge.js ./src/scripts/index.js ./src/scripts/MenuButton.js ./src/scripts/OutputElement.js ./src/scripts/Path.js ./src/scripts/PreVertex.js ./src/scripts/TriangleVertexImage.js ./src/scripts/VectorMath.js ./src/scripts/Vertex.js ./src/scripts/Wind.js ./src/scripts/WindList.js ./src/scripts/WindPointsList.js ./src/scripts/WindVertex.js ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/scripts/AppMap.js */\"./src/scripts/AppMap.js\");\n__webpack_require__(/*! ./src/scripts/Arrow.js */\"./src/scripts/Arrow.js\");\n__webpack_require__(/*! ./src/scripts/Calculator.js */\"./src/scripts/Calculator.js\");\n__webpack_require__(/*! ./src/scripts/Chute.js */\"./src/scripts/Chute.js\");\n__webpack_require__(/*! ./src/scripts/ChuteImage.js */\"./src/scripts/ChuteImage.js\");\n__webpack_require__(/*! ./src/scripts/Constant.js */\"./src/scripts/Constant.js\");\n__webpack_require__(/*! ./src/scripts/DialogWindows.js */\"./src/scripts/DialogWindows.js\");\n__webpack_require__(/*! ./src/scripts/Edge.js */\"./src/scripts/Edge.js\");\n__webpack_require__(/*! ./src/scripts/index.js */\"./src/scripts/index.js\");\n__webpack_require__(/*! ./src/scripts/MenuButton.js */\"./src/scripts/MenuButton.js\");\n__webpack_require__(/*! ./src/scripts/OutputElement.js */\"./src/scripts/OutputElement.js\");\n__webpack_require__(/*! ./src/scripts/Path.js */\"./src/scripts/Path.js\");\n__webpack_require__(/*! ./src/scripts/PreVertex.js */\"./src/scripts/PreVertex.js\");\n__webpack_require__(/*! ./src/scripts/TriangleVertexImage.js */\"./src/scripts/TriangleVertexImage.js\");\n__webpack_require__(/*! ./src/scripts/VectorMath.js */\"./src/scripts/VectorMath.js\");\n__webpack_require__(/*! ./src/scripts/Vertex.js */\"./src/scripts/Vertex.js\");\n__webpack_require__(/*! ./src/scripts/Wind.js */\"./src/scripts/Wind.js\");\n__webpack_require__(/*! ./src/scripts/WindList.js */\"./src/scripts/WindList.js\");\n__webpack_require__(/*! ./src/scripts/WindPointsList.js */\"./src/scripts/WindPointsList.js\");\nmodule.exports = __webpack_require__(/*! ./src/scripts/WindVertex.js */\"./src/scripts/WindVertex.js\");\n\n\n//# sourceURL=webpack:///multi_./src/scripts/AppMap.js_./src/scripts/Arrow.js_./src/scripts/Calculator.js_./src/scripts/Chute.js_./src/scripts/ChuteImage.js_./src/scripts/Constant.js_./src/scripts/DialogWindows.js_./src/scripts/Edge.js_./src/scripts/index.js_./src/scripts/MenuButton.js_./src/scripts/OutputElement.js_./src/scripts/Path.js_./src/scripts/PreVertex.js_./src/scripts/TriangleVertexImage.js_./src/scripts/VectorMath.js_./src/scripts/Vertex.js_./src/scripts/Wind.js_./src/scripts/WindList.js_./src/scripts/WindPointsList.js_./src/scripts/WindVertex.js?");

/***/ })

/******/ });