/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/AppMap.js":
/*!*******************************!*\
  !*** ./src/scripts/AppMap.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('AppMap', [\r\n  'Map', \r\n  'control.ZoomControl', \r\n  'Constant', \r\n  'MenuButton',\r\n  'OutputElement',\r\n  'Arrow'  \r\n],\r\nfunction(provide, Map, ZoomControl, Constant, MenuButton, OutputElement, Arrow) {\r\n  /**\r\n   * @extends Map\r\n   */\r\n  class AppMap extends Map {\r\n\r\n    constructor() {\r\n\r\n      // Array of Dropzones and their coordinates.\r\n      var dz = [\r\n        {name: \"Коломна\", mapCenter: [55.091289443603706, 38.917269584802675]}, \r\n        {name: \"Пущино\", mapCenter: [54.78929269708931,37.64268598670033]}, \r\n        {name: \"Ватулино\", mapCenter: [55.663193308717396,36.14121807608322]}\r\n      ];    \r\n        \r\n      super(\"map\", {\r\n        center: dz[0].mapCenter,    \r\n        zoom: Constant.defaultZoom\r\n      }, {\r\n        suppressMapOpenBlock: true  // remove button 'open in yandex maps'\r\n      });\r\n      \r\n      this.dz = dz; \r\n \r\n      // view from space  \r\n      this.setType(\"yandex#satellite\");    \r\n      this.cursors.push('arrow');  \r\n      this.controls.remove('trafficControl');  \r\n      this.controls.remove('zoomControl');\r\n      var zoomControl = new ZoomControl({options: { \r\n        position: { right: 10, top: 105 }, \r\n        size: 'small'\r\n      }}); \r\n      this.controls.add(zoomControl);\r\n      this.controls.remove('geolocationControl');\r\n      this.controls.remove('fullscreenControl');   \r\n       \r\n      this.searchControl = this.controls.get('searchControl');\r\n      this.searchControl.options.set('size', 'small');\r\n      this.searchControl.options.set('noPlacemark', true);\r\n      this.searchControl.options.set('noSelect', true);\r\n\r\n      // Settings menu (ymaps.Button)\r\n      var settingsButton = new MenuButton(\"Настройки\", \"images/icon_menu.svg\", \r\n        \"#settingsMenu\", \"#settingsMenuDarkScreen\");\r\n      this.controls.add(settingsButton, {position: {top: 45, left: 10}});\r\n\r\n      // Output for Surface wind parameters (ymaps.Button)\r\n      this.windOutput = new OutputElement();      \r\n      this.controls.add(this.windOutput, {position: {bottom: 30, left: 10}});\r\n\r\n      // Wind arrow (Windsock)\r\n      this.arrow = new Arrow(this.getCenter());\r\n      this.geoObjects.add(this.arrow);\r\n\r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.preventDefault();  \r\n      }); \r\n\r\n      //this.menu = null;       \r\n    }\r\n    \r\n    /**\r\n     * Processing of yandex.maps search\r\n     */   /*\r\n    setSearchProcessor(calculator) {\r\n\r\n      this.calculator = calculator;    \r\n      this.path = calculator.path;\r\n      this.windList = calculator.windList;\r\n      \r\n      this.defaultZoom = Constant.defaultZoom;\r\n      \r\n      this.searchControl.events.add('resultshow', function(e) {\r\n                \r\n        this.path.clear(); \r\n        this.setZoom(this.defaultZoom);        \r\n        //this.windList.shiftList(this.getCenter());\r\n        this.map.arrow.setCoordinates(this.map.getCenter());  \r\n        \r\n        var index = e.get('index');    \r\n        var geoObjectsArray = this.searchControl.getResultsArray();\r\n        var resultName = geoObjectsArray[index].properties.get('name');\r\n\r\n        var newDz = {\r\n          name: resultName, \r\n          mapCenter: this.getCenter()\r\n        };    \r\n        this.dz.push(newDz);    \r\n        $(\"#dz\").append(\"<option>\" + newDz.name + \"</option>\");    \r\n        $(\"#dz\").children()[this.dz.length - 1].selected = true;    \r\n      }.bind(this));      \r\n    }  */\r\n        \r\n  } \r\n  provide(AppMap);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/AppMap.js?");

/***/ }),

/***/ "./src/scripts/Arrow.js":
/*!******************************!*\
  !*** ./src/scripts/Arrow.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Arrow', [\r\n  'Placemark',\r\n  'templateLayoutFactory', \r\n  'Constant'  \r\n],\r\nfunction(provide, Placemark, templateLayoutFactory, Constant) {\r\n  \r\n  /**\r\n   * Wind Arrow (Yandex Maps API Placemark). \r\n   * You can: rotate it, change its size and coordinates.\r\n   */\r\n  class Arrow extends Placemark {\r\n\r\n    constructor(coordinates = null) {      \r\n\r\n      var arrowStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var arrowStartRadius = Constant.isMobile ? arrowStartSize : arrowStartSize/2; \r\n      \r\n      super([], {\r\n          arrowClass: 'arrow',  \r\n          rotation: 0,           \r\n          size: arrowStartSize\r\n        }, {\r\n          draggable: true,\r\n          iconLayout: templateLayoutFactory.createClass(\r\n              '<div class=\"$[properties.arrowClass]\" style=\"transform: rotate($[properties.rotation]deg);' + \r\n              'width: $[properties.size]px; height: $[properties.size]px;\"/>'\r\n            ), \r\n          iconShape: {\r\n            type: 'Circle',\r\n            coordinates: [arrowStartSize/2, arrowStartSize/2],\r\n            radius: arrowStartRadius\r\n          }          \r\n        }\r\n      );\r\n\r\n      this.arrowStartSize = arrowStartSize;\r\n      this.arrowStartRadius = arrowStartRadius;   \r\n\r\n      if (coordinates != null) {\r\n        this.setCoordinates(coordinates);\r\n      }\r\n      \r\n      this.boundChange = this.boundChange.bind(this);\r\n       \r\n    }\r\n    \r\n    setCoordinates(coordinates) {\r\n      this.geometry.setCoordinates(coordinates);   \r\n    }\r\n\r\n    \r\n   /**\r\n    * Rotate arrow\r\n    */\r\n    rotate(angle) {\r\n      this.properties.set('rotation', (-1)*angle);      \r\n    }\r\n\r\n    \r\n    /**\r\n     * Arrow can have different size for different Zoom.\r\n     */\r\n    changeSize(newZoom) {\r\n      var size = (2**(newZoom - Constant.defaultZoom))*(this.arrowStartSize);\r\n      \r\n      var shape = \r\n        {\r\n          type: 'Circle',\r\n          coordinates: [size/2, size/2],\r\n          radius: (2**(newZoom - Constant.defaultZoom))*(this.arrowStartRadius)\r\n        };\r\n      \r\n      this.options.set('iconShape', shape);      \r\n      this.properties.set('size', size);\r\n      // properties.set call rebuild of Placemark, \r\n      // so, properties.set should stay after options.set      \r\n    }\r\n\r\n    \r\n    /**\r\n     * If Yandex Maps Zoom is changed we will call this.changeSize() function.\r\n     * @param {Event} e - Yandex Maps 'boundschange' event.     \r\n     */\r\n    boundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        this.changeSize(newZoom);\r\n      }\r\n    }        \r\n  }\r\n\r\n  provide(Arrow);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/Arrow.js?");

/***/ }),

/***/ "./src/scripts/Calculator.js":
/*!***********************************!*\
  !*** ./src/scripts/Calculator.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Calculator', [\r\n  'VectorMath', \r\n  'Constant'\r\n],\r\nfunction(provide, VectorMath, Constant) {\r\n  /**\r\n   * This class calculates: \r\n   * a) heights at all vertices of the Path \r\n   * (it will be kept in vertex.height varialables where vertex belongs \r\n   * to Path), \r\n   * b) points on the Path where wind changes (it will be kept in \r\n   * wind.vertex varialables where wind belongs to WindList). \r\n   */\r\n  class Calculator {\r\n    /**\r\n     * @param {Path} path - list of vertices and edges of Chute Path.\r\n     * @param {Chute} chute - Chute velocity.     \r\n     * @param {WindList} windList  \r\n     */\r\n    constructor(path, chute, windList) {          \r\n      this.path = path;\r\n      this.chute = chute;\r\n      this.windList = windList;      \r\n    }\r\n    \r\n\r\n    /**\r\n     * Main calculation function. \r\n     */\r\n    calculateHeight(fromBaseToLast = null) {\r\n      if (this.path.length == 0) {\r\n        console.warn(\"Cannot calculate: Path is empty\");\r\n        return;\r\n      }  \r\n\r\n      //console.log(\"Calculated\");\r\n    \r\n      switch(fromBaseToLast) {\r\n        case true: \r\n          this.calculateHeightForward();\r\n          break;\r\n\r\n        case false:\r\n          this.calculateHeightBack();\r\n          break;\r\n\r\n        case null:\r\n          this.calculateHeightForward();\r\n          this.calculateHeightBack();      \r\n      }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Case: calculation from Base Vertex to Last Vertex.\r\n     */     \r\n    calculateHeightForward() {                                     \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n          \r\n      var vertexA = path.baseVertex; \r\n      var pointA = vertexA.getCoordinates();\r\n\r\n      // true iff firstWindPoint will be on the Path after calculation.  \r\n      var firstWindHeightIsReached = false;\r\n      var wind = windList.lastWind;\r\n      \r\n      // Skip to wind corresponding to base vertex      \r\n      while(wind.getHeight() >= vertexA.height) {        \r\n        if (wind.getHeight() == vertexA.height) {\r\n          wind.setVertexCoordinates(pointA);  \r\n        } else {\r\n          //wind.setVertexCoordinates(null);\r\n        }\r\n\r\n        if (wind == windList.firstWind) break;        \r\n        wind = wind.prevWind;\r\n      }\r\n\r\n      // If there is nothing to calculate in forward direction, \r\n      // we should remove nearby wind vertex and return.\r\n      if (path.baseVertex.nextVertex == null) {\r\n        while(wind != null) {\r\n         wind.setVertexCoordinates(null);\r\n         wind = wind.prevWind;\r\n        } \r\n        return;\r\n      }    \r\n                \r\n      var vertexB = vertexA.nextVertex;               \r\n      // Later, pointA can be any point of edge, \r\n      // pointB always will be vertex, \r\n      // pointA and pointB belong to the one edge \r\n      var pointB = vertexB.getCoordinates();      \r\n      var pointAHeight = vertexA.height;\r\n\r\n      var edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n      \r\n      chute.angleArray = [];    \r\n\r\n      while(true) {                \r\n        // edgeChuteVelocity is velocity along edge [pointA, pointB] at pointA.\r\n        // 'wind' is a wind in pointA. \r\n        // Our aim is to calculate height in pointB.       \r\n        var calcResults = \r\n            this.calculateChuteVelocity(\r\n                pointA, pointB, chute, wind, edgeChuteDirection); \r\n                             \r\n        var edgeChuteVelocity = calcResults.chuteEdgeVelocity;  \r\n        var chutePolarAngle = calcResults.chutePolarAngle;\r\n        var chuteCanFlyAlongLine = calcResults.chuteCanFlyAlongLine;\r\n\r\n        //chute.angleArray.push(velocityAngle);\r\n\r\n        if (!chuteCanFlyAlongLine) break;\r\n        if (edgeChuteVelocity < 0) break;\r\n\r\n        // Case: chute is hanging above pointA\r\n        // This is top boundary of previous wind        \r\n        if (edgeChuteVelocity == 0) {\r\n          if (wind != windList.firstWind) {\r\n            pointAHeight = wind.getHeight();\r\n            wind.setVertexCoordinates(pointA); \r\n            vertexA = wind.vertex;\r\n            vertexA.setChuteImageCoordinates(null);            \r\n            wind = wind.prevWind;            \r\n            continue;\r\n          } else break;          \r\n        }\r\n                                       \r\n        if (edgeChuteVelocity > 0) {\r\n\r\n          /* \r\n          vertexA.windPointsArray.push({\r\n            point: pointA, \r\n            velocityAngle: velocityAngle\r\n          });     */     \r\n\r\n\r\n          var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n          var t1 = dist / edgeChuteVelocity;\r\n          \r\n          if (wind != windList.firstWind) {          \r\n            var t2 = (pointAHeight - wind.getHeight()) / chute.verticalVel;                        \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, chute will reach (vertex) pointB            \r\n              vertexB.setHeight(pointAHeight - t1 * this.chute.verticalVel);\r\n              // Blue color.\r\n              vertexB.prevEdge.setColor('#0000FF');\r\n                     \r\n              if (t2 == t1) {\r\n                wind.setVertexCoordinates(pointB);\r\n                wind = wind.prevWind;                \r\n              } \r\n\r\n              vertexA.setChuteImageCoordinates(\r\n                  [(pointA[0] + pointB[0])/2, (pointA[1] + pointB[1])/2], \r\n                  chutePolarAngle); \r\n\r\n\r\n              vertexA = vertexB;\r\n              vertexB = vertexB.nextVertex;\r\n              if (vertexB == null) break;\r\n              //if (vertexB == path.lastVertex) break;\r\n              \r\n              pointA = vertexA.getCoordinates();\r\n              pointB = vertexB.getCoordinates(); \r\n              edgeChuteDirection = vertexA.nextEdge.getChuteDirection();              \r\n              pointAHeight = vertexA.height;                \r\n              continue;              \r\n            } else {              \r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n              \r\n              var pointC = pointA;\r\n\r\n              pointA = \r\n                  VectorMath.findIntermediatePoint(\r\n                      pointA, pointB, (t2 * edgeChuteVelocity)/dist);\r\n              \r\n              // pointAHeight = wind.getHeight();\r\n              pointAHeight -= t2 * this.chute.verticalVel;\r\n\r\n              vertexA.setChuteImageCoordinates(\r\n                  [(pointA[0] + pointC[0])/2, (pointA[1] + pointC[1])/2], \r\n                  chutePolarAngle); \r\n\r\n              wind.setVertexCoordinates(pointA);     \r\n\r\n              vertexA = wind.vertex;        \r\n              \r\n              // wind.vertex.prevVertex.setChuteCoordinates();\r\n\r\n              wind = wind.prevWind;              \r\n              continue;\r\n            }\r\n          } else {\r\n            // case: wind = windList.firstWind                        \r\n            if (t1 > Constant.maxFlightTime) break;\r\n                   \r\n            vertexB.setHeight(pointAHeight - t1 * this.chute.verticalVel);\r\n            // Blue color. \r\n            vertexB.prevEdge.setColor('#0000FF');\r\n                                    \r\n            if (vertexB.height == 0) {\r\n              wind.setVertexCoordinates(pointB);\r\n              firstWindHeightIsReached = true;              \r\n            }\r\n                             \r\n            if ((pointAHeight > 0) && (vertexB.height < 0)) {                   \r\n              var pointC = \r\n                  VectorMath.findIntermediatePoint(\r\n                      pointA, pointB,  pointAHeight/(pointAHeight - vertexB.height));\r\n              wind.setVertexCoordinates(pointC);\r\n              firstWindHeightIsReached = true;                      \r\n            }                 \r\n            \r\n            vertexA = vertexB;\r\n            vertexB = vertexB.nextVertex;\r\n            if (vertexB == null) break;\r\n            //if (vertexB == path.lastVertex) break;\r\n                        \r\n            pointA = vertexA.getCoordinates();\r\n            pointB = vertexB.getCoordinates();\r\n            edgeChuteDirection = vertexA.nextEdge.getChuteDirection();            \r\n            pointAHeight = vertexA.height;              \r\n            continue;                  \r\n          }          \r\n        }               \r\n      }\r\n\r\n      while(vertexB != null) {\r\n        vertexB.setHeight(null);\r\n        // Red color.\r\n        vertexB.prevEdge.setColor('#FF0000');\r\n        vertexB = vertexB.nextVertex;\r\n      };\r\n      \r\n      // Remove last wind points that shouldn't be on the map. \r\n      if (!firstWindHeightIsReached) {  \r\n        while(wind != null) {\r\n          wind.setVertexCoordinates(null);\r\n          wind = wind.prevWind;\r\n        }\r\n      } \r\n    }\r\n    \r\n\r\n    /**\r\n     * Case: calculation from Base Vertex to First Vertex.\r\n     */    \r\n    calculateHeightBack() {    \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n                    \r\n      var vertexB = path.baseVertex;       \r\n      var pointB = vertexB.getCoordinates();\r\n\r\n      // true iff lastWindPoint will be on the Path after calculation.  \r\n      var lastWindPointIsShown = false;\r\n      \r\n      var wind = windList.firstWind;      \r\n      if (wind.getHeight() < vertexB.height) {\r\n        // that is, 0 < vertexB.height            \r\n        while(true) {\r\n          //wind.setVertexCoordinates(null);\r\n                    \r\n          if (wind.nextWind == null) break;          \r\n          //if (wind.nextWind.getHeight() == null) break;\r\n          \r\n          if (wind.nextWind.getHeight() > vertexB.height) break;\r\n          \r\n          if (wind.nextWind.getHeight() == vertexB.height) {\r\n            wind = wind.nextWind;\r\n            wind.setVertexCoordinates(pointB);\r\n            break;\r\n          }    \r\n          wind = wind.nextWind;          \r\n        }   \r\n      }  \r\n\r\n      if (path.baseVertex.prevVertex == null) {\r\n        while(wind.nextWind != null) {\r\n          wind.nextWind.setVertexCoordinates(null);\r\n          wind = wind.nextWind;\r\n        }\r\n        return;\r\n      } \r\n\r\n      var vertexA = vertexB.prevVertex;      \r\n      // pointA will always be vertex, \r\n      // pointB can be vertex or point on the edge      \r\n      var pointA = vertexA.getCoordinates();     \r\n      var pointBHeight = vertexB.height;\r\n\r\n      var edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n            \r\n      while(true) {         \r\n        // Note: here pointA is only for setting direction; \r\n        // if there will be changing wind on the edge, \r\n        // the chute will fly with following velocity only after \r\n        // last changing (in the direction, determined by \r\n        // vector pointApointB)        \r\n        var edgeChuteVelocity = \r\n            this.calculateChuteVelocity(\r\n                pointA, pointB, chute, \r\n                wind, edgeChuteDirection).chuteEdgeVelocity;\r\n        \r\n        // In this case it is impossible to flight this edge        \r\n        if (edgeChuteVelocity < 0) break;\r\n\r\n        // Case: chute is hanging above pointB.          \r\n        // This is bottom boundary of current wind        \r\n        if (edgeChuteVelocity == 0) {          \r\n          if (wind == windList.lastWind) break;                                      \r\n          wind = wind.nextWind;          \r\n          pointBHeight = wind.getHeight();                                      \r\n          wind.setVertexCoordinates(pointB);      \r\n          continue;                       \r\n        }\r\n                             \r\n        if (edgeChuteVelocity > 0) {          \r\n          if (wind != windList.lastWind) {            \r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n            var t1 = dist / edgeChuteVelocity;                         \r\n            var t2 = \r\n              (wind.nextWind.getHeight() - pointBHeight) / chute.verticalVel;\r\n          \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, pointB is reachable from pointA  \r\n            \r\n              //if (t1 > Constant.maxFlightTime) break;\r\n              \r\n              vertexA.setHeight(pointBHeight + t1 * this.chute.verticalVel);\r\n              // Blue color. \r\n              vertexA.nextEdge.setColor('#0000FF');\r\n              \r\n              if (wind == windList.firstWind && \r\n                  pointBHeight < 0 && \r\n                  vertexA.height > 0) {\r\n                var pointC = \r\n                    VectorMath.findIntermediatePoint(\r\n                        pointA, pointB,  \r\n                        vertexA.height/(vertexA.height - pointBHeight)); \r\n\r\n                wind.setVertexCoordinates(pointC);  \r\n              }               \r\n              \r\n              vertexB = vertexA;\r\n              vertexA = vertexA.prevVertex;\r\n              if (vertexA == null) break;\r\n              //if (vertexA == path.firstVertex) break;\r\n                            \r\n              pointA = vertexA.getCoordinates();\r\n              pointB = vertexB.getCoordinates();\r\n              pointBHeight = vertexB.height;\r\n              \r\n              edgeChuteDirection = vertexA.nextEdge.getChuteDirection();                                                               \r\n              continue;  \r\n            } else { \r\n              // Case: with current wind, pointB is NOT reachable from pointA\r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n                           \r\n              pointB = \r\n                  VectorMath.findIntermediatePoint(\r\n                      pointB, pointA, (t2 * edgeChuteVelocity)/dist); \r\n             \r\n              pointBHeight += t2 * this.chute.verticalVel;\r\n                                                                      \r\n              wind = wind.nextWind;\r\n              wind.setVertexCoordinates(pointB);              \r\n              continue;\r\n            }\r\n          } else {  \r\n            // case: wind == windList.lastWind            \r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n            var t1 = dist / edgeChuteVelocity;            \r\n            if (t1 > Constant.maxFlightTime) break;\r\n                                    \r\n            vertexA.setHeight(pointBHeight + (t1 * this.chute.verticalVel));\r\n            // Blue color.\r\n            vertexA.nextEdge.setColor('#0000FF');\r\n            //vertexA.height = pointBHeight + (t1 * this.chute.verticalVel);\r\n\r\n            if (\r\n                wind == windList.firstWind && \r\n                (pointBHeight < 0) && \r\n                (vertexA.height > 0)) {\r\n              var pointC = \r\n                  VectorMath.findIntermediatePoint(\r\n                      pointA, pointB,  \r\n                      vertexA.height/(vertexA.height - pointBHeight));\r\n\r\n              wind.setVertexCoordinates(pointC);            \r\n            } \r\n               \r\n            vertexB = vertexA;\r\n            vertexA = vertexA.prevVertex;\r\n            if (vertexA == null) break;\r\n            //if (vertexA == path.firstVertex) break;\r\n                    \r\n            pointA = vertexA.getCoordinates();\r\n            pointB = vertexB.getCoordinates(); \r\n            pointBHeight = vertexB.height;            \r\n            edgeChuteDirection = vertexA.nextEdge.getChuteDirection();            \r\n            continue;                     \r\n          }\r\n        }                                \r\n      }\r\n\r\n      while(vertexA != null) {\r\n        vertexA.setHeight(null);\r\n        // Red color.\r\n        vertexA.nextEdge.setColor('#FF0000');\r\n        vertexA = vertexA.prevVertex;\r\n      }    \r\n\r\n      wind = wind.nextWind; \r\n      while(wind != null) {\r\n        wind.setVertexCoordinates(null);\r\n        wind = wind.nextWind;\r\n      }\r\n    }\r\n\r\n    \r\n    /** \r\n     * Calculate Polar angle of Chute Velocity and \r\n     * Absolute (relatively to Earth) Chute Velocity along Line Segment \r\n     * (we suppose that chute is flying along this line segment).\r\n     * @param {number[]} pointA - Yandex Maps Coordinates: (latitude, longitude).\r\n     * @param {number[]} pointB - Yandex Maps Coordinates: (latitude, longitude). \r\n     * @param {Chute} chute \r\n     * @param {Wind} wind\r\n     * @param [boolean] edgeChuteDirection - Skydiver can fly with his face directed \r\n     * with or against edge.\r\n     * @returns {Object} Object       \r\n     * @returns {number} Object.chuteEdgeVelocity - Absolute Chute Velocity along \r\n     * line segment [pointA, pointB]; in m/sec; \r\n     * Cases: chuteEdgeVelocity < 0 - In this case it is impossible to fly this segment;\r\n     * chuteEdgeVelocity == 0 - hanging above pointA;    \r\n     * chuteEdgeVelocity > 0 - chute will fly from pointA to pointB.\r\n     * @returns {number} Object.chutePolarAngle - Polar angle of Chute Velocity. \r\n     * @returns {boolean} Object.chuteCanFlyAlongLine - Is true iff chute velotity \r\n     * is greater or equal to wind velocity projection to direction that is \r\n     * perpendicula to the Line Segment. \r\n     */    \r\n    calculateChuteVelocity(\r\n      pointA, pointB, chute, wind, edgeChuteDirection = true) {\r\n          \r\n      // Let's find right orthonormal basis (e, f), first vector of which (e)\r\n      // has the same direction with vector [pointA, pointB].      \r\n      // Yandex Maps Coordinates: (latitude, longitude)\r\n      // Latitude is increasing from bottom to top (-90deg, 90deg)\r\n      // Longitude is increasing from West to East (-180deg, 180deg)\r\n            \r\n      function sign(a) {\r\n        if (a>0) return 1;\r\n        if (a==0) return 0;\r\n        return -1;\r\n      }      \r\n      \r\n      var sx = sign(pointB[1] - pointA[1]);\r\n      var sy = sign(pointB[0] - pointA[0]);       \r\n    \r\n      var pointC = [pointA[0], pointB[1]];\r\n      \r\n      // now (ex, ey) are coordinates of vector e in standart orthonormal basis:\r\n      // x has direction from left to right, \r\n      // y has direction from bottom to top, \r\n      // scale: 1 meter\r\n      var ex = sx * ymaps.coordSystem.geo.getDistance(pointC, pointA);\r\n      var ey = sy * ymaps.coordSystem.geo.getDistance(pointC, pointB);\r\n\r\n      // Polar angle of vector (pointA, pointB)  \r\n      var angle1 =  VectorMath.getPolarFromCartesian([ex, ey]).angle;\r\n                \r\n      var d = Math.sqrt(ex*ex + ey*ey);\r\n      ex = ex / d;\r\n      ey = ey / d;\r\n      \r\n      var fx = -ey;\r\n      var fy = ex;\r\n      \r\n      // Let's find coordinates (we, wf) of vector 'wind' in basis (e, f).\r\n      // (e, f) is orthogonal basis, so we = (wind, e), wf = (wind, f).\r\n      var [wx, wy] = wind.getXY();\r\n   \r\n      var we = wx * ex + wy * ey; \r\n      var wf = wx * fx + wy * fy;     \r\n       \r\n      // Let's find coordinates (ce, cf) of chute velocity \r\n      // in basis (e, f):     \r\n      var cf = (-1)*wf;\r\n      \r\n      // it is impossible to fly this segment\r\n      if (chute.horizontalVel < Math.abs(cf)) {\r\n        let chutePolarAngle = \r\n            (VectorMath.getPolarFromCartesian(\r\n                 [0, sign(cf)*chute.horizontalVel])).angle;\r\n        chutePolarAngle += angle1;  \r\n        return({          \r\n          chuteEdgeVelocity: 0,\r\n          //chuteEdgeVelocity: -1, \r\n          chutePolarAngle: chutePolarAngle, \r\n          chuteCanFlyAlongLine: false\r\n        });\r\n      }  \r\n  \r\n      var directionSign = edgeChuteDirection ? 1 : -1;   \r\n      var ce = directionSign * Math.sqrt(chute.horizontalVel**2 - cf**2);\r\n      \r\n      // Polar angle of Chute velocity relative to bases {e, f}\r\n      var chutePolarAngle = (VectorMath.getPolarFromCartesian([ce, cf])).angle;\r\n      // Polar angle of Chute velocity \r\n      chutePolarAngle += angle1;\r\n\r\n      //console.log('polarCoordinates: ');\r\n      //console.log(polarCoordinates);\r\n\r\n      var chuteEdgeVelocity = ce + we;\r\n      return({\r\n        chuteEdgeVelocity: chuteEdgeVelocity,\r\n        chutePolarAngle: chutePolarAngle, \r\n        chuteCanFlyAlongLine: true\r\n      });       \r\n    }   \r\n  }\r\n      \r\n  provide(Calculator);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Calculator.js?");

/***/ }),

/***/ "./src/scripts/Chute.js":
/*!******************************!*\
  !*** ./src/scripts/Chute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Chute', [],\r\nfunction(provide) {\r\n\r\n  class Chute {\r\n    /**\r\n     * @param {number} horizontalVel - Horizontal chute velocity, in m/sec.\r\n     * @param {number} verticalVel - Vertical chute velocity, in m/sec.     \r\n     */\r\n    constructor(horizontalVel, verticalVel) {\r\n      this.horizontalVel = horizontalVel; \r\n      this.verticalVel = verticalVel;\r\n    }   \r\n  }\r\n      \r\n  provide(Chute);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Chute.js?");

/***/ }),

/***/ "./src/scripts/ChuteImage.js":
/*!***********************************!*\
  !*** ./src/scripts/ChuteImage.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('ChuteImage', [\r\n  'Placemark',\r\n  'templateLayoutFactory', \r\n  'Constant'  \r\n],\r\nfunction(provide, Placemark, templateLayoutFactory, Constant) {\r\n  \r\n  /**\r\n   * Chute Image (Yandex Maps API Placemark). \r\n   * You can: rotate it and change its coordinates.\r\n   */\r\n  class ChuteImage extends Placemark {\r\n\r\n    /**\r\n     * @param {null | Number[]} coordinates \r\n     */\r\n    constructor(coordinates = null) {      \r\n      var chuteStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var chuteStartRadius = Constant.isMobile ? chuteStartSize : chuteStartSize/2; \r\n      \r\n      super(coordinates, {\r\n            chuteClass: 'chute',  \r\n            rotation: 0,           \r\n            size: chuteStartSize\r\n          }, {\r\n            iconLayout: templateLayoutFactory.createClass(\r\n                '<div class=\"$[properties.chuteClass]\" style=\"transform: rotate($[properties.rotation]deg);' + \r\n                'width: $[properties.size]px; height: $[properties.size]px;\"/>'), \r\n            iconOffset: [-12, -12],\r\n            iconShape: {\r\n              type: 'Circle',\r\n              coordinates: [chuteStartSize/2, chuteStartSize/2],\r\n              radius: chuteStartRadius\r\n            }          \r\n          });  \r\n    }\r\n    \r\n    /**\r\n     * @param {null | Number[]} coordinates \r\n     */\r\n    setCoordinates(coordinates) {\r\n      this.geometry.setCoordinates(coordinates); \r\n    }\r\n\r\n   /**\r\n    * Rotate arrow\r\n    * @param {Number} angle\r\n    */\r\n    rotate(angle) {\r\n      this.properties.set('rotation', (-1)*angle);      \r\n    }\r\n  }\r\n  provide(ChuteImage);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/ChuteImage.js?");

/***/ }),

/***/ "./src/scripts/Constant.js":
/*!*********************************!*\
  !*** ./src/scripts/Constant.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Constant */\r\nymaps.modules.define('Constant', [],\r\nfunction(provide) {\r\n\r\n// Determine mobile or desktop case.\r\nvar isMobile = false;\r\nif(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\r\n  isMobile = true;\r\n}\r\n  /** These varialables are constants for app */\r\n  var Constant = {\r\n    defaultBaseHeight: 300, \r\n    defaultStartHeight: 300,\r\n    defaultFinalHeight: 0,\r\n    defaultZoom: 16,\r\n    defaultCalculationDirection: true,  \r\n    // We will not consider cases when horizontal velocity\r\n    // is more than maxChuteHorizontalVelocity\r\n    maxChuteHorizontalVelocity: 100,  // wingsuit\r\n    maxChuteVerticalVelocity: 50,  // free fall\r\n    maxHeight: 15000,\r\n    maxWindValue: 40,\r\n    // If we will fly more than maxFlightTime, then\r\n    // it is impossible to fly this path\r\n    maxFlightTime: 3600, // 1 hour\r\n    isMobile: isMobile\r\n  }\r\n\r\n  provide(Constant);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Constant.js?");

/***/ }),

/***/ "./src/scripts/DialogWindows.js":
/*!**************************************!*\
  !*** ./src/scripts/DialogWindows.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('DialogWindows', ['Constant', 'Wind'],\r\nfunction(provide, Constant, Wind) {\r\n\r\n  var DialogWindows = {};\r\n  /**\r\n   * @param {AppMap} map\r\n   * @param {Chute} chute\r\n   * @param {WindList} windList\r\n   * @param {Path} path\r\n   * @param {Calculator} calculator \r\n   */\r\n  DialogWindows.initMenu = function(map, chute, windList, path, calculator) {\r\n    \r\n    // First active link in Menu will be Dz link  \r\n    this.prevLinkId = 'helpLink';\r\n\r\n    initMenuWindow();\r\n    initDzWindow();\r\n    initChuteWindow();\r\n    initHeightWindow();\r\n    initWindWindow();\r\n    \r\n    /**\r\n     * Settings Menu initialization\r\n     */\r\n    function initMenuWindow() {\r\n\r\n      $('#helpLinkContent').css('display', 'block');\r\n      $('#helpLink').addClass('active');\r\n\r\n      $('nav a').on('click', function(e) {\r\n        e.preventDefault();\r\n\r\n        let currentLinkId = $(this).attr('id');\r\n\r\n        $('#' + DialogWindows.prevLinkId + \"Content\").css('display', 'none');\r\n        $('#' + currentLinkId + \"Content\").css('display', 'block');\r\n\r\n        $('#' + DialogWindows.prevLinkId).removeClass('active');\r\n        $(this).addClass('active');\r\n            \r\n        DialogWindows.prevLinkId = currentLinkId;\r\n      })\r\n\r\n      // Close Settings Menu after clicking Cross or Dark screen\r\n      $(\"#settingsMenuHeaderRectangle, #settingsMenuDarkScreenClickable\").click(function() {\r\n        \r\n        $(\"#settingsMenuDarkScreen\").css(\"left\", \"-100%\");\r\n\r\n        if (window.matchMedia(\"(min-width: 768px)\").matches) {\r\n          $(\"#settingsMenu\").css(\"left\", \"-50%\");  \r\n        } else {\r\n          $(\"#settingsMenu\").css(\"left\", \"-100%\");              \r\n        }\r\n      });   \r\n\r\n      // Loose focus after pressing Enter on input field.\r\n      $(\"input\").keypress(function(e) {\r\n        if (e.keyCode === 13 || e.keyCode === 9) {  // Enter keycode\r\n          $(\"input\").blur();     // Forced loose of focus\r\n        }    \r\n      });\r\n    }\r\n\r\n  \r\n    /**\r\n     * Dz Window initialization\r\n     */\r\n    function initDzWindow() {\r\n      // Set default options: dz array\r\n      for(var i=0; i<map.dz.length; i++) {\r\n        $(\"#dz\").append(\"<option>\" + map.dz[i].name + \"</option>\");    \r\n      }\r\n      \r\n      $(\"#dz\").on(\"change\", function() {\r\n        var mapCenter = map.dz[this.selectedIndex].mapCenter;      \r\n        map.setCenter(mapCenter, Constant.defaultZoom);\r\n        map.arrow.setCoordinates(mapCenter);                \r\n        // path.clear() will print results too\r\n        path.clear();\r\n      });\r\n    }\r\n\r\n\r\n    /** \r\n     * Chute Window initialization.\r\n     */\r\n    function initChuteWindow() {\r\n      $(\"#chutehorvel\").val(chute.horizontalVel);\r\n      $(\"#chutevervel\").val(chute.verticalVel);\r\n    \r\n      $(\"#chutehorvel\").on(\"change\", function () {\r\n        var chutehorvel = Number.parseFloat($(\"#chutehorvel\").val());\r\n        if ((chutehorvel>=0) && (chutehorvel<=Constant.maxChuteHorizontalVelocity)) {\r\n          chute.horizontalVel = chutehorvel;\r\n          $(\"#chutehorvel\").val(chutehorvel);\r\n        } else {\r\n          if (Number.isNaN(chutehorvel)) {\r\n            alert('Недопустимое значение!');\r\n          } else {\r\n            if (chutehorvel < 0) {\r\n              alert('Скорость должна быть неотрицательной!');\r\n            } else {\r\n              alert('Скорость должна быть не больше ' + Constant.maxChuteHorizontalVelocity + 'м/с !');\r\n            }\r\n          }\r\n          $(\"#chutehorvel\").val(chute.horizontalVel);\r\n          return;           \r\n        }\r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();           \r\n        }        \r\n      });  \r\n\r\n      $(\"#chutevervel\").on(\"change\", function () {                           \r\n        var chutevervel = Number.parseFloat($(\"#chutevervel\").val());\r\n        if (( chutevervel>=0) && (chutevervel<=Constant.maxChuteVerticalVelocity)) {\r\n          chute.verticalVel = chutevervel;\r\n          $(\"#chutevervel\").val(chutevervel);    \r\n        } else {\r\n          if (Number.isNaN(chutevervel)) {\r\n            alert('Недопустимое значение!');\r\n          } else {\r\n            if (chutevervel < 0) {\r\n              alert('Скорость должна быть неотрицательной!');\r\n            } else {\r\n              alert('Скорость должна быть не больше ' + Constant.maxChuteVerticalVelocity + 'м/с !');\r\n            }\r\n          }\r\n          $(\"#chutevervel\").val(chute.verticalVel);\r\n          return;           \r\n        }\r\n                \r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();           \r\n        }\r\n      });\r\n    }    \r\n\r\n    \r\n    /**\r\n     * Height Window initialization.\r\n     */\r\n    function initHeightWindow() {\r\n      $(\"#baseVertexHeight\").val(Math.floor(Constant.defaultBaseHeight));\r\n\r\n      $(\"#baseVertexHeight\").on(\"change\", function() {            \r\n        var n = Number.parseFloat($(\"#baseVertexHeight\").val());\r\n        \r\n        if ((n >= 0) && (n <= Constant.maxHeight)) { \r\n            path.setBaseVertexHeight(n);\r\n            $(\"#baseVertexHeight\").val(Math.floor(n));                  \r\n        } else {\r\n\r\n          if (Number.isNaN(n)) {\r\n            alert('Недопустимое значение!');\r\n          } else {\r\n            if (n < 0) {\r\n              alert('Высота в базовой точке должна быть неотрицательной!');\r\n            } else {\r\n              alert('Высота в базовой точке должна быть не больше ' + Constant.maxHeight + 'м !');  \r\n            }\r\n          }  \r\n          \r\n          if (path.length > 0) {\r\n            $(\"#baseVertexHeight\").val(Math.floor(path.baseVertex.height));\r\n          } else {\r\n            $(\"#baseVertexHeight\").val(Math.floor(path.baseVertexHeight));  \r\n          } \r\n        } \r\n      });\r\n    }\r\n\r\n\r\n\r\n    /** \r\n     * Wind Window initialization.\r\n     */    \r\n    function initWindWindow() {\r\n\r\n      $(\"#windValueInput\").prop(\"max\", \"\" + Constant.maxWindValue);\r\n      // Draw scales for Range Input Sliders in WindInput window    \r\n      drawWindScales();\r\n\r\n\r\n      drawWindScreen();\r\n\r\n      /**\r\n       * Draw WindScreen window in Wind Menu\r\n       */\r\n      function drawWindScreen() {\r\n        $(\"#windInput\").addClass(\"displayNone\");\r\n        $(\"#windScreen\").removeClass(\"displayNone\");\r\n\r\n        var windTable = document.getElementById(\"windTable\"); \r\n        windTable.innerHTML = '';   \r\n        var funcArray = [];\r\n        var row = []; \r\n        var wind = windList.firstWind;\r\n        for(var i=0; i < windList.numberOfWinds; i++) {\r\n          row[i] = windTable.insertRow(i);\r\n          funcArray[i] = createRowClickListener(wind);\r\n          row[i].addEventListener(\"click\", funcArray[i]);\r\n          var cell1 = row[i].insertCell(0);\r\n          var cell2 = row[i].insertCell(1);\r\n          var cell3 = row[i].insertCell(2);\r\n          cell1.innerHTML = (wind.height == null)? \"?\" : wind.height + \" м\";      \r\n          cell2.innerHTML = '<div class=\\\"arrow\\\"></div>';\r\n          cell2.firstChild.style.transform = \"rotate(\" + (-1)*wind.getAngle() + \"deg)\";\r\n          cell3.innerHTML = wind.value + \" м/c\";\r\n          wind = wind.nextWind;\r\n        } \r\n\r\n        // Button Add Wind in WindScreen window\r\n        $(\"#addWind\").click(function() {        \r\n          var w = new Wind(5, 0, null, map);\r\n\r\n          $(\"#addWind\").off('click');\r\n          for(var i=0; i < row.length; i++) {\r\n            row[i].removeEventListener('click', funcArray[i]);\r\n          }\r\n          drawWindInput(w);\r\n        });      \r\n\r\n        function createRowClickListener(w) {\r\n          return (function(e) {\r\n            $(\"#windScreen\").addClass(\"displayNone\");\r\n            windList.currentWind = w;\r\n            $(\"#windInput\").removeClass(\"displayNone\");\r\n\r\n            $(\"#addWind\").off('click');\r\n            for(var i=0; i < row.length; i++) {\r\n              row[i].removeEventListener('click', funcArray[i]);\r\n            }\r\n\r\n            drawWindInput(w);    \r\n          }); \r\n        }\r\n      }\r\n      \r\n      /**\r\n       * Draw WindInput window in Wind Menu\r\n       */\r\n      function drawWindInput(wind) {\r\n        $(\"#windScreen\").addClass(\"displayNone\");\r\n        $(\"#windInput\").removeClass(\"displayNone\");\r\n\r\n        if (wind == windList.firstWind) {\r\n          $(\"#windHeightInput\").prop(\"disabled\", true);\r\n          $(\"#removeWind\").addClass(\"displayNone\");       \r\n        } else {\r\n          $(\"#windHeightInput\").prop(\"disabled\", false);\r\n          $(\"#removeWind\").removeClass(\"displayNone\");\r\n        }\r\n        $(\"#windHeightInput\").val(wind.getHeight());    \r\n        $(\"#windDirectionInput\").val(wind.getAngle());\r\n        $(\"#windValueInput\").val(wind.getValue());\r\n        var angle = wind.getAngle();\r\n        $(\"#menuArrow\").css(\"transform\", \"rotate(\" + (-1)*angle + \"deg)\");\r\n        $(\"#menuWindValue\").html(wind.getValue() + \" м/с\");      \r\n\r\n\r\n        // Button 'Back to WindScreen' in WindInput window\r\n        $(\"#windInputHeaderArrowRectangle\").click(function() { \r\n          $(\"#windHeightInput\").off(\"change\"); \r\n          $(\"#windDirectionInput\").off('input change');\r\n          $(\"#windValueInput\").off('input change');\r\n          $(\"#removeWind\").off('click');\r\n          $(\"#windInputHeaderArrowRectangle\").off('click');\r\n          drawWindScreen();\r\n        });\r\n\r\n        // Button 'Remove current wind' in WindInput window\r\n        $(\"#removeWind\").click(function() {\r\n          if (wind.getHeight() != null) {\r\n            windList.removeWind(wind);\r\n\r\n            if (path.length > 0) {\r\n              calculator.calculateHeight();\r\n            }\r\n          } \r\n          $(\"#windHeightInput\").off(\"change\"); \r\n          $(\"#windDirectionInput\").off('input change');\r\n          $(\"#windValueInput\").off('input change');\r\n          $(\"#removeWind\").off('click');\r\n          $(\"#windInputHeaderArrowRectangle\").off('click');\r\n          drawWindScreen();\r\n        });\r\n\r\n            \r\n        // Input for WindHeight in WindInput window  \r\n        $(\"#windHeightInput\").on(\"change\", function() {        \r\n          \r\n          var heightString = $(\"#windHeightInput\").val();      \r\n          var height = Number.parseFloat(heightString);\r\n\r\n          if (!Number.isNaN(height)) {\r\n            if (height > 0) {\r\n              if (height <= Constant.maxHeight) {\r\n                if (!windList.heightIsInList(height)) {\r\n                  if (wind.height == null) {\r\n                    wind.setHeight(height);\r\n                    windList.addWind(wind);\r\n                  } else {\r\n                    wind.setHeight(height);\r\n                    windList.sortList();\r\n                  }\r\n\r\n                  if (path.length > 0) {\r\n                    calculator.calculateHeight();       \r\n                  }                       \r\n                } else {\r\n                  alertError('Такая высота уже была!');\r\n                }\r\n              } else {  // height > Constant.maxHeight\r\n                alertError('Высота должны быть не больше ' + Constant.maxHeight + ' м!');\r\n              }\r\n            } else {  // height <= 0\r\n              if (height == 0) {\r\n                alertError('Поверхностный ветер уже задан!');\r\n              } else {  // height < 0              \r\n                alertError('Высота должна быть больше нуля!');\r\n              }             \r\n            }\r\n          } else {\r\n            alertError('Недопустимое значение!');\r\n          }\r\n\r\n          function alertError(str) {\r\n            alert(str);\r\n            $(\"#windHeightInput\").val(Math.floor(wind.height));\r\n          }   \r\n        });\r\n        \r\n                        \r\n        // Range Input Slider for Wind Direction in WindInput window.  \r\n        $(\"#windDirectionInput\").on('input change', function() {\r\n          var angleStr = $(\"#windDirectionInput\").val();          \r\n          var angle = Number.parseInt(angleStr);\r\n          \r\n          wind.setAngle(angle);\r\n          if (wind == windList.firstWind) {\r\n            map.windOutput.print(wind.toString()); \r\n            map.arrow.rotate(angle);\r\n          }\r\n\r\n          $(\"#menuArrow\").css(\"transform\", \"rotate(\" + (-1)*angle + \"deg)\");\r\n\r\n          if ((wind.height != null) && (path.length > 0)) {\r\n            calculator.calculateHeight();         \r\n          }            \r\n        });\r\n\r\n        // Range Input Slider for  Wind Value in WindInput window.   \r\n        $(\"#windValueInput\").on('input change', function() {\r\n          var valueStr = $(\"#windValueInput\").val();\r\n          var value = Number.parseInt(valueStr);\r\n\r\n          wind.setValue(value);\r\n          if (wind == windList.firstWind) {\r\n            map.windOutput.print(wind.toString()); \r\n          } \r\n\r\n          $(\"#menuWindValue\").html(value + \" м/с\");\r\n          \r\n          if ((wind.height != null) && (path.length > 0)) {\r\n            calculator.calculateHeight();         \r\n          }       \r\n        });\r\n      }              \r\n    }\r\n   \r\n    /**\r\n     * Draw scales for Wind Window:\r\n     *   wind direction scale (E, N, W, S, E),\r\n     *   wind velocity scale (0, ..., Constant.maxWindValue m/s)\r\n     */\r\n    function drawWindScales() {\r\n\r\n      // Create legend for direction range input\r\n      var directionPlateSpan = 5;\r\n      var directionPlateNumber = 4*directionPlateSpan + 1;\r\n      var windValuePlateNumber = 0;\r\n      \r\n      for(var i=0; i<directionPlateNumber; i++) {\r\n        var str = \"\";\r\n        switch (i) {\r\n          case 0: \r\n            str = \"В\";\r\n            break;\r\n          case directionPlateSpan: \r\n            str = \"С\";\r\n            break;\r\n          case directionPlateSpan*2: \r\n            str = \"З\";\r\n            break;      \r\n          case directionPlateSpan*3: \r\n            str = \"Ю\";\r\n            break;\r\n          case directionPlateSpan*4: \r\n            str = \"В\";\r\n            break;\r\n          default:\r\n            str = \"&nbsp\";          \r\n        }\r\n        $(\"#windDirectionInputScale\").append(\"<div class='directionPlate'>\" + str + \"</div>\");\r\n    \r\n        var str2;        \r\n        if (i % 5 == 0) {\r\n          str2 = windValuePlateNumber;\r\n          windValuePlateNumber += (Constant.maxWindValue / 4);\r\n        } else {\r\n          str2 = \"&nbsp\";\r\n        }        \r\n        $(\"#windValueInputScale\").append(\"<div class='directionPlate'>\" + str2 + \"</div>\");\r\n       \r\n      }\r\n      $(\".directionPlate\").css({\r\n        \"width\": 100/(directionPlateNumber) + \"%\",\r\n        \"float\": \"left\", \r\n        \"text-align\": \"center\"\r\n      });     \r\n    }     \r\n\r\n  }\r\n\r\n  provide(DialogWindows);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/DialogWindows.js?");

/***/ }),

/***/ "./src/scripts/Edge.js":
/*!*****************************!*\
  !*** ./src/scripts/Edge.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Edge', [\r\n  'Polygon', \r\n  'VectorMath', \r\n  'Arrow', \r\n  'ChuteImage',  \r\n],\r\nfunction(provide, Polygon, VectorMath, Arrow, ChuteImage) {\r\n  /**\r\n   * PathEdge consists of two Rectangles: \r\n   * Image Rectangle and Invisible Event Rectangle.\r\n   * Invisible Event Rectangle is aimed for catching events \r\n   * (we use it to make GUI more friendly for Users in mobile case). \r\n   */\r\n  class Edge {    \r\n    /**\r\n     * @param {Vertex} prevVertex\r\n     * @param {Vertex} nextVertex\r\n     * @param {Path} edgeImageWidthWidth\r\n     * @param {boolean} chuteDirection      \r\n     */\r\n    constructor(prevVertex, nextVertex, path, chuteDirection = true) {\r\n      this.prevVertex = prevVertex;\r\n      this.nextVertex = nextVertex;\r\n      this.path = path; \r\n      // true - if Chute motion and Edge has the same direction\r\n      this.chuteDirection = chuteDirection;\r\n\r\n      this.edgeWidth = path.edgeEventRectangleWidth; // edgeWidth; \r\n      this.edgeImageWidth = this.edgeWidth / 10; // edgeImageWidth;\r\n\r\n      // Edge connects prevVertex, nextVertex, itself.\r\n      prevVertex.nextVertex = nextVertex;\r\n      prevVertex.nextEdge = this;\r\n      nextVertex.prevVertex  = prevVertex;\r\n      nextVertex.prevEdge = this;\r\n      \r\n      var zIndex = 0;\r\n\r\n      // Rectangle vertices will be calculated later\r\n      this.eventRectangle = new Polygon([], {}, {\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: zIndex\r\n      });\r\n\r\n      var color = this.getColor();\r\n      \r\n      this.image = new Polygon([], {}, {\r\n        fillColor: color,\r\n        strokeColor: color, \r\n        zIndex: (zIndex - 1)        \r\n      });\r\n            \r\n      //this.chuteImage = new ChuteImage();\r\n\r\n      this.calculateEdgeRectangles();\r\n            \r\n      this.clickNumber = 0;\r\n\r\n      this.edgeIsOnMap = false;\r\n\r\n      //this.processVertexClick = this.processVertexClick.bind(this);\r\n      \r\n      this.eventRectangle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick(e);\r\n      }.bind(this));      \r\n    }\r\n\r\n    \r\n    scale(scale) {\r\n      this.edgeWidth *= scale;\r\n      this.edgeImageWidth *= scale;\r\n      this.calculateEdgeRectangles();\r\n    }\r\n\r\n    \r\n    addToMap() {\r\n      if (!this.edgeIsOnMap) {\r\n        this.path.map.geoObjects.add(this.eventRectangle);         \r\n        this.path.map.geoObjects.add(this.image);\r\n        //this.path.map.geoObjects.add(this.chuteImage);    \r\n        this.edgeIsOnMap = true;\r\n      }\r\n    }\r\n\r\n    removeFromMap() {\r\n      if (this.edgeIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.eventRectangle);         \r\n        this.path.map.geoObjects.remove(this.image);\r\n        //this.path.map.geoObjects.remove(this.chuteImage);    \r\n        this.edgeIsOnMap = false;\r\n      }\r\n    }\r\n\r\n\r\n    getChuteDirection() {\r\n      return this.chuteDirection;\r\n    }\r\n    \r\n    getColor() {\r\n      var color = this.chuteDirection ? \"#0000FF\" : \"#000050\";\r\n      return color;\r\n    }\r\n\r\n    setColor(color) {\r\n      this.image.options.set('strokeColor', color);\r\n      this.image.options.set('fillColor', color);\r\n    }\r\n\r\n    /**\r\n     * Process both click and dblclick on this edge.\r\n     * Single clicking is for adding new Vertex. \r\n     * Double clicking is for changing chute direction \r\n     * on this edge (skydiver can fly with his face directed \r\n     * with or against edge).\r\n     */       \r\n    processVertexClick(e) {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (this.clickNumber == 1) {  // Single Click (add Vertex)\r\n            this.divideEdge(e);                           \r\n            this.clickNumber = 0;\r\n          } else {   \r\n            if (this.clickNumber == 2) {  // Double Click (change chute direction)\r\n              this.chuteDirection = !this.chuteDirection;        \r\n              let color = this.getColor();              \r\n              this.image.options.set(\"fillColor\", color);\r\n              this.image.options.set(\"strokeColor\", color);                            \r\n              this.clickNumber = 0;\r\n              \r\n              this.path.calculator.calculateHeight();\r\n              this.path.printHeightsAndWindPoints();              \r\n            }             \r\n          }  \r\n        }.bind(this), 200);\r\n      }  \r\n    }    \r\n\r\n      \r\n    /**    \r\n     * Here we calculate projection of point = e.get('coords') to \r\n     * line segment {this.pointA, this.pointB} and then \r\n     * send that projection to path.divideEdge.     \r\n     * @param {Event} e\r\n     */\r\n    divideEdge(e) {\r\n                \r\n      var point = e.get('coords');\r\n      \r\n      var pointA = this.prevVertex.getCoordinates(), \r\n          pointB = this.nextVertex.getCoordinates();\r\n              \r\n      var vector1 = VectorMath.subVectors(point, pointA), \r\n          vector2 = VectorMath.subVectors(pointB, pointA);\r\n      vector2 = VectorMath.normaliseVector(vector2);                \r\n      var c = VectorMath.scalarProduct(vector1, vector2);        \r\n      var vector3 = VectorMath.multVectorConstant(vector2, c);\r\n      \r\n      var point2 = VectorMath.addVectors(pointA, vector3);\r\n                            \r\n      this.path.divideEdge(this, point2);    \r\n    }\r\n        \r\n    /**\r\n     * Run this function when geometric parameters of prevVertex or nextVertex are changed. \r\n     * It will recalculate Edge parameters.\r\n     */\r\n    calculateEdgeRectangles() {\r\n      var pointA = this.prevVertex.getCoordinates();\r\n      var pointB = \r\n          this.nextVertex.isTriangleVertex ?   \r\n              this.nextVertex.image.getEdgePoint() : \r\n              this.nextVertex.getCoordinates();\r\n      \r\n      var vertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeWidth);\r\n\r\n      this.eventRectangle.geometry.setCoordinates([vertices]);        \r\n      \r\n      var imageVertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeImageWidth);\r\n\r\n      this.image.geometry.setCoordinates([imageVertices]);   \r\n      \r\n      /*\r\n      var x = (pointA[0] + pointB[0])/2, \r\n          y = (pointA[1] + pointB[1])/2;\r\n      \r\n      this.chuteImage.setCoordinates([x, y]); */\r\n    }\r\n\r\n              \r\n    /**\r\n     * @param {number} width - Width of Rectangle, in meters. \r\n     */    \r\n    calculateRectangleVertices (pointA, pointB, width) {\r\n                  \r\n      var latitude = pointA[0],\r\n          geodesicVectorAB = VectorMath.subVectors(pointB, pointA);\r\n\r\n      var cartVectorAB = \r\n              VectorMath.toLocalVector(geodesicVectorAB, latitude);         \r\n\r\n      var v = VectorMath.normaliseVector(cartVectorAB);\r\n      \r\n      var w = [(-v[1])*width , v[0]*width];\r\n            \r\n      var wg = VectorMath.toGeodesicVector(w, latitude);\r\n      var wwg = [wg[0]*(-1), wg[1]*(-1)];\r\n      \r\n      var vertices = [];  \r\n      vertices[0] = VectorMath.addVectors(pointA, wg);\r\n      vertices[1] = VectorMath.addVectors(pointB, wg);\r\n      vertices[2] = VectorMath.addVectors(pointB, wwg); \r\n      vertices[3] = VectorMath.addVectors(pointA, wwg);       \r\n                  \r\n      return vertices;  \r\n    }              \r\n  } \r\n  provide(Edge);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Edge.js?");

/***/ }),

/***/ "./src/scripts/MenuButton.js":
/*!***********************************!*\
  !*** ./src/scripts/MenuButton.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('MenuButton', [\r\n  'control.Button'       \r\n],\r\nfunction(provide, Button) {\r\n  /**\r\n   * MenuButton creates Yandex.Maps API Button.\r\n   * If you click this Button, then CSS property \r\n   * 'left' of two DOM elements (Element1 with jQuerySelector1 and \r\n   *  Element2 with jQuerySelector2) will be set to be 0. \r\n   * @extends control.Button\r\n   */\r\n  class MenuButton extends Button {\r\n    /**\r\n     * @param {string} [title] - Button hint.\r\n     * @param {string} [image] - Src for <img> tag of this button.\r\n     * @param {string} [jQuerySelector1] - jQuery selector for Element1. \r\n     * @param {string} [jQuerySelector2] - jQuery selector for Element2. \r\n     * @param {string} [cssclass] - Css for this button.          \r\n     */ \r\n    constructor(\r\n      title, \r\n      image, \r\n      jQuerySelector1,\r\n      jQuerySelector2,\r\n      cssclass='inputControlElement' \r\n    ) {\r\n      super({\r\n        data: {\r\n          title: title,\r\n          image: image, \r\n          cssclass: cssclass        \r\n        },  \r\n        options: {\r\n          layout: ymaps.templateLayoutFactory.createClass(\r\n            \"<div title='{{data.title}}' class='{{data.cssclass}}'>\" + \r\n              \"<img class='iconimage' src='{{data.image}}'>\" +           \r\n            \"</div>\"\r\n          ),\r\n          maxWidth: 300\r\n        }\r\n      });\r\n                      \r\n      // Result of this Button clicking\r\n      this.events.add('click', function() {         \r\n        $(jQuerySelector2).css(\"left\", \"0\");\r\n        $(jQuerySelector1).css(\"left\", \"0\");      \r\n      });    \r\n    }        \r\n  } \r\n  provide(MenuButton);  \r\n});\r\n\n\n//# sourceURL=webpack:///./src/scripts/MenuButton.js?");

/***/ }),

/***/ "./src/scripts/OutputElement.js":
/*!**************************************!*\
  !*** ./src/scripts/OutputElement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('OutputElement', [\r\n  'control.Button', \r\n  'templateLayoutFactory'  \r\n],\r\nfunction(provide, Button, templateLayoutFactory) {\r\n  \r\n  class OutputElement extends Button {\r\n    /**\r\n     * @param {string} content   \r\n     */\r\n    constructor(content='') {\r\n      \r\n      super({\r\n        data: {content: content},  \r\n          \r\n        options: {\r\n          layout: templateLayoutFactory.createClass(\r\n            \"<div class='outputControlElement'>{{data.content}}</div>\"\r\n          ),\r\n         maxWidth: 300 \r\n        }\r\n      });           \r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} str \r\n     */\r\n    print(str) {\r\n      this.data.set('content', str);   \r\n    }\r\n  } \r\n  provide(OutputElement);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/OutputElement.js?");

/***/ }),

/***/ "./src/scripts/Path.js":
/*!*****************************!*\
  !*** ./src/scripts/Path.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Path', [\r\n  'Vertex',\r\n  'Edge',\r\n  'Constant'\r\n],\r\nfunction(\r\n  provide,\r\n  Vertex,\r\n  Edge,\r\n  Constant\r\n) {\r\n  /**\r\n   * List of Vertices and Edges.\r\n   * Image of Last Vertex is Triangle. Images of other Vertices are Circles.\r\n   */\r\n  class Path {\r\n    /**\r\n     * @param {Map} map - link to Yandex map.\r\n     */\r\n    constructor(map) {\r\n      this.map = map;\r\n      this.firstVertex = null;\r\n      this.lastVertex = null;\r\n\r\n      this.baseVertex = null;\r\n      this.baseVertexHeight = Constant.defaultBaseHeight;\r\n\r\n      // number of vertices\r\n      this.length = 0;\r\n\r\n      // Radius of Circle Image of Vertices, in meters\r\n      this.vertexRadius = Constant.isMobile ? 4 : 4;\r\n      // Define size of Triangle Image of Vertices\r\n      this.triangleScale = 1;\r\n      // Radius for Event Circle of Vertices, in meters\r\n      this.vertexEventRadius = \r\n          Constant.isMobile ? 6*this.vertexRadius : 3*this.vertexRadius;\r\n      // Width of Event Rectangle of Edges\r\n      this.edgeEventRectangleWidth = 1;\r\n\r\n      // On the map: line segments should be under vertex images,\r\n      // vertex images should be under vertices\r\n      this.vertexZIndex = 2;\r\n      this.vertexImageZIndex = 1;\r\n      this.edgeZIndex = 0;\r\n      this.edgeImageZIndex = -1;\r\n\r\n      this.calculator = null;\r\n\r\n      this.pathBoundChange = this.pathBoundChange.bind(this);   \r\n      this.map.events.add('boundschange', this.pathBoundChange);\r\n    }\r\n\r\n\r\n    pathBoundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        var scale = (2**(oldZoom - newZoom));\r\n        this.scale(scale);\r\n      }\r\n    }\r\n\r\n    scale(scale) {\r\n      this.vertexRadius *= scale;\r\n      this.vertexEventRadius *= scale;\r\n      this.edgeEventRectangleWidth *= scale;\r\n      this.triangleScale *= scale;\r\n      if (this.length > 0 ) {\r\n        var vertex = this.lastVertex;\r\n        vertex.scale(scale);\r\n        for(var i=1; i < this.length; i++) {\r\n          vertex = vertex.prevVertex;\r\n          vertex.scale(scale);\r\n          vertex.nextEdge.scale(scale);\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n\r\n\r\n    /**\r\n     * Add new Vertex to Path and to Map.\r\n     * Add corresponding Edge to Path and to Map.\r\n     * @param {number[]} point - Yandex.Maps coordinates, point = [x, y].\r\n     * @return {Array} New Last Vertex and new Vast Edge of Path.\r\n     */\r\n    addVertex(point, isAddedtoEnd) {\r\n\r\n      var vertex = new Vertex(point, this.vertexEventRadius, this);\r\n\r\n      var edge = null;\r\n\r\n      if (this.length > 0) {\r\n\r\n        if (isAddedtoEnd) {  \r\n          // We should add vertex to the end of path\r\n\r\n          var lastPoint = this.lastVertex.getCoordinates();\r\n          vertex.setTriangleVertex(lastPoint);\r\n\r\n          edge = new Edge(this.lastVertex, vertex, this);\r\n\r\n          if (this.length > 1) {\r\n            this.lastVertex.setCircleVertex(this.vertexRadius);\r\n            this.lastVertex.prevEdge.calculateEdgeRectangles(); \r\n          }  \r\n\r\n          this.lastVertex = vertex;   \r\n          \r\n          this.lastVertex.setIsBetweenBaseAndLast(true);\r\n        } else {\r\n          // We should add vertex to the beginning of path\r\n\r\n          vertex.setCircleVertex(this.vertexRadius);\r\n\r\n          if (this.length == 1) {\r\n            this.firstVertex.setTriangleVertex(point);\r\n          } \r\n\r\n          edge = new Edge(vertex, this.firstVertex, this);\r\n      \r\n          this.firstVertex = vertex;\r\n\r\n          this.firstVertex.setIsBetweenBaseAndLast(false);\r\n        }\r\n\r\n        vertex.addToMap();\r\n        edge.addToMap();\r\n        this.length++;\r\n\r\n        this.calculator.calculateHeight(isAddedtoEnd);\r\n\r\n      } else {  // this.length == 0;    \r\n        this.firstVertex = vertex;\r\n        this.lastVertex = vertex;\r\n        this.baseVertex = vertex;\r\n        this.firstVertex.setHeight(this.baseVertexHeight);\r\n        vertex.setStrokeColor('#FFFF00');\r\n        vertex.setCircleVertex(this.vertexRadius);\r\n        vertex.isBetweenBaseAndLast = null;\r\n        vertex.printHint(\"h=\" + Math.floor(vertex.height) + \"&nbsp;м\");\r\n        vertex.printPlacemark(Math.floor(vertex.height) + \"&nbsp;м\");\r\n\r\n        vertex.addToMap();\r\n        this.length++;        \r\n      }\r\n\r\n      return([vertex, edge]);\r\n    }\r\n\r\n    /**\r\n     * You shouldn't setBaseVertex to vertex with height == null \r\n     * or height < 0.\r\n     * @param {Vertex} vertex \r\n     */\r\n    setBaseVertex(vertex) {\r\n      this.baseVertex.setStrokeColor(this.baseVertex.color);\r\n      this.baseVertex = vertex;\r\n      // Yellow color.\r\n      this.baseVertex.setStrokeColor('#FFFF00');\r\n      this.setVerticesIsBetweenBaseAndLast();\r\n      $(\"#baseVertexHeight\").val(Math.floor(this.baseVertex.height));\r\n      this.baseVertexHeight = this.baseVertex.height;\r\n      //this.calculator.calculateHeight();\r\n    }\r\n\r\n\r\n    setBaseVertexHeight(height) {\r\n      this.baseVertexHeight = height;\r\n      if (this.length > 0) {\r\n        this.baseVertex.setHeight(height);\r\n        this.calculator.calculateHeight();\r\n      }\r\n    }\r\n\r\n\r\n    setVerticesIsBetweenBaseAndLast() {\r\n      this.baseVertex.isBetweenBaseAndLast = null;\r\n      var v = this.baseVertex;\r\n      while((v = v.prevVertex)!= null) {\r\n        v.isBetweenBaseAndLast = false;\r\n      }\r\n      var v = this.baseVertex;\r\n      while((v = v.nextVertex) != null) { \r\n        v.isBetweenBaseAndLast = true;\r\n      }   \r\n    }\r\n\r\n\r\n    /**\r\n     * Divide Edge by point.\r\n     * Point should be on that Edge.\r\n     * @param {Edge} edge\r\n     * @param {number[]} point - Yandex.maps coordinates.\r\n     * @return {Array} New Vertex and two new Edges.\r\n     */\r\n    divideEdge(edge, point) {\r\n      var prevVertex = edge.prevVertex,\r\n          nextVertex = edge.nextVertex;\r\n          \r\n      var edgeChuteDirection = edge.getChuteDirection();\r\n         \r\n      var vertex = new Vertex(point, this.vertexEventRadius, this);    \r\n      vertex.setCircleVertex(this.vertexRadius);\r\n\r\n      var edge1 = new Edge(prevVertex, vertex, this, edgeChuteDirection);\r\n      var edge2 = new Edge(vertex, nextVertex, this, edgeChuteDirection);\r\n      \r\n      if (vertex.prevVertex.isBetweenBaseAndLast == true || \r\n          vertex.prevVertex.isBetweenBaseAndLast == null) {\r\n        vertex.setIsBetweenBaseAndLast(true);\r\n      } else {\r\n        vertex.setIsBetweenBaseAndLast(false);  \r\n      }  \r\n\r\n      this.length++;\r\n\r\n      edge.removeFromMap();\r\n      vertex.addToMap();\r\n      edge1.addToMap();\r\n      edge2.addToMap();\r\n\r\n      this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\r\n      return([vertex, edge1, edge2]);\r\n    }\r\n\r\n    /**\r\n     * Remove vertex from Path and from map.\r\n     * @param {Vertex} vertex\r\n     * @return {(Edge|null)} Edge between previous and next vertices.\r\n     */\r\n    removeVertex(vertex) {\r\n\r\n      if ((vertex == this.baseVertex) && (this.length > 1)) {\r\n        alert('Вы не можете удалить базовую вершину!');\r\n        return;\r\n      }\r\n\r\n      vertex.removeFromMap();\r\n      if (vertex == this.lastVertex && vertex.prevVertex != null) {\r\n        vertex.prevVertex.setChuteImageCoordinates(null);\r\n      }\r\n\r\n      var prevVertex = vertex.prevVertex;\r\n      var nextVertex = vertex.nextVertex;\r\n\r\n      var edge = null;\r\n\r\n      if (this.length > 1) {\r\n        if ((prevVertex != null) && (nextVertex != null)) {\r\n\r\n          var prevEdge = vertex.prevEdge;\r\n          var nextEdge = vertex.nextEdge;\r\n          \r\n          var edgeChuteDirection = \r\n              prevEdge.getChuteDirection() || nextEdge.getChuteDirection();\r\n\r\n          prevEdge.removeFromMap();\r\n          nextEdge.removeFromMap();\r\n          \r\n          var prevPoint = prevVertex.getCoordinates();\r\n          \r\n          if (nextVertex == this.lastVertex) {\r\n            nextVertex.setTriangleVertex(prevPoint);\r\n          } \r\n\r\n          edge = new Edge(prevVertex, nextVertex, this, edgeChuteDirection);\r\n          edge.addToMap();\r\n\r\n        } else if (nextVertex == null) {  // last vertex case\r\n          var prevEdge = vertex.prevEdge;\r\n\r\n          prevEdge.removeFromMap(); \r\n\r\n          this.lastVertex = prevVertex;\r\n          this.lastVertex.nextVertex = null;\r\n          this.lastVertex.nextEdge = null;\r\n\r\n          if (prevVertex.prevVertex != null) {\r\n            var prevPrevPoint = prevVertex.prevVertex.getCoordinates();\r\n            prevVertex.setTriangleVertex(prevPrevPoint);\r\n            prevVertex.prevEdge.calculateEdgeRectangles();  \r\n          }\r\n        } else {  // first vertex case\r\n          vertex.nextEdge.removeFromMap(); \r\n\r\n          nextVertex.prevVertex = null;\r\n          this.firstVertex = nextVertex;\r\n\r\n          if (this.length == 2) {\r\n            nextVertex.setCircleVertex(this.vertexRadius);\r\n          }\r\n        }\r\n      } else {  // case: only one circle\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.length--;\r\n\r\n      if (this.length > 0) {\r\n        this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\r\n      }\r\n\r\n      return(edge);\r\n    }\r\n\r\n    /**\r\n     * Drag vertex with neibour edges.\r\n     * @param {Vertex} vertex\r\n     */\r\n    dragVertex(vertex) { \r\n      this.calculator.calculateHeight(vertex.isBetweenBaseAndLast);\r\n\r\n      if (vertex.nextEdge != null) {\r\n        vertex.nextEdge.calculateEdgeRectangles();\r\n      }\r\n\r\n      if (vertex.prevEdge != null) {\r\n        vertex.prevEdge.calculateEdgeRectangles();\r\n      }\r\n    }\r\n\r\n\r\n    /** Remove all vetrices and edges from Path and from map. */\r\n    clear() {\r\n      if (this.length > 0 ) {\r\n        var vertex = this.lastVertex;\r\n        vertex.removeFromMap();\r\n\r\n        for(var i=1; i < this.length; i++) {\r\n          vertex = vertex.prevVertex;\r\n          vertex.removeFromMap();\r\n          vertex.nextEdge.removeFromMap();\r\n        }\r\n\r\n        this.length = 0;\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.calculator.windList.removeWindVertices();\r\n    }\r\n\r\n  }\r\n  provide(Path);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Path.js?");

/***/ }),

/***/ "./src/scripts/PreVertex.js":
/*!**********************************!*\
  !*** ./src/scripts/PreVertex.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('PreVertex', [\r\n  'Circle',\r\n  'Placemark',\r\n  'templateLayoutFactory',\r\n  'ChuteImage',\r\n  'Constant'\r\n],\r\nfunction(provide, Circle, Placemark, templateLayoutFactory,\r\n    ChuteImage, Constant) {\r\n  /**\r\n   * 'Abstract' class. You should initialize this.image before\r\n   * using some methods.\r\n   * Vertex consists of: Invisible Event Circle (it is used for catching\r\n   * events for Vertex), Vertex Placemark for Output, Chute Placemark,\r\n   * Link to Vertex Image (you should initialize it later).\r\n   */\r\n  class PreVertex {\r\n    /**\r\n     * @param {AppMap} map - Yandex.Map.\r\n     * @param {null | number[]} coordinates - Yandex.Maps coordinates of center.\r\n     */\r\n    constructor(map, coordinates = null) {\r\n      this.map = map;\r\n\r\n      this.imageRadius = 4;\r\n      this.eventRadius =\r\n          Constant.isMobile ? 6*this.imageRadius : 3*this.imageRadius;\r\n\r\n      // Event Circle (invisible)\r\n      this.eventCircle = new ymaps.Circle(\r\n          [coordinates, this.eventRadius], {}, {\r\n            draggable: true,\r\n            // vertex will be invisible\r\n            fillOpacity: 0,\r\n            strokeOpacity: 0,\r\n            strokeWidth: 0,\r\n            zIndex: 2\r\n          });\r\n\r\n      // Output Placemark\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        coordinates, {iconContent: ''}, {iconOffset: [0, -35], cursor: 'arrow'});\r\n\r\n      // Vertex Image\r\n      this.image = null;\r\n      this.imageZIndex = 1;\r\n      // Blue color\r\n      this.color = '#0000FF';\r\n      this.strokeColor = '#0000FF';\r\n\r\n      // Image of chute which shows chute direction on the this.nextEdge\r\n      this.chuteImage = new ChuteImage();\r\n\r\n      this.placemarkHintContent = null;\r\n      this.placemarkIsVisible = true;\r\n\r\n      this.vertexIsOnMap = false;\r\n\r\n      // remove standart map zoom for double click\r\n      this.eventCircle.events.add('dblclick', function(e) {\r\n        e.stopPropagation();\r\n      });\r\n    }\r\n\r\n\r\n    /**\r\n     * Set the same coordinates for Event Circle and Vertex Placemark.\r\n     * this.image should be added before using this function.\r\n     * @param {null | number[]} point\r\n     */\r\n    setCoordinates(point) {\r\n      this.eventCircle.geometry.setCoordinates(point);\r\n      this.heightPlacemark.geometry.setCoordinates(point);\r\n      this.image.setCoordinates(point);\r\n    }\r\n\r\n    /**\r\n     * this.image should be added before using this function.\r\n     */\r\n    scale(scale) {\r\n      this.eventRadius = this.eventRadius * scale;\r\n      this.eventCircle.geometry.setRadius(this.eventRadius);\r\n\r\n      this.imageRadius = this.imageRadius * scale;\r\n      this.image.scale(scale);\r\n    }\r\n\r\n\r\n    /**\r\n     * this.image should be added before using this function.\r\n     */\r\n    addToMap() {\r\n      if (!this.vertexIsOnMap) {\r\n        this.map.geoObjects.add(this.eventCircle);\r\n        this.map.geoObjects.add(this.heightPlacemark);\r\n        this.map.geoObjects.add(this.image);\r\n        this.map.geoObjects.add(this.chuteImage);\r\n        this.vertexIsOnMap = true;\r\n      } else {\r\n        console.warn('Vertex has already been added to Map!');\r\n      }\r\n    }\r\n\r\n    /**\r\n     * this.image should be added before using this function.\r\n     */\r\n    removeFromMap() {\r\n      if (this.vertexIsOnMap) {\r\n        this.map.geoObjects.remove(this.eventCircle);\r\n        this.map.geoObjects.remove(this.heightPlacemark);\r\n        this.map.geoObjects.add(this.image);\r\n        this.map.geoObjects.add(this.chuteImage);\r\n        this.vertexIsOnMap = false;\r\n      } else {\r\n        console.warn('Vertex has already been removed from Map!');\r\n      }\r\n    }\r\n\r\n\r\n    getCoordinates() {\r\n      return this.eventCircle.geometry.getCoordinates();\r\n    }\r\n\r\n    /**\r\n     * this.image should be added before using this function.\r\n     */\r\n    setColor(color) {\r\n      this.color = color;\r\n      this.image.options.set('fillColor', color);\r\n    }\r\n\r\n    /**\r\n     * this.image should be added before using this function.\r\n     */\r\n    setStrokeColor(color) {\r\n      this.strokeColor = color;\r\n      this.image.options.set('strokeColor', color);\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */\r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set('iconContent', str);\r\n    }\r\n\r\n    printHint(str) {\r\n      this.placemarkHintContent = str;\r\n\r\n      if (!this.placemarkIsVisible) {\r\n        this.eventCircle.properties.set('hintContent', str);\r\n      }\r\n    }\r\n  }\r\n  provide(PreVertex);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/PreVertex.js?");

/***/ }),

/***/ "./src/scripts/TriangleVertexImage.js":
/*!********************************************!*\
  !*** ./src/scripts/TriangleVertexImage.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('TriangleVertexImage', [\r\n  'Polygon', \r\n  'VectorMath'  \r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n \r\n  /** \r\n   * Let point1, point2 - two points with Yandex.maps (geodesic) coordinates. \r\n   * TriangleVertex is Yandex maps triangle, \r\n   * such that vector (point1, point2) and that triangle \r\n   * form arrow (end of path).\r\n   * Size of arrow is about several meters.\r\n   */ \r\n  class TriangleVertexImage extends Polygon {\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates. \r\n     * @param {number} triangleScale - It defines size of Triangle.\r\n     * @param {number} zIndex - z-index of Polygon.     \r\n     */\r\n    constructor(point1, point2, color, strokeColor, triangleScale = 1, zIndex=0) {\r\n      // four square brackets is a must for Polygon constructor, \r\n      // non empty super constructor is a must     \r\n      super([], {}, {\r\n        fillColor: color, \r\n        strokeColor: strokeColor, \r\n        strokeWidth: 2, \r\n        zIndex: zIndex          \r\n      });   \r\n      \r\n      // Three vertices of triangle \r\n      this.triangleVertices = null;\r\n      // Point on triangle side to which edge will be connected\r\n      this.edgePoint = null;\r\n\r\n      this.triangleScale = triangleScale;\r\n      this.point1 = point1;\r\n      this.point2 = point2;\r\n      \r\n      this.setCoordinates(point1, point2);       \r\n    }\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.    \r\n     */    \r\n    setCoordinates (point1, point2) {\r\n      this.point1 = point1;\r\n      this.point2 = point2;  \r\n\r\n      var p = this.calculateVertices(point1, point2);\r\n\r\n      this.triangleVertices = [p[0], p[1], p[2]];\r\n      this.edgePoint = p[3]; \r\n      \r\n      this.geometry.setCoordinates([this.triangleVertices]); \r\n    }\r\n    \r\n    getEdgePoint() {\r\n      return(this.edgePoint);\r\n    }\r\n    \r\n    setScale(scale) {\r\n      this.triangleScale = scale;\r\n      this.setCoordinates(this.point1, this.point2);\r\n    }\r\n\r\n    getScale() {\r\n      return this.triangleScale;\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps point coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps point coordinates.\r\n     * @return {number[][]} points - First three points of this array are \r\n     * the vertices of triangle; last point is a point at the triangle side \r\n     * to which edge will be connected.  \r\n     */     \r\n    calculateVertices (point1, point2) {\r\n                   \r\n      var latitude = point1[0],\r\n          geodesicArrowVector = VectorMath.subVectors(point2, point1),\r\n          localArrowVector = \r\n            VectorMath.toLocalVector(geodesicArrowVector, latitude);         \r\n\r\n      localArrowVector = VectorMath.normaliseVector(localArrowVector);                \r\n      \r\n      // Points coordinates in local cartesian coordinate system.\r\n      // First three point are the vertices of triangle.\r\n      // Last point is a point at the triangle side \r\n      // to which edge will be connected.\r\n      var pointsLocal = [[-2, 0.5], [-2, -0.5], [0, 0], [-2,0]];\r\n      for(var i=0; i<4; i++) {\r\n        for(var j=0; j<2; j++) {\r\n          pointsLocal[i][j] *= this.triangleScale;\r\n        }\r\n      }\r\n      \r\n      var points = [];                 \r\n      for(var i=0; i<pointsLocal.length; i++) {   \r\n        points[i] = VectorMath.rotateVector(pointsLocal[i], localArrowVector);\r\n        points[i] = VectorMath.addVectors(\r\n          point2, \r\n          VectorMath.toGeodesicVector(points[i], latitude)\r\n        );\r\n      }\r\n \r\n      return(points);  \r\n    }        \r\n  }\r\n  \r\n  provide(TriangleVertexImage);      \r\n});\n\n//# sourceURL=webpack:///./src/scripts/TriangleVertexImage.js?");

/***/ }),

/***/ "./src/scripts/VectorMath.js":
/*!***********************************!*\
  !*** ./src/scripts/VectorMath.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('VectorMath', [],\r\nfunction(provide) {\r\n  /** Set of functions for working with Sphere (2 dimensional) vectors. */\r\n  class VectorMath {\r\n       \r\n    /**\r\n     * We consider following local cartesian coordinate system: \r\n     *  axis have the same direction as Latitude-Longtitude, \r\n     *  axis have the same length (with each other), \r\n     *  default scale parameter (0.00008) makes this \r\n     *  coordinate system be of the size we need in our tasks.\r\n     * @param {number[]} geodesicVector - Latitude-Longtitude vector coordinates.\r\n     * @param {number} latitude\r\n     * @param {number} scale - Default value is 0.00008\r\n     * @return {number[]} [vx, vy] - Vector coordinates in cartesian coordinate system.\r\n     */      \r\n    static toLocalVector(geodesicVector, latitude, scale=0.00008) {  \r\n      var vx = geodesicVector[0]/scale;\r\n      var vy = (geodesicVector[1]/scale) * \r\n                Math.cos((Math.PI/180)*latitude);\r\n      return([vx, vy]);\r\n    }\r\n    \r\n    /**\r\n     * Convert Cartesian coordinate to Latitude-Longtitude coordinates.\r\n     * @param {number[]} localVector - Cartesian vector. \r\n     * @param {number} latitude\r\n     * @param {number} scale \r\n     * @return {number[]|0} [vlat, vlon] - [Latitude, Longtitude] or 0 \r\n     *  (if impossible to convert).       \r\n     */\r\n    static toGeodesicVector(localVector, latitude, scale=0.00008) {\r\n      var vlat = localVector[0]*scale;\r\n      var c = Math.cos((Math.PI/180)*latitude);\r\n      if (c == 0) return 0;\r\n      var vlon = (localVector[1]*scale) / c;\r\n      return([vlat, vlon]);\r\n    }\r\n\r\n    static normaliseVector(v) {\r\n      var d = Math.sqrt(v[0]**2 + v[1]**2);\r\n      if (d>0) {\r\n        return ([v[0]/d, v[1]/d]);\r\n      } else {        \r\n        return ([0, 0]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * n = (cos(alpha), sin(alpha)), \r\n     * alpha is angle of rotation\r\n     */\r\n    static rotateVector(v, n) {\r\n      var wx = n[0]*v[0] - n[1]*v[1];\r\n      var wy = n[1]*v[0] + n[0]*v[1];\r\n      return ([wx, wy]);        \r\n    }\r\n\r\n    static addVectors(v1, v2) {\r\n      return([v1[0] + v2[0], v1[1] + v2[1]]);\r\n    } \r\n    \r\n    static subVectors(v1, v2) {\r\n      return([v1[0] - v2[0], v1[1] - v2[1]]);\r\n    }\r\n\r\n    static multVectorConstant(v, a) {\r\n      return([v[0]*a, v[1]*a]);\r\n    }\r\n\r\n    static scalarProduct(v1, v2) {\r\n      return(v1[0]*v2[0] + v1[1]*v2[1]);      \r\n    }\r\n    \r\n    static length(v) {\r\n      return(Math.sqrt(v[0]*v[0] + v[1]*v[1]));\r\n    }\r\n    \r\n    /**\r\n     * pointA + {pointA, pointB} * t\r\n     */       \r\n    static findIntermediatePoint(pointA, pointB, t) {\r\n      var v = this.subVectors(pointB, pointA);      \r\n      var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);      \r\n      v = this.multVectorConstant(v, t);                   \r\n      var point = this.addVectors(pointA, v);\r\n      return(point);  \r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number[]} point - Cartesian coordinates.\r\n     * @returns {Object | null} polarCoordinates - Polar coordinates or null if radius = 0. \r\n     * @returns {number} polarCoordinates.radius\r\n     * @returns {number} polarCoordinates.angle - Here 0 <= angle < 2*PI.\r\n     */\r\n    static getPolarFromCartesian(point) {\r\n      var x = point[0]; \r\n      var y = point[1];\r\n\r\n      var r = Math.sqrt(x*x + y*y);      \r\n      if (r == 0) return {radius: null, angle: null};\r\n        \r\n      var angle = null;\r\n\r\n      if (x > 0) {\r\n        angle = (y >= 0) ? Math.atan(y/x) : (2*Math.PI - Math.atan((-y)/x));\r\n      } else {\r\n        if (x < 0) {\r\n          if (y >= 0) {\r\n            angle = Math.PI - Math.atan(y/(-x));\r\n          } else {\r\n            angle = Math.PI + Math.atan(y/x);\r\n          }\r\n        } else {  // x = 0\r\n          angle = (y > 0) ? Math.PI/2  : Math.PI*(3/2);  \r\n        }\r\n      }  \r\n\r\n      //angle = 360 * (angle / (Math.PI*2));  \r\n      var polarCoordinates = {radius: r, angle: angle};\r\n      return polarCoordinates;\r\n    }\r\n                  \r\n  }      \r\n  provide(VectorMath);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/VectorMath.js?");

/***/ }),

/***/ "./src/scripts/Vertex.js":
/*!*******************************!*\
  !*** ./src/scripts/Vertex.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Vertex', [\r\n  'Circle',\r\n  'Rectangle',\r\n  'TriangleVertexImage', \r\n  'Placemark',   \r\n  'templateLayoutFactory', \r\n  'ChuteImage',\r\n],\r\nfunction(provide, Circle, Rectangle, TriangleVertexImage, Placemark, \r\n    templateLayoutFactory, ChuteImage) {\r\n  /**\r\n   * Vertex of Path. \r\n   * Vertex consists of: Invisible Event Circle (it is used for catching \r\n   * events for Vertex), Vertex Placemark for Output, Vertex Image (Circle or Triangle).\r\n   * Also it contains references to previous and next Vertices. \r\n   */\r\n  class Vertex {    \r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {number} eventRadius - Radius of Event Circle.\r\n     * @param {Path} path - Link to parent Path; we need it because some vertex\r\n     * operations (like clicking on Placemark Cross = Path clear) change the Path.   \r\n     */\r\n    constructor(point, eventRadius, path) {\r\n\r\n      // Event Circle (invisible)\r\n      this.eventCircle = new ymaps.Circle(\r\n        [point, eventRadius], \r\n        {}, \r\n        {\r\n          draggable: true,\r\n          // vertex will be invisible\r\n          fillOpacity: 0,\r\n          strokeOpacity: 0, \r\n          strokeWidth: 0, \r\n          zIndex: 2\r\n        }\r\n      );\r\n\r\n            \r\n      // Output Placemark\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        [point[0], point[1]], \r\n        {iconContent: ''}, \r\n        {\r\n          iconOffset: [0, -35],\r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n\r\n      this.placemarkHintContent = null;\r\n      this.placemarkIsVisible = true;\r\n      \r\n      // Image of Vertex. Object of classes: ymaps.Circle or TriangleVertexImage.\r\n      // To set it, use this.setTriangleImage() or this.setCircleImage()\r\n      // You should not add Vertex to Map until Image is not set up.\r\n      this.image = null;\r\n      this.imageZIndex = 1;\r\n      // Blue color    \r\n      this.color = '#0000FF'; \r\n      this.strokeColor = '#0000FF';\r\n\r\n      // null - for undefined, true - for Triangle Vertex Image, false - for Circle Vertex Image.\r\n      this.isTriangleVertex = null;\r\n\r\n      this.path = path; \r\n\r\n      // References to some another Vertices.\r\n      this.prevVertex = null;\r\n      this.nextVertex = null;\r\n\r\n      this.prevEdge = null;\r\n      this.nextEdge = null;\r\n\r\n      // Image of chute which shows chute direction on the this.nextEdge \r\n      this.chuteImage = new ChuteImage();\r\n\r\n      // true if this Vertex is situated between \r\n      // Base Vertex and Last Vertex of Path.\r\n      // null - for Base Vertex itself.\r\n      this.isBetweenBaseAndLast = null;\r\n            \r\n      this.clickNumber = 0;\r\n\r\n      this.vertexIsOnMap = false;\r\n      this.chuteIsOnMap = false;\r\n      // Vertex single clicking switcher\r\n      this.singleClickingIsOn = true;\r\n     \r\n      // Turning on/off vertex when conditon \r\n      // \"reachable/unreachable\" was changed\r\n      this.wasTurnOffBecauseUnreachable = false;\r\n      // The same for back direction\r\n      this.wasTurnOffBecauseBackUnreachable = false;\r\n\r\n      // Chute height at this vertex. It will be calculated later.      \r\n      this.height = null;      \r\n              \r\n      this.eventCircle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n      \r\n      // remove standart map zoom for double click\r\n      this.eventCircle.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });\r\n\r\n      this.eventCircle.events.add('contextmenu', function(e) {\r\n        e.stopPropagation();  \r\n        if (this.path.baseVertex != this && this.height != null && this.height >= 0) {\r\n          this.path.setBaseVertex(this);\r\n        }\r\n      }.bind(this));\r\n      \r\n      \r\n      this.eventCircle.events.add('drag', function(e) {\r\n        e.stopPropagation();\r\n        var point = this.eventCircle.geometry.getCoordinates();\r\n        this.setCoordinates(point);       \r\n        this.path.dragVertex(this);     \r\n      }.bind(this));\r\n    \r\n    }\r\n\r\n\r\n    setChuteImageCoordinates(point, angle = null) {\r\n      this.chuteImage.setCoordinates(point);\r\n      if (angle != null) {\r\n        this.chuteImage.rotate(angle);\r\n      }\r\n      if (point == null) {\r\n        if (this.chuteIsOnMap) {\r\n          this.path.map.geoObjects.remove(this.chuteImage);\r\n          this.chuteIsOnMap = false;\r\n        }\r\n      } else {\r\n        if (!this.chuteIsOnMap) {\r\n          this.path.map.geoObjects.add(this.chuteImage);\r\n          this.chuteIsOnMap = true;\r\n        }\r\n      }      \r\n    }\r\n\r\n\r\n\r\n\r\n    scale(scale) {\r\n      var radius = this.eventCircle.geometry.getRadius();  \r\n      radius = radius * scale;\r\n      this.eventCircle.geometry.setRadius(radius);\r\n      \r\n      if (this.isTriangleVertex) {\r\n        var triangleScale = this.image.getScale();\r\n        triangleScale *= scale;\r\n        this.image.setScale(triangleScale);\r\n\r\n      } else {\r\n        radius = this.image.geometry.getRadius();  \r\n        radius = radius * scale;\r\n        this.image.geometry.setRadius(radius);\r\n      }\r\n    }\r\n\r\n    setIsBetweenBaseAndLast(isBetweenBaseAndLast) {\r\n      this.isBetweenBaseAndLast = isBetweenBaseAndLast;\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {Vertex | null} vertex \r\n     */\r\n    setNextVertex(vertex) {\r\n      this.nextVertex = vertex;\r\n      if (vertex != null) {        \r\n        vertex.prevVertex = this;\r\n      } \r\n    }\r\n\r\n    setPrevVertex(vertex) {\r\n      this.prevVertex = vertex;\r\n      if (vertex != null) {        \r\n        vertex.nextVertex = this;\r\n      } \r\n    }\r\n\r\n\r\n    setNextEdge(edge) {\r\n      this.nextEdge = edge;\r\n      if (edge != null) {        \r\n        edge.prevVertex = this;\r\n        edge.nextVertex = this.nextVertex;\r\n        if (this.nextVertex != null) {\r\n          this.nextVertex.prevEdge = edge;\r\n        }\r\n      } \r\n    }\r\n\r\n    setPrevEdge(edge) {\r\n      this.prevEdge = edge;\r\n      if (edge != null) {\r\n        edge.nextVertex = this;\r\n        edge.prevVertex = this.prevVertex;\r\n        if (this.prevVertex != null) {\r\n          this.prevVertex.nextEdge = edge;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {number[]} prevPoint - Previuos point that define direction of Triangle.\r\n     */\r\n    setTriangleVertex(prevPoint) {\r\n\r\n      this.isTriangleVertex = true;\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.image);\r\n        this.path.map.geoObjects.remove(this.heightPlacemark);  \r\n      }\r\n\r\n      var point1 = prevPoint;\r\n      var point2 = this.getCoordinates();\r\n      \r\n      // Set Triangle Image \r\n      this.image = \r\n        new TriangleVertexImage(point1, point2, this.color, this.strokeColor, this.path.triangleScale, this.imageZIndex);\r\n\r\n      // Set Placemark with Closing Cross\r\n      var path = this.path;\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(   \r\n        '<div class=\"px-2 py-1 bg-info d-inline-flex rounded border align-items-center\"' + \r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' +\r\n          '<div class=\"bg-info pr-2\">$[properties.iconContent]</div>' +            \r\n          '<div class=\"bg-info placemarkCross placemarkCrossImage\"></div>' +\r\n          //'<div class=\"p-0 bg-info hoverColor\">&#10006;</div>' +\r\n        '</div>', {\r\n          build: function () {\r\n            this.constructor.superclass.build.call(this);\r\n            this.path = path;\r\n            var elem = this.getData().geoObject;\r\n            elem.events.add('click', this.clickFunc, this);\r\n            elem.events.add('mouseenter', this.mouseEnter, this);\r\n            elem.events.add('mouseleave', this.mouseLeave, this); \r\n          }, \r\n\r\n          clear: function () { \r\n            var elem = this.getData().geoObject;\r\n            elem.events.remove('click', this.clickFunc, this);\r\n            elem.events.remove('mouseenter', this.mouseEnter, this);\r\n            elem.events.remove('mouseleave', this.mouseLeave, this); \r\n\r\n            this.constructor.superclass.clear.call(this);\r\n          },\r\n\r\n        \r\n          getShape: function () {\r\n            var parentElement = this.getParentElement();\r\n            if (parentElement != null) {\r\n              var element = $('.d-inline-flex', parentElement);\r\n              var width = element[0].offsetWidth;\r\n              var height = element[0].offsetHeight;\r\n              var position = element.position();\r\n              \r\n              return new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([\r\n                [position.left + width - 15, position.top],\r\n                [position.left + width, position.top + height]\r\n              ]));\r\n            } else {\r\n              return null;\r\n            }  \r\n          },\r\n\r\n \r\n          clickFunc: function(e) {\r\n            e.preventDefault();\r\n            if (this.path.length > 2) { \r\n              if (confirm(\"Удалить все метки? \\n\\n (для удаления только одной метки дважды щелкните по ней)\")) {\r\n                this.path.clear();\r\n              };\r\n            } else {\r\n              this.path.clear();\r\n            }\r\n          }.bind(this),\r\n          \r\n          mouseEnter: function() {\r\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\r\n            $(elem).removeClass('placemarkCrossImage');\r\n            $(elem).addClass('placemarkCrossImagePointed');\r\n          \r\n          },\r\n\r\n          mouseLeave: function() {\r\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\r\n            $(elem).removeClass('placemarkCrossImagePointed');\r\n            $(elem).addClass('placemarkCrossImage');\r\n          }           \r\n        }\r\n      );\r\n\r\n      var MyIconShape = {\r\n        type: 'Rectangle',\r\n        coordinates: [[71, 0], [96, 25]]\r\n      };\r\n           \r\n      this.heightPlacemark.options.set('iconLayout', MyIconLayout);\r\n      this.heightPlacemark.options.set('iconShape', MyIconShape);\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.add(this.image);\r\n        this.path.map.geoObjects.add(this.heightPlacemark);  \r\n      }     \r\n    }\r\n\r\n    /**\r\n     * @param {number} radius - Radious of Vertex Image.\r\n     */\r\n    setCircleVertex(radius) {\r\n\r\n      this.isTriangleVertex = false;\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.image);\r\n        this.path.map.geoObjects.remove(this.heightPlacemark);  \r\n      } \r\n\r\n      var point = this.getCoordinates();      \r\n      //var color = '#0000FF';\r\n      this.image = new ymaps.Circle([point, radius], {}, {\r\n        fillColor: this.color, \r\n        strokeColor: this.strokeColor, \r\n        strokeWidth: 2,\r\n        zIndex: this.imageZIndex\r\n      });\r\n\r\n      // Set Placemark without Closing Cross\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(   \r\n        '<div class=\"px-2 py-1 bg-info text-center rounded border d-inline-block\"' + \r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' + \r\n          '$[properties.iconContent]' + \r\n        '</div>'\r\n      );  \r\n            \r\n      this.heightPlacemark.options.set('iconLayout', MyIconLayout);\r\n      this.heightPlacemark.options.set('iconShape', null);\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.add(this.image); \r\n        this.path.map.geoObjects.add(this.heightPlacemark); \r\n      }  \r\n    }  \r\n    \r\n        \r\n    addToMap() {\r\n      if (!this.vertexIsOnMap && this.isTriangleVertex != null) {\r\n        this.path.map.geoObjects.add(this.eventCircle);         \r\n        this.path.map.geoObjects.add(this.image);\r\n        this.path.map.geoObjects.add(this.heightPlacemark);  \r\n        //this.path.map.geoObjects.add(this.chuteImage);     \r\n        this.vertexIsOnMap = true;\r\n      }      \r\n    }\r\n    \r\n    \r\n    removeFromMap() {\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.eventCircle);         \r\n        this.path.map.geoObjects.remove(this.image);\r\n        this.path.map.geoObjects.remove(this.heightPlacemark);    \r\n        this.vertexIsOnMap = false;\r\n      }               \r\n      this.removeChuteImageFromMap();\r\n    }  \r\n\r\n    \r\n    addChuteImageToMap() {\r\n      if (!this.chuteIsOnMap) {\r\n        this.path.map.geoObjects.add(this.chuteImage);\r\n        this.chuteIsOnMap = true;  \r\n      }\r\n    }  \r\n\r\n    removeChuteImageFromMap() {\r\n      if (this.chuteIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.chuteImage);\r\n        this.chuteIsOnMap = false;  \r\n      }\r\n    }\r\n\r\n    \r\n    /** \r\n     * Turn off single clicking on vertex.\r\n     * Remember, that single clicking on vertex \r\n     * shows or hides Placemark.     \r\n     */\r\n    turnOffSingleClicking() {\r\n      if (this.singleClickingIsOn) {\r\n        this.singleClickingIsOn = false;\r\n      } else {\r\n        console.warn(\"Single clicking is already off!\");\r\n      }        \r\n    }\r\n\r\n    /** \r\n     * Turn on single clicking on vertex.\r\n     * Remember, that single clicking on vertex \r\n     * shows or hides Placemark.     \r\n     */    \r\n    turnOnSingleClicking() {\r\n      if (!this.singleClickingIsOn) {\r\n        this.singleClickingIsOn = true;\r\n      } else {\r\n        console.warn(\"Single clicking is already on!\");\r\n      }            \r\n    }\r\n         \r\n    /**\r\n     * Process both click and dblclick on this vertex.\r\n     * Single clicking is for showing/hiding Placemark. \r\n     * Double clicking is for vertex removing.\r\n     */       \r\n    processVertexClick() {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (this.clickNumber == 1) {  // Single Click (show/hide Placemark)\r\n            if (this.singleClickingIsOn) {\r\n              if (this.nextVertex != null) {\r\n                this.placemarkIsVisible = !this.placemarkIsVisible;\r\n                this.heightPlacemark.options.set('visible', this.placemarkIsVisible);\r\n                //console.log(this.heightPlacemark);\r\n                if (this.placemarkIsVisible) {                \r\n                  this.path.map.geoObjects.remove(this.eventCircle);                    \r\n                  this.eventCircle.properties.set('hintContent', null);\r\n                  this.path.map.geoObjects.add(this.eventCircle); \r\n                } else {\r\n                  this.eventCircle.properties.set('hintContent', this.placemarkHintContent);\r\n                }\r\n              }\r\n            }                            \r\n            this.clickNumber = 0;\r\n          } else {  // Double Click (remove Vertex)           \r\n            this.path.removeVertex(this);   \r\n            this.clickNumber = 0;              \r\n          }  \r\n        }.bind(this), 200);\r\n      }  \r\n    }\r\n\r\n    \r\n    /**\r\n     * Set the same coordinates for Event Circle, \r\n     * Vertex Placemark, Vertex Image.\r\n     * Change Direction of Triangles (if vertex is Triangle vertex) \r\n     * for this Vertex, prevVertex, nextVertex. \r\n     */     \r\n    setCoordinates(point) {\r\n     \r\n      this.eventCircle.geometry.setCoordinates(point);\r\n      this.heightPlacemark.geometry.setCoordinates(point);\r\n      this.chuteImage.setCoordinates(point);\r\n      \r\n      // Note: it supposed in in case of Triangle Vertex, pervVertex != null.\r\n      if (this.isTriangleVertex) {\r\n         var prevPoint = this.prevVertex.eventCircle.geometry.getCoordinates();\r\n         // Here we calculate vertices of Image Triangle\r\n         this.image.setCoordinates(prevPoint, point);\r\n      } else {\r\n        // In this case, this.image is a Circle, so \r\n        // we can set coordinates of it center.\r\n        this.image.geometry.setCoordinates(point);\r\n      }\r\n       \r\n      if (this.nextVertex != null && this.nextVertex.isTriangleVertex) {\r\n        var nextPoint = this.nextVertex.eventCircle.geometry.getCoordinates();\r\n        this.nextVertex.image.setCoordinates(point, nextPoint);\r\n      }    \r\n    }\r\n\r\n\r\n    getCoordinates() {\r\n      return this.eventCircle.geometry.getCoordinates();\r\n    }\r\n\r\n\r\n    setColor(color) {\r\n      this.color = color;\r\n      if (this.image != null) {\r\n        this.image.options.set('fillColor', color);\r\n      }\r\n    }\r\n\r\n    setStrokeColor(color) {\r\n      this.strokeColor = color;\r\n      if (this.image != null) {\r\n        this.image.options.set('strokeColor', color);\r\n      }      \r\n    }\r\n\r\n    setHeight(height) {\r\n      this.height = height;\r\n\r\n      if (typeof(height) == 'number') {\r\n        this.printHint(Math.floor(height) + '&nbsp;м');\r\n        this.printPlacemark(Math.floor(height) + '&nbsp;м');\r\n        // Blue color.\r\n        this.setColor('#0000FF');\r\n        if (this.path.baseVertex == this) {\r\n          // Yellow color. \r\n          this.setStrokeColor('#FFFF00');  \r\n        } else {\r\n          this.setStrokeColor('#0000FF');\r\n        }\r\n        //if (this.prevEdge != null) {\r\n        //  this.prevEdge.setColor('#0000FF');\r\n        //}       \r\n\r\n      } else {\r\n        this.printHint('&#x26D4;');\r\n        this.printPlacemark('&#x26D4;');\r\n        // Red color.\r\n        this.setColor('#FF0000');\r\n        this.setStrokeColor('#FF0000');\r\n        //if (this.prevEdge != null) {\r\n        //  this.prevEdge.setColor('#FF0000');    \r\n        //} \r\n        /*\r\n        if (firstUnreachable) {\r\n          firstUnreachable = false;\r\n        } else {\r\n        }  */\r\n      }\r\n    }\r\n\r\n    \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set('iconContent', str); \r\n    }\r\n    \r\n    printHint(str) {\r\n      this.placemarkHintContent = str;\r\n\r\n      if (!this.placemarkIsVisible) {\r\n        this.eventCircle.properties.set('hintContent', str);\r\n      }     \r\n    }       \r\n  } \r\n  provide(Vertex);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Vertex.js?");

/***/ }),

/***/ "./src/scripts/Wind.js":
/*!*****************************!*\
  !*** ./src/scripts/Wind.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Wind', [\r\n  'WindVertex'\r\n],\r\nfunction(provide, WindVertex) {\r\n\r\n  /**\r\n   * Wind at particular height.  \r\n   */\r\n  class Wind {\r\n    /** \r\n     * Wind at special height.\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     * @param {number} angle - Angle between current wind and West wind; in degrees.    \r\n     * @param {(number | null)} height - In meters; height must be >= 0.\r\n     */\r\n    constructor(value, angle, height, map) {\r\n            \r\n      this.value = value;\r\n      this.height = height;\r\n      this.setAngle(angle); \r\n\r\n      this.prevWind = null;\r\n      this.nextWind = null; \r\n\r\n      //this.vertex = null;   \r\n\r\n      //this.point = null;\r\n\r\n      this.vertex = new WindVertex(height, map);\r\n    }\r\n\r\n\r\n    setVertexCoordinates(point) {\r\n      //this.point = point;\r\n      this.vertex.setCoordinates(point);      \r\n    } \r\n\r\n    /*\r\n    getPoint() {\r\n      return this.point;\r\n    }*/\r\n\r\n\r\n    setNextWind(wind) {\r\n      this.nextWind = wind;\r\n      if (wind != null) {\r\n        wind.prevWind = this;\r\n      }\r\n    }  \r\n\r\n    setPrevWind(wind) {\r\n      this.prevWind = wind;\r\n      if (wind != null) {\r\n        wind.nextWind = this;\r\n      }\r\n    }  \r\n   \r\n    /**\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     */\r\n    setValue(value) {\r\n      this.value = value;                   \r\n    }\r\n\r\n    /**\r\n     * angle will be reduced to interval (-180, 180] degrees.\r\n     * @param {number} angle\r\n     */\r\n    setAngle(angle) {\r\n      \r\n      angle = Math.floor(angle); \r\n      \r\n      if (angle != -180) {  // we want to differ -180 degree and 180 degree at wind menu scale             \r\n        if (angle >= 0) {\r\n          angle = angle % 360;\r\n        } else {\r\n          // negative angle case\r\n          angle = angle * (-1);\r\n          angle = angle % 360;\r\n          angle = 360 - angle;        \r\n        }\r\n        \r\n        if (angle > 180) {\r\n          angle -= 360;\r\n        }\r\n      }      \r\n      this.angle = angle;            \r\n    }\r\n\r\n    /**\r\n     * Set this.height and print it to Arrow Output Icon.\r\n     * @param {(number | null)} height - In meters; height must be >= 0.\r\n     */\r\n    setHeight(height) {\r\n      this.height = height;\r\n      this.vertex.printPlacemark(Math.floor(height));      \r\n    }\r\n         \r\n    getAngle() {\r\n      return(this.angle);\r\n    }\r\n    \r\n    getValue() {\r\n      return(this.value);\r\n    }\r\n    \r\n    getHeight() {\r\n      return(this.height);\r\n    }\r\n\r\n    toString() {\r\n      var str = (this.height == 0) ? 'Поверхностный ветер: ' : ('h=' + this.height + 'м');\r\n      str += (this.value + ' м/с, ' + this.getDirection());\r\n      return str;\r\n    }\r\n        \r\n    /**\r\n     * Calculate wind coordinates in cartesian coordinate system.\r\n     * @return {number[]} [vx, vy] - coordinates, in m/sec.\r\n     */\r\n    getXY () {      \r\n      var radiandirection = this.angle * ((2*Math.PI)/360);       \r\n      var vx = this.value * Math.cos(radiandirection);\r\n      var vy = this.value * Math.sin(radiandirection);\r\n      return [vx, vy];      \r\n    } \r\n    \r\n    /**\r\n     * Get name of wind direction (E, EN, N, NW, W, WS, S, SE)\r\n     */    \r\n    getDirection() {     \r\n      var angleSwitch = Math.floor((this.angle + 180 + 22)/45);\r\n      var direction;\r\n      \r\n      switch(angleSwitch) {\r\n        case 0: direction = \"В\"; break;\r\n        case 1: direction = \"СВ\"; break;\r\n        case 2: direction = \"С\"; break;\r\n        case 3: direction = \"СЗ\"; break;\r\n        case 4: direction = \"З\"; break;\r\n        case 5: direction = \"ЮЗ\"; break;\r\n        case 6: direction = \"Ю\"; break;\r\n        case 7: direction = \"ЮВ\"; break;\r\n        case 8: direction = \"В\"; break;    \r\n      }\r\n      \r\n      return(direction);     \r\n    }      \r\n  }\r\n      \r\n  provide(Wind);  \r\n});      \r\n\n\n//# sourceURL=webpack:///./src/scripts/Wind.js?");

/***/ }),

/***/ "./src/scripts/WindList.js":
/*!*********************************!*\
  !*** ./src/scripts/WindList.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindList', ['Wind'],\r\nfunction(provide, Wind) {\r\n  \r\n  /**\r\n   * List of winds at different heights; \r\n   * always contains wind at height = 0m (surface wind); \r\n   * that surface wind is always first and cannot be removed.\r\n   * List will be sorted for height (from bottom to top); \r\n   * all winds should have different heights.\r\n   */\r\n  class WindList {\r\n    constructor(map) {\r\n      this.map = map; \r\n\r\n      // Surface wind: 5 m/sec, West\r\n      var angle = 0;\r\n      this.firstWind = new Wind(5, angle, 0, this.map);\r\n      this.map.windOutput.print(this.firstWind.toString());\r\n      this.map.arrow.rotate(angle);\r\n          \r\n      this.lastWind = this.firstWind;\r\n      this.numberOfWinds = 1;\r\n\r\n      this.windVertexRadius = 4;   \r\n      \r\n      this.pathBoundChange = this.pathBoundChange.bind(this);   \r\n      this.map.events.add('boundschange', this.pathBoundChange);      \r\n    }\r\n    \r\n       \r\n    /**\r\n     * Add wind to the List and sort List.\r\n     * @param {Wind} wind\r\n     */ \r\n    addWind(wind) {      \r\n      this.lastWind.setNextWind(wind);      \r\n      this.lastWind = wind;\r\n      this.numberOfWinds++;\r\n      this.sortList();\r\n    } \r\n    \r\n    \r\n    /**\r\n     * Remove wind from WindList. \r\n     * Note: you cannot remove firstWind by construction.\r\n     * @param {Wind} wind - It is supposed that wind belongs to WindList.  \r\n     */\r\n    removeWind(wind) {     \r\n      // First wind, that is, surface wind, cannot be removed\r\n      if (wind == this.firstWind) {\r\n        console.warn(\"This wind was not removed, because it was firstWind.\");\r\n        return;\r\n      }\r\n      \r\n      if (wind.vertex.vertexIsOnMap) {\r\n        wind.vertex.removeFromMap();\r\n      }\r\n\r\n      wind.prevWind.setNextWind(wind.nextWind);\r\n      if (wind == this.lastWind) {\r\n        this.lastWind = this.lastWind.prevWind;\r\n      }                                       \r\n      this.numberOfWinds--;         \r\n    }\r\n    \r\n        \r\n    /**\r\n     * Check if this list has a wind with given height.  \r\n     * @param {number} height\r\n     */\r\n    heightIsInList(height) {\r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        if (wind.getHeight() == height) return true;\r\n        wind = wind.nextWind;\r\n      }\r\n      return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Bubble sort (it is practical for small list)\r\n     */\r\n    sortList() {\r\n\r\n      while(true) {\r\n        var wind = this.firstWind;\r\n        var swapped = false;\r\n\r\n        while(wind != this.lastWind) {\r\n          if (wind.height > wind.nextWind.height) {\r\n            this.swapWindAndNextWind(wind);\r\n            swapped = true;          \r\n          } else {\r\n            wind = wind.nextWind;\r\n          }\r\n        }\r\n        if (!swapped) break;\r\n      }\r\n    } \r\n\r\n\r\n    /**\r\n     * Print List in console (for development needs)\r\n     */\r\n    printList() {\r\n      console.log('\\n\\n\\n');\r\n      var wind = this.firstWind;\r\n      var i=0;\r\n      while(wind != null) {\r\n        console.log('wind #' + i + ':'); console.log(wind);\r\n        i++;\r\n        wind = wind.nextWind;\r\n      }\r\n    }\r\n    \r\n\r\n    /**\r\n     * Swap wind and wind.nextWind.  \r\n     */\r\n    swapWindAndNextWind(wind) { \r\n      var nextWind = wind.nextWind;\r\n      if (nextWind == null) return;\r\n\r\n      nextWind.setPrevWind(wind.prevWind);\r\n      var nextWindNextWind = nextWind.nextWind;\r\n      nextWind.setNextWind(wind);\r\n      wind.setNextWind(nextWindNextWind); \r\n      \r\n      if (this.firstWind == wind) {\r\n        this.firstWind = nextWind;\r\n      }\r\n      if (this.lastWind == nextWind) {\r\n        this.lastWind = wind;\r\n      }        \r\n    }\r\n\r\n    \r\n    removeWindVertices() {\r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        wind.setVertexCoordinates(null);       \r\n        wind = wind.nextWind;\r\n      }     \r\n    }\r\n\r\n\r\n    pathBoundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        var scale = (2**(oldZoom - newZoom));\r\n        this.scale(scale);\r\n      }\r\n    }\r\n  \r\n  \r\n    scale(scale) {\r\n      this.windVertexRadius *= scale;\r\n        var wind = this.firstWind;\r\n        while (wind != null) {\r\n          wind.vertex.scale(scale);\r\n          wind = wind.nextWind;\r\n        }      \r\n    }\r\n  }\r\n      \r\n  provide(WindList);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindList.js?");

/***/ }),

/***/ "./src/scripts/WindPointsList.js":
/*!***************************************!*\
  !*** ./src/scripts/WindPointsList.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindPointsList', [],\r\nfunction(provide) {\r\n\r\n  class WindPointsList {\r\n    constructor(point) {\r\n      this.firstPoint = point;\r\n      this.firstPoint.nextPoint = null;\r\n      this.length = 1;\r\n      this.currentPoint = point;\r\n    }  \r\n\r\n    addPoint(point) {\r\n      this.currentPoint.nextPoint = point;\r\n      this.currentPoint = point;\r\n      this.length++;\r\n    }    \r\n  }      \r\n  provide(WindPointsList);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindPointsList.js?");

/***/ }),

/***/ "./src/scripts/WindVertex.js":
/*!***********************************!*\
  !*** ./src/scripts/WindVertex.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindVertex', [\r\n  'Circle',\r\n  'Placemark',\r\n  'templateLayoutFactory',\r\n  'ChuteImage',\r\n  'PreVertex',\r\n],\r\nfunction(provide, Circle, Placemark, templateLayoutFactory,\r\n    ChuteImage, PreVertex) {\r\n  /**\r\n   * Wind Vertex consists of Vertex Image (Circle) and\r\n   * Vertex Placemark for output.\r\n   */\r\n  class WindVertex {\r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {number} radius\r\n     */\r\n    //constructor(wind, map, radius = 4) {\r\n    constructor(height, map) {\r\n\r\n      this.height = height;\r\n      this.map = map;\r\n\r\n      var color = \"#0000FF\";\r\n      var strokeColor = \"#00FF00\";\r\n      var radius = 4;\r\n\r\n      var point = null;\r\n\r\n      // Coordinates will be set up later (image is not on the map now).\r\n      this.image = new ymaps.Circle([point, radius], {}, {\r\n        fillColor: color,\r\n        strokeColor: strokeColor,\r\n        strokeWidth: 2\r\n      });\r\n\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(\r\n        '<div class=\"px-2 py-1 bg-success text-center rounded border d-inline-block\"' +\r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' +\r\n          '$[properties.iconContent]' +\r\n        '</div>');\r\n\r\n      // Placemark for Height of Chute at this vertex.\r\n      // Coordinates will be set up later.\r\n      this.heightPlacemark = new ymaps.Placemark(point, {}, {\r\n        iconLayout: MyIconLayout,\r\n        iconOffset: [0, -35],\r\n        cursor: 'arrow'\r\n      });\r\n\r\n      this.prevVertex = null;\r\n      this.nextVertex = null;\r\n\r\n      // Image of chute which shows chute direction on the this.nextEdge\r\n      this.chuteImage = new ChuteImage();\r\n\r\n      this.placemarkIsVisible = true;\r\n      //this.printPlacemark(wind.getHeight() + \"&nbsp;м\");\r\n      this.printPlacemark(height);\r\n\r\n      this.clickNumber = 0;\r\n      this.placemarkIsShown = true;\r\n\r\n      this.image.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n\r\n      // remove standart map zoom for double click\r\n      this.image.events.add('dblclick', function(e) {\r\n        e.stopPropagation();\r\n      });\r\n\r\n      this.vertexIsOnMap = false;\r\n      this.chuteIsOnMap = false;\r\n      this.edge = null;\r\n    }\r\n\r\n\r\n    getCoordinates() {\r\n      return this.image.geometry.getCoordinates();\r\n    }\r\n\r\n\r\n    setCoordinates(point) {\r\n      if (point == null) {\r\n        if (this.vertexIsOnMap) {\r\n          this.removeFromMap();\r\n        }\r\n      } else {\r\n        if (!this.vertexIsOnMap) {\r\n          this.addToMap();\r\n        }\r\n        this.image.geometry.setCoordinates(point);\r\n        this.heightPlacemark.geometry.setCoordinates(point);\r\n      }\r\n    }\r\n\r\n\r\n    setChuteImageCoordinates(point) {\r\n      this.chuteImage.setCoordinates(point);\r\n      if (point == null) {\r\n        if (this.chuteIsOnMap) {\r\n          this.map.geoObjects.remove(this.chuteImage);\r\n          this.chuteIsOnMap = false;\r\n        }\r\n      } else {\r\n        if (!this.chuteIsOnMap) {\r\n          this.map.geoObjects.add(this.chuteImage);\r\n          this.chuteIsOnMap = true;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    scale(scale) {\r\n      var radius = this.image.geometry.getRadius();\r\n      radius = radius * scale;\r\n      this.image.geometry.setRadius(radius);\r\n    }\r\n\r\n\r\n    processVertexClick() {\r\n      this.placemarkIsVisible = !this.placemarkIsVisible;\r\n      this.heightPlacemark.options.set('visible', this.placemarkIsVisible);\r\n    }\r\n\r\n    /**\r\n     * @param {string | null} str - This will be printed in this.heightPlacemark\r\n     */\r\n    printPlacemark(str) {\r\n      var newStr = (str == null) ? '' : str;\r\n      this.heightPlacemark.properties.set('iconContent', newStr  + \"&nbsp;м\");\r\n    }\r\n\r\n    printHint(str) {\r\n      var newStr = (str == null) ? '' : str;\r\n      this.properties.set('hintContent', newStr  + \"&nbsp;м\");\r\n    }\r\n\r\n    addToMap() {\r\n      if (this.vertexIsOnMap) {\r\n        console.warn('Wind Vertex have already been added.');\r\n        return;\r\n      }\r\n      this.map.geoObjects.add(this.image);\r\n      this.map.geoObjects.add(this.heightPlacemark);\r\n      //this.map.geoObjects.add(this.chuteImage);\r\n      this.vertexIsOnMap = true;\r\n    }\r\n\r\n    removeFromMap() {\r\n      if (!this.vertexIsOnMap) {\r\n        console.warn('Wind Vertex have already been removed.');\r\n        return;\r\n      }\r\n      this.map.geoObjects.remove(this.image);\r\n      this.map.geoObjects.remove(this.heightPlacemark);\r\n      //this.map.geoObjects.remove(this.chuteImage);\r\n      /*\r\n      if (this.chuteImageIsOnMap) {\r\n        this.map.geoObjects.remove(this.chuteImage);\r\n        this.chuteImageIsOnMap = false;\r\n      }    */\r\n      this.vertexIsOnMap = false;\r\n      this.removeChuteImageFromMap();\r\n    }\r\n\r\n\r\n    addChuteImageToMap() {\r\n      if (!this.chuteIsOnMap) {\r\n        this.path.map.geoObjects.add(this.chuteImage);\r\n        this.chuteIsOnMap = true;\r\n      }\r\n    }\r\n\r\n    removeChuteImageFromMap() {\r\n      if (this.chuteIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.chuteImage);\r\n        this.chuteIsOnMap = false;\r\n      }\r\n    }\r\n\r\n  }\r\n  provide(WindVertex);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindVertex.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Program calculate heights of Glider (Chute) for\r\n * Vertices of the Path. Path is a set of Vertices and Edges.\r\n * You can input Path by clicking on the Yandex Map.\r\n */\r\n\r\nymaps.ready(init);\r\nfunction init() {\r\n  ymaps.modules.require([\r\n    'AppMap',\r\n    'WindList',\r\n    'Chute',\r\n    'Path',\r\n    'Calculator',\r\n    'DialogWindows', 'Circle'\r\n  ]).spread(function (\r\n    AppMap,\r\n    WindList,\r\n    Chute,\r\n    Path,\r\n    Calculator,\r\n    DialogWindows, Circle\r\n  ) {\r\n    // Yandex map\r\n    var map = new AppMap();\r\n\r\n    // Chute velocity = (10, 5) m/s\r\n    var chute = new Chute(10, 5);\r\n\r\n    // Winds at several heights\r\n    var windList = new WindList(map);\r\n\r\n    // List of Vertices and Edges\r\n    var path = new Path(map);\r\n\r\n    // Calculator will make all computations\r\n    var calculator = new Calculator(path, chute, windList);\r\n\r\n    path.setCalculator(calculator);\r\n\r\n    // Click on the map will add vertice to the end of the Path,\r\n    // double click on the map will add vertice to the beginning of the Path.\r\n    var clickNumber = 0;\r\n    map.events.add('click', function(e) {\r\n      var point = e.get('coords');\r\n      clickNumber++;\r\n      if (clickNumber == 1) {\r\n        setTimeout(function() {\r\n          if (clickNumber == 1) {  // Single Click\r\n\r\n            //var c = new ymaps.Placemark(null);\r\n            //map.geoObjects.add(c);\r\n            //c.geometry.setCoordinates(point);\r\n            ///console.log(c.geometry.getRadius());\r\n\r\n            // We add vertex to the end of the Path\r\n            path.addVertex(point, true);\r\n          } else {  // Double Click\r\n            // We add new vertex to the beginning of the Path\r\n            path.addVertex(point, false);\r\n          }\r\n          clickNumber = 0;\r\n        }, 200);\r\n      }\r\n    });\r\n\r\n\r\n    /**\r\n     * Menu initialization\r\n     */\r\n    DialogWindows.initMenu(map, chute, windList, path, calculator);\r\n  });\r\n}\n\n//# sourceURL=webpack:///./src/scripts/index.js?");

/***/ }),

/***/ 0:
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/scripts/AppMap.js ./src/scripts/Arrow.js ./src/scripts/Calculator.js ./src/scripts/Chute.js ./src/scripts/ChuteImage.js ./src/scripts/Constant.js ./src/scripts/DialogWindows.js ./src/scripts/Edge.js ./src/scripts/index.js ./src/scripts/MenuButton.js ./src/scripts/OutputElement.js ./src/scripts/Path.js ./src/scripts/PreVertex.js ./src/scripts/TriangleVertexImage.js ./src/scripts/VectorMath.js ./src/scripts/Vertex.js ./src/scripts/Wind.js ./src/scripts/WindList.js ./src/scripts/WindPointsList.js ./src/scripts/WindVertex.js ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/scripts/AppMap.js */\"./src/scripts/AppMap.js\");\n__webpack_require__(/*! ./src/scripts/Arrow.js */\"./src/scripts/Arrow.js\");\n__webpack_require__(/*! ./src/scripts/Calculator.js */\"./src/scripts/Calculator.js\");\n__webpack_require__(/*! ./src/scripts/Chute.js */\"./src/scripts/Chute.js\");\n__webpack_require__(/*! ./src/scripts/ChuteImage.js */\"./src/scripts/ChuteImage.js\");\n__webpack_require__(/*! ./src/scripts/Constant.js */\"./src/scripts/Constant.js\");\n__webpack_require__(/*! ./src/scripts/DialogWindows.js */\"./src/scripts/DialogWindows.js\");\n__webpack_require__(/*! ./src/scripts/Edge.js */\"./src/scripts/Edge.js\");\n__webpack_require__(/*! ./src/scripts/index.js */\"./src/scripts/index.js\");\n__webpack_require__(/*! ./src/scripts/MenuButton.js */\"./src/scripts/MenuButton.js\");\n__webpack_require__(/*! ./src/scripts/OutputElement.js */\"./src/scripts/OutputElement.js\");\n__webpack_require__(/*! ./src/scripts/Path.js */\"./src/scripts/Path.js\");\n__webpack_require__(/*! ./src/scripts/PreVertex.js */\"./src/scripts/PreVertex.js\");\n__webpack_require__(/*! ./src/scripts/TriangleVertexImage.js */\"./src/scripts/TriangleVertexImage.js\");\n__webpack_require__(/*! ./src/scripts/VectorMath.js */\"./src/scripts/VectorMath.js\");\n__webpack_require__(/*! ./src/scripts/Vertex.js */\"./src/scripts/Vertex.js\");\n__webpack_require__(/*! ./src/scripts/Wind.js */\"./src/scripts/Wind.js\");\n__webpack_require__(/*! ./src/scripts/WindList.js */\"./src/scripts/WindList.js\");\n__webpack_require__(/*! ./src/scripts/WindPointsList.js */\"./src/scripts/WindPointsList.js\");\nmodule.exports = __webpack_require__(/*! ./src/scripts/WindVertex.js */\"./src/scripts/WindVertex.js\");\n\n\n//# sourceURL=webpack:///multi_./src/scripts/AppMap.js_./src/scripts/Arrow.js_./src/scripts/Calculator.js_./src/scripts/Chute.js_./src/scripts/ChuteImage.js_./src/scripts/Constant.js_./src/scripts/DialogWindows.js_./src/scripts/Edge.js_./src/scripts/index.js_./src/scripts/MenuButton.js_./src/scripts/OutputElement.js_./src/scripts/Path.js_./src/scripts/PreVertex.js_./src/scripts/TriangleVertexImage.js_./src/scripts/VectorMath.js_./src/scripts/Vertex.js_./src/scripts/Wind.js_./src/scripts/WindList.js_./src/scripts/WindPointsList.js_./src/scripts/WindVertex.js?");

/***/ })

/******/ });