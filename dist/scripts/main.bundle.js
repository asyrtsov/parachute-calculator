/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/AppMap.js":
/*!*******************************!*\
  !*** ./src/scripts/AppMap.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('AppMap', [\r\n  'Map', \r\n  'control.ZoomControl', \r\n  'Constant', \r\n  'MenuButton',\r\n  'OutputElement',\r\n  'Arrow'  \r\n],\r\nfunction(provide, Map, ZoomControl, Constant, MenuButton, OutputElement, Arrow) {\r\n  /**\r\n   * @extends Map\r\n   */\r\n  class AppMap extends Map {\r\n\r\n    constructor() {\r\n\r\n      // Array of Dropzones and their coordinates.\r\n      var dz = [\r\n        {name: \"Коломна\", mapCenter: [55.091289443603706, 38.917269584802675]}, \r\n        {name: \"Пущино\", mapCenter: [54.78929269708931,37.64268598670033]}, \r\n        {name: \"Ватулино\", mapCenter: [55.663193308717396,36.14121807608322]}\r\n      ];    \r\n        \r\n      super(\"map\", {\r\n        center: dz[0].mapCenter,    \r\n        zoom: Constant.defaultZoom\r\n      }, {\r\n        suppressMapOpenBlock: true  // remove button 'open in yandex maps'\r\n      });\r\n      \r\n      this.dz = dz; \r\n \r\n      // view from space  \r\n      this.setType(\"yandex#satellite\");    \r\n      this.cursors.push('arrow');  \r\n      this.controls.remove('trafficControl');  \r\n      this.controls.remove('zoomControl');\r\n      var zoomControl = new ZoomControl({options: { \r\n        position: { right: 10, top: 105 }, \r\n        size: 'small'\r\n      }}); \r\n      this.controls.add(zoomControl);\r\n      this.controls.remove('geolocationControl');\r\n      this.controls.remove('fullscreenControl');   \r\n       \r\n      this.searchControl = this.controls.get('searchControl');\r\n      this.searchControl.options.set('size', 'small');\r\n      this.searchControl.options.set('noPlacemark', true);\r\n      this.searchControl.options.set('noSelect', true);\r\n\r\n      // Settings menu (ymaps.Button)\r\n      var settingsButton = new MenuButton(\"Настройки\", \"images/icon_menu.svg\", \r\n        \"#settingsMenu\", \"#settingsMenuDarkScreen\");\r\n      this.controls.add(settingsButton, {position: {top: 45, left: 10}});\r\n\r\n      // Output for Surface wind parameters (ymaps.Button)\r\n      this.windOutput = new OutputElement();      \r\n      this.controls.add(this.windOutput, {position: {bottom: 30, left: 10}});\r\n\r\n      // Wind arrow (Windsock)\r\n      this.arrow = new Arrow(this.getCenter());\r\n      this.geoObjects.add(this.arrow);\r\n\r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.preventDefault();  \r\n      }); \r\n\r\n      //this.menu = null;       \r\n    }\r\n    \r\n    /**\r\n     * Processing of yandex.maps search\r\n     */   /*\r\n    setSearchProcessor(calculator) {\r\n\r\n      this.calculator = calculator;    \r\n      this.path = calculator.path;\r\n      this.windList = calculator.windList;\r\n      \r\n      this.defaultZoom = Constant.defaultZoom;\r\n      \r\n      this.searchControl.events.add('resultshow', function(e) {\r\n                \r\n        this.path.clear(); \r\n        this.setZoom(this.defaultZoom);        \r\n        //this.windList.shiftList(this.getCenter());\r\n        this.map.arrow.setCoordinates(this.map.getCenter());  \r\n        \r\n        var index = e.get('index');    \r\n        var geoObjectsArray = this.searchControl.getResultsArray();\r\n        var resultName = geoObjectsArray[index].properties.get('name');\r\n\r\n        var newDz = {\r\n          name: resultName, \r\n          mapCenter: this.getCenter()\r\n        };    \r\n        this.dz.push(newDz);    \r\n        $(\"#dz\").append(\"<option>\" + newDz.name + \"</option>\");    \r\n        $(\"#dz\").children()[this.dz.length - 1].selected = true;    \r\n      }.bind(this));      \r\n    }  */\r\n        \r\n  } \r\n  provide(AppMap);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/AppMap.js?");

/***/ }),

/***/ "./src/scripts/Arrow.js":
/*!******************************!*\
  !*** ./src/scripts/Arrow.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Arrow', [\r\n  'Placemark',\r\n  'templateLayoutFactory', \r\n  'Constant'  \r\n],\r\nfunction(provide, Placemark, templateLayoutFactory, Constant) {\r\n  \r\n  /**\r\n   * Wind Arrow (Yandex Maps API Placemark). \r\n   * You can: rotate it, change its size and coordinates.\r\n   */\r\n  class Arrow extends Placemark {\r\n\r\n    constructor(coordinates) {      \r\n\r\n      var arrowStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var arrowStartRadius = Constant.isMobile ? arrowStartSize : arrowStartSize/2; \r\n      \r\n      super([], {\r\n          arrowClass: 'arrow',  \r\n          rotation: 0,           \r\n          size: arrowStartSize\r\n        }, {\r\n          draggable: true,\r\n          iconLayout: templateLayoutFactory.createClass(\r\n              '<div class=\"$[properties.arrowClass]\" style=\"transform: rotate($[properties.rotation]deg);' + \r\n              'width: $[properties.size]px; height: $[properties.size]px;\"/>'\r\n            ), \r\n          iconShape: {\r\n            type: 'Circle',\r\n            coordinates: [arrowStartSize/2, arrowStartSize/2],\r\n            radius: arrowStartRadius\r\n          }          \r\n        }\r\n      );\r\n\r\n      this.arrowStartSize = arrowStartSize;\r\n      this.arrowStartRadius = arrowStartRadius;   \r\n\r\n      this.setCoordinates(coordinates);\r\n      \r\n      this.boundChange = this.boundChange.bind(this);\r\n       \r\n    }\r\n    \r\n    setCoordinates(coordinates) {\r\n      this.geometry.setCoordinates(coordinates);   \r\n    }\r\n\r\n    \r\n   /**\r\n    * Rotate arrow\r\n    */\r\n    rotate(angle) {\r\n      this.properties.set('rotation', (-1)*angle);      \r\n    }\r\n\r\n    \r\n    /**\r\n     * Arrow can have different size for different Zoom.\r\n     */\r\n    changeSize(newZoom) {\r\n      var size = (2**(newZoom - Constant.defaultZoom))*(this.arrowStartSize);\r\n      \r\n      var shape = \r\n        {\r\n          type: 'Circle',\r\n          coordinates: [size/2, size/2],\r\n          radius: (2**(newZoom - Constant.defaultZoom))*(this.arrowStartRadius)\r\n        };\r\n      \r\n      this.options.set('iconShape', shape);      \r\n      this.properties.set('size', size);\r\n      // properties.set call rebuild of Placemark, \r\n      // so, properties.set should stay after options.set      \r\n    }\r\n\r\n    \r\n    /**\r\n     * If Yandex Maps Zoom is changed we will call this.changeSize() function.\r\n     * @param {Event} e - Yandex Maps 'boundschange' event.     \r\n     */\r\n    boundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        this.changeSize(newZoom);\r\n      }\r\n    }        \r\n  }\r\n\r\n  provide(Arrow);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/Arrow.js?");

/***/ }),

/***/ "./src/scripts/BoundaryHeights.js":
/*!****************************************!*\
  !*** ./src/scripts/BoundaryHeights.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('BoundaryHeights', ['Constant'],\r\nfunction(provide, Constant) {\r\n  \r\n  /**\r\n   * Object consists of three varialables: startHeight, finalHeight and \r\n   * calculationDirection.\r\n   * StartHeight is a height of first vertex of Path.\r\n   * FinalHeight is a height of last vertex of Path.   \r\n   * StartHeight and finalHeight can have following values: number or null.\r\n   * CalculationDirection has boolean value. If it equal to true, \r\n   * calculation will be made from first vertex of Path to last vertex, \r\n   * otherwise - from last vertex to first vertex.   \r\n   * StartHeight and finalHeight have connection to html &lt; input &gt; \r\n   * elements $(\"#startHeight\") and $(\"#finalHeight\").\r\n   * CalculationDirection has connection to $(\"#calculationDirection\") \r\n   * checkbox element. In constructor, we create two-side connection \r\n   * between those varialables and html elements.   \r\n   */\r\n  class BoundaryHeights {\r\n\r\n    constructor() {\r\n      // Value must be null or number\r\n      this.startHeight = null;\r\n      this.finalHeight = null;\r\n      \r\n      // Value must be bool\r\n      this.calculationDirection = Constant.defaultCalculationDirection;\r\n      $(\"#calculationDirection\").prop(\"checked\", !this.calculationDirection);\r\n            \r\n      // This objects should be set up by \r\n      // setPath() and setCalculator() methods\r\n      this.path = null;\r\n      this.calculator = null;\r\n      \r\n      this.setDefaultHeights();      \r\n      this.startProcessingHeightFields();\r\n      this.startProcessingCalculationDirectionField();      \r\n    }\r\n    \r\n    getCalculationDirection() {\r\n      return this.calculationDirection;\r\n    }\r\n    \r\n    setCalculationDirection(calculationDirection) {\r\n      this.calculationDirection = calculationDirection;      \r\n    }\r\n    \r\n        \r\n    setPath(path) {\r\n      this.path = path;\r\n    }\r\n    \r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @param {boolean} calculationDirection\r\n     */    \r\n    setDefaultHeights() {\r\n      if (this.calculationDirection) {\r\n        this.setStartHeight(Constant.defaultStartHeight);\r\n        this.setFinalHeight(Constant.defaultStartHeight);\r\n      } else {\r\n        this.setStartHeight(Constant.defaultFinalHeight);\r\n        this.setFinalHeight(Constant.defaultFinalHeight);        \r\n      }\r\n      \r\n      this.setPropDisabled();    \r\n    } \r\n    \r\n    /**\r\n     * Disable/enable heights field with dependence of \r\n     * calculationDirection.\r\n     */\r\n    setPropDisabled() {\r\n      $(\"#startHeight\").prop(\"disabled\", !this.calculationDirection);\r\n      $(\"#finalHeight\").prop(\"disabled\", this.calculationDirection);            \r\n    }\r\n\r\n    /**\r\n     * @param {(number | null)} finalHeight\r\n     */    \r\n    setStartHeight(startHeight) {\r\n      this.startHeight = startHeight;\r\n      this.printStartHeight();\r\n    }\r\n    \r\n    printStartHeight() {\r\n      if (this.startHeight != null) {\r\n        $(\"#startHeight\").val(Math.floor(this.startHeight));\r\n      } else {\r\n        if (this.calculationDirection) {\r\n          $(\"#startHeight\").val(\"\");  \r\n        } else {\r\n          $(\"#startHeight\").val(\"не определена\");\r\n        }  \r\n      }                \r\n    }\r\n    \r\n    /**\r\n     * @param {(number | null)} finalHeight\r\n     */\r\n    setFinalHeight(finalHeight) {\r\n      this.finalHeight = finalHeight;\r\n      this.printFinalHeight(); \r\n    }\r\n\r\n    printFinalHeight() {\r\n      if (this.finalHeight != null) {\r\n        $(\"#finalHeight\").val(Math.floor(this.finalHeight));\r\n      } else {        \r\n        if (this.calculationDirection) {\r\n          $(\"#finalHeight\").val(\"не определена\");  \r\n        } else {\r\n          $(\"#finalHeight\").val(\"\");\r\n        }  \r\n      }                \r\n    }        \r\n    \r\n    \r\n    makeHeightsEqual() {\r\n      if (this.calculationDirection) {\r\n        this.setFinalHeight(this.startHeight);        \r\n      } else {\r\n        this.setStartHeight(this.finalHeight);  \r\n      }      \r\n    }\r\n    \r\n    \r\n    startProcessingHeightFields() {\r\n      \r\n      $(\"#startHeight\").change(function () {       \r\n        var s = $(\"#startHeight\").val();\r\n        var n = Number.parseInt(s);\r\n        if ((n >= 0) && (n <= Constant.maxHeight)) {\r\n          \r\n          this.startHeight = n;\r\n          this.printStartHeight();\r\n     \r\n          if (this.path.length > 0) {  \r\n            this.calculator.calculateHeight();\r\n            this.path.printHeightsAndWindPoints();\r\n          } \r\n        } else {\r\n          this.printStartHeight();\r\n        }\r\n      }.bind(this));\r\n\r\n      \r\n      $(\"#finalHeight\").change(function () {       \r\n        var s = $(\"#finalHeight\").val();\r\n        var n = Number.parseFloat(s);\r\n        if ((n >= 0) && (n <= Constant.maxHeight)) {\r\n          this.finalHeight = n;\r\n          this.printFinalHeight();\r\n          \r\n          if (this.path.length > 0) {\r\n            this.calculator.calculateHeight();\r\n            this.path.printHeightsAndWindPoints();                       \r\n          } \r\n        } else {\r\n          this.printFinalHeight();\r\n        }    \r\n      }.bind(this));    \r\n    }  \r\n\r\n\r\n    startProcessingCalculationDirectionField() { \r\n  \r\n      $(\"#calculationDirection\").change(function() {\r\n        var isChecked = $(\"#calculationDirection\").prop(\"checked\");\r\n        this.calculationDirection = !isChecked;\r\n        this.setPropDisabled();\r\n                \r\n        if (this.path.length > 0) {         \r\n          this.calculator.calculateHeight();\r\n          this.printStartHeight();\r\n          this.printFinalHeight();\r\n          this.path.printHeightsAndWindPoints();              \r\n        } else {           \r\n          this.makeHeightsEqual();         \r\n        }                              \r\n      }.bind(this));     \r\n    } \r\n  } \r\n  provide(BoundaryHeights);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/BoundaryHeights.js?");

/***/ }),

/***/ "./src/scripts/Calculator.js":
/*!***********************************!*\
  !*** ./src/scripts/Calculator.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Calculator', [\r\n  'VectorMath', \r\n  'Constant'\r\n],\r\nfunction(provide, VectorMath, Constant) {\r\n  /**\r\n   * This class calculates: \r\n   * a) heights at all vertices of the Path \r\n   * (it will be kept in vertex.height varialables where vertex belongs \r\n   * to Path), \r\n   * b) points on the Path where wind changes (it will be kept in \r\n   * wind.pathPoint varialables where wind belongs to WindList). \r\n   * Calculation can be done from start vertex to final vertex or \r\n   * vice versa. Direction of calculation is determined by \r\n   * calculationDirection varialable.\r\n   */\r\n  class Calculator {\r\n    /**\r\n     * @param {Path} path - list of vertices and edges of Chute Path.\r\n     * @param {Chute} chute - Chute velocity.     \r\n     * @param {WindList} windList\r\n     * @param {BoundaryHeights} boundaryHeights     \r\n     */\r\n    constructor(path, chute, windList, boundaryHeights) {            \r\n      this.path = path;\r\n      this.chute = chute;\r\n      this.windList = windList;      \r\n\r\n      this.boundaryHeights = boundaryHeights;\r\n\r\n      // 'true' for calculation from the beginning of Path to the end of Path, \r\n      // 'false' for calculation from the end of Path to the beginning of Path.       \r\n      //this.calculationDirection = boundaryHeights.calculationDirection;\r\n    }\r\n\r\n    getCalculationDirection() {\r\n      return this.boundaryHeights.getCalculationDirection();      \r\n    }    \r\n    \r\n    setCalculationDirection(calculationDirection) {\r\n      this.boundaryHeights.setCalculationDirection(calculationDirection);      \r\n    }\r\n    \r\n    setStartHeight(startHeight) {\r\n      this.boundaryHeights.setStartHeight(startHeight);\r\n    }\r\n    \r\n    setFinalHeight(finalHeight) {\r\n      this.boundaryHeights.setFinalHeight(finalHeight);\r\n    }\r\n\r\n    setDefaultHeights() {\r\n      this.boundaryHeights.setDefaultHeights();      \r\n    }\r\n    \r\n\r\n    /**\r\n     * Main calculation function.\r\n     * If this.boundaryHeights.calculationDirection == true, then calculator begins computation \r\n     * from start vertex and boundaryHeights.startHeight height; \r\n     * if this.boundaryHeights.calculationDirection == false, then calculator begins computation \r\n     * from final vertex and boundaryHeights.finalHeight height.          \r\n     */\r\n    calculateHeight() {\r\n      if (this.path.length == 0) {\r\n        console.warn(\"Cannot calculate: Path is empty\");\r\n        return;\r\n      }  \r\n    \r\n      if (this.boundaryHeights.getCalculationDirection()) {\r\n        this.calculateHeightForward();\r\n      } else {\r\n        this.calculateHeightBack();\r\n      }       \r\n    }\r\n    \r\n    /**\r\n     * Case: forward calculation.\r\n     * It calculates: 1) heights at vertices of Path,  \r\n     * 2) points on Path which corresponding to winds from WindList, \r\n     * 3) boundaryHeights.finalHeight.  \r\n     */     \r\n    calculateHeightForward() {\r\n                                     \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n\r\n      var wind = windList.lastWind;       \r\n      while(wind != null) {\r\n        wind.pathPoint = null;\r\n        wind = wind.prevWind;\r\n      }           \r\n            \r\n      var vertex = path.firstVertex;\r\n      while(vertex != null) {\r\n        vertex.height = null;\r\n        vertex = vertex.nextVertex;\r\n      }      \r\n            \r\n      // Case: startHeight is undefined (equals null)      \r\n      if (this.boundaryHeights.startHeight == null) {\r\n        this.boundaryHeights.setFinalHeight(null);        \r\n        return;        \r\n      }\r\n          \r\n      var vertexA = path.firstVertex;      \r\n      var pointA = vertexA.getCoordinates();\r\n      vertexA.height = this.boundaryHeights.startHeight; \r\n            \r\n      // Skip winds without heights\r\n      // (remember that suface wind always exists)      \r\n      wind = windList.lastWind;\r\n      while(wind.getHeight() == null) {\r\n        wind = wind.prevWind;\r\n      }\r\n      \r\n      // Skip to wind corresponding to first (highest) vertex      \r\n      while(wind.getHeight() >= vertexA.height) {\r\n        \r\n        if (wind.getHeight() == vertexA.height) {\r\n          wind.pathPoint = pointA;  \r\n        }\r\n        if (wind == windList.firstWind) break;\r\n        \r\n        wind = wind.prevWind;\r\n      }\r\n\r\n      if (path.length == 1) return;        \r\n                                    \r\n      var vertex = vertexA.nextVertex;\r\n      while(vertex != null) {\r\n        vertex.height = null;\r\n        vertex = vertex.nextVertex;\r\n      } \r\n      \r\n      var vertexB = vertexA.nextVertex;\r\n                  \r\n      // Later, pointA can be any point of edge, \r\n      // pointB always will be vertex, \r\n      // pointA and pointB belong to the one edge \r\n      var pointB = vertexB.getCoordinates();      \r\n      var pointAHeight = vertexA.height;\r\n\r\n      var edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n      \r\n      while(true) {\r\n        \r\n        //console.log(\"edgeChuteDirection: \" + edgeChuteDirection); \r\n                \r\n        // edgeChuteVelocity is velocity along edge [pointA, pointB] at pointA.\r\n        // 'wind' is a wind in pointA. \r\n        // Our aim is to calculate height in pointB.       \r\n        var edgeChuteVelocity = \r\n          this.calculateChuteEdgeVelocity(\r\n            pointA, pointB, chute, wind, edgeChuteDirection\r\n          ); \r\n                                                                               \r\n        if (edgeChuteVelocity < 0) break;\r\n\r\n        // Case: chute is hanging above pointA\r\n        // This is top boundary of previous wind        \r\n        if (edgeChuteVelocity == 0) {\r\n          if (wind != windList.firstWind) {\r\n            pointAHeight = wind.getHeight();\r\n            wind.pathPoint = pointA;             \r\n            wind = wind.prevWind;            \r\n            continue;\r\n          } else break;          \r\n        }\r\n                                       \r\n        if (edgeChuteVelocity > 0) {\r\n          \r\n          var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n          var t1 = dist / edgeChuteVelocity;\r\n          \r\n          if (wind != windList.firstWind) {\r\n          \r\n            var t2 = (pointAHeight - wind.getHeight()) / chute.verticalVel;\r\n                        \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, chute will reach (vertex) pointB\r\n                                                                      \r\n              vertexB.height = pointAHeight - t1 * this.chute.verticalVel;\r\n                            \r\n              if (t2 == t1) {\r\n                wind.pathPoint = pointB;\r\n                wind = wind.prevWind;                \r\n              } \r\n                            \r\n              if (vertexB == path.lastVertex) break;\r\n              \r\n              vertexA = vertexB;\r\n              vertexB = vertexA.nextVertex;\r\n              \r\n              //pointA = vertexA.geometry.getCoordinates();\r\n              //pointB = vertexB.geometry.getCoordinates(); \r\n\r\n              pointA = vertexA.getCoordinates();\r\n              pointB = vertexB.getCoordinates(); \r\n\r\n              edgeChuteDirection = vertexA.nextEdge.getChuteDirection();              \r\n\r\n              pointAHeight = vertexA.height;  \r\n              \r\n              continue;\r\n              \r\n            } else {              \r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n              \r\n              pointA = VectorMath.findIntermediatePoint(\r\n                pointA, pointB, (t2 * edgeChuteVelocity)/dist\r\n              );\r\n              \r\n              pointAHeight -= t2 * this.chute.verticalVel;\r\n                            \r\n              wind.pathPoint = pointA;                                                                      \r\n              wind = wind.prevWind;\r\n              \r\n              continue;\r\n            }\r\n\r\n          } else {\r\n            // case: wind = windList.firstWind\r\n                        \r\n            if (t1 > Constant.maxFlightTime) break;\r\n                   \r\n            vertexB.height = pointAHeight - t1 * this.chute.verticalVel;\r\n                                    \r\n            if (vertexB.height == 0) {\r\n              wind.pathPoint = pointB;\r\n            }\r\n                             \r\n            if (pointAHeight > 0 && vertexB.height < 0) {                   \r\n              wind.pathPoint = \r\n                VectorMath.findIntermediatePoint(\r\n                  pointA, pointB,  pointAHeight/(pointAHeight - vertexB.height)\r\n                );              \r\n            }                 \r\n                                                                                  \r\n            if (vertexB == path.lastVertex) break;\r\n            \r\n            vertexA = vertexB;\r\n            vertexB = vertexA.nextVertex;\r\n            \r\n            pointA = vertexA.getCoordinates();\r\n            pointB = vertexB.getCoordinates();\r\n\r\n            edgeChuteDirection = vertexA.nextEdge.getChuteDirection();            \r\n\r\n            pointAHeight = vertexA.height;              \r\n\r\n            continue;                  \r\n          }          \r\n        }               \r\n      }\r\n      \r\n      this.boundaryHeights.setFinalHeight(path.lastVertex.height);       \r\n    }\r\n    \r\n\r\n    /**\r\n     * Case: back calculation.\r\n     * It calculates: 1) heights at vertices of Path,  \r\n     * 2) points on Path which corresponding to winds from WindList, \r\n     * 3) boundaryHeights.startHeight.    \r\n     */    \r\n    calculateHeightBack() {\r\n      \r\n      //console.log(\"back computation\");\r\n      \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n\r\n      var wind = windList.firstWind;       \r\n      while(wind != null) {\r\n        wind.pathPoint = null;\r\n        wind = wind.nextWind;\r\n      }           \r\n\r\n      var vertex = path.firstVertex;\r\n      while(vertex != null) {\r\n        vertex.height = null;\r\n        vertex = vertex.nextVertex;\r\n      }      \r\n      \r\n      // Case: finalHeight is undefined (equals null)\r\n      if (this.boundaryHeights.finalHeight == null) {\r\n        this.boundaryHeights.setStartHeight(null);        \r\n        return;    \r\n      }    \r\n                    \r\n      var vertexB = path.lastVertex;      \r\n      var pointB = vertexB.getCoordinates();\r\n      vertexB.height = this.boundaryHeights.finalHeight;\r\n      \r\n      wind = windList.firstWind;      \r\n      if (wind.getHeight() < vertexB.height) {\r\n        // that is, 0 < vertexB.height\r\n            \r\n        while(true) {\r\n                    \r\n          if (wind.nextWind == null) break;          \r\n          if (wind.nextWind.getHeight() == null) break;\r\n          \r\n          if (wind.nextWind.getHeight() > vertexB.height) break;\r\n          \r\n          if (wind.nextWind.getHeight() == vertexB.height) {\r\n            wind = wind.nextWind;\r\n            wind.pathPoint = pointB;\r\n            break;\r\n          }\r\n          \r\n          wind = wind.nextWind;          \r\n        }   \r\n      }  \r\n\r\n      if (path.length == 1) return;\r\n\r\n      var vertexA = vertexB.prevVertex;\r\n      \r\n      // pointA will always be vertex, \r\n      // pointB can be vertex or point on the edge      \r\n      var pointA = vertexA.getCoordinates();\r\n     \r\n      var pointBHeight = vertexB.height;\r\n\r\n      var edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n            \r\n      while(true) {\r\n         \r\n        // Note: here pointA is only for setting direction; \r\n        // if there will be changing wind on the edge, \r\n        // the chute will fly with following velocity only after \r\n        // last changing (in the direction, determined by \r\n        // vector pointApointB)        \r\n        var edgeChuteVelocity = \r\n          this.calculateChuteEdgeVelocity(\r\n            pointA, pointB, chute, wind, edgeChuteDirection\r\n          );\r\n        \r\n        //console.log(\"edgeChuteVelocity: \" + edgeChuteVelocity);\r\n        \r\n        // In this case it is impossible to flight this edge        \r\n        if (edgeChuteVelocity < 0) break;\r\n\r\n        // Case: chute is hanging above pointB.          \r\n        // This is bottom boundary of current wind        \r\n        if (edgeChuteVelocity == 0) {\r\n          \r\n          if (wind == windList.lastWind || wind.nextWind.getHeight() == null) {\r\n            break;\r\n          }                   \r\n          \r\n          wind = wind.nextWind;          \r\n          pointBHeight = wind.getHeight();                                      \r\n          wind.pathPoint = pointB;          \r\n          continue;                       \r\n        }\r\n                             \r\n        if (edgeChuteVelocity > 0) {\r\n          \r\n          if (wind != windList.lastWind && wind.nextWind.getHeight() != null) {\r\n          \r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n            var t1 = dist / edgeChuteVelocity;\r\n                         \r\n            var t2 = \r\n              (wind.nextWind.getHeight() - pointBHeight) / chute.verticalVel;\r\n          \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, pointB is reachable from pointA  \r\n            \r\n              //if (t1 > Constant.maxFlightTime) break;\r\n              \r\n              vertexA.height = pointBHeight + t1 * this.chute.verticalVel;\r\n              \r\n              if (\r\n                wind == windList.firstWind \r\n                && (pointBHeight < 0) \r\n                && (vertexA.height > 0) \r\n              ) {\r\n                wind.pathPoint = \r\n                  VectorMath.findIntermediatePoint(\r\n                    pointA, pointB,  vertexA.height/(vertexA.height - pointBHeight)\r\n                  );            \r\n              }               \r\n                  \r\n              if (vertexA == path.firstVertex) break;\r\n              \r\n              vertexB = vertexA;\r\n              vertexA = vertexB.prevVertex;\r\n              \r\n              pointA = vertexA.getCoordinates();\r\n              pointB = vertexB.getCoordinates();\r\n\r\n              pointBHeight = vertexB.height;\r\n              \r\n              edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n                                                               \r\n              continue;  \r\n            } else {\r\n\r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n                           \r\n              pointB = VectorMath.findIntermediatePoint(\r\n                pointB, pointA, (t2 * edgeChuteVelocity)/dist \r\n              ); \r\n             \r\n              pointBHeight += t2 * this.chute.verticalVel;\r\n                                                                      \r\n              wind = wind.nextWind;\r\n              wind.pathPoint = pointB;\r\n              \r\n              continue;\r\n            }\r\n          } else {  \r\n            // case: wind == windList.lastWind || wind.nextWind.getHeight() == null \r\n            \r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n            var t1 = dist / edgeChuteVelocity;\r\n            \r\n            if (t1 > Constant.maxFlightTime) break;\r\n                                    \r\n            vertexA.height = pointBHeight + (t1 * this.chute.verticalVel);\r\n\r\n            if (\r\n              wind == windList.firstWind \r\n              && (pointBHeight < 0) \r\n              && (vertexA.height > 0) \r\n            ) {\r\n              wind.pathPoint = \r\n                VectorMath.findIntermediatePoint(\r\n                  pointA, pointB,  vertexA.height/(vertexA.height - pointBHeight)\r\n                );            \r\n            } \r\n                                                                      \r\n            if (vertexA == path.firstVertex) break;\r\n            \r\n            vertexB = vertexA;\r\n            vertexA = vertexB.prevVertex;\r\n            \r\n            pointA = vertexA.getCoordinates();\r\n            pointB = vertexB.getCoordinates(); \r\n\r\n            pointBHeight = vertexB.height;            \r\n\r\n            edgeChuteDirection = vertexA.nextEdge.getChuteDirection();\r\n            \r\n            continue;                     \r\n          }\r\n        }                                \r\n      }\r\n\r\n      this.boundaryHeights.setStartHeight(path.firstVertex.height);         \r\n      return;      \r\n    }\r\n\r\n    \r\n    /** \r\n     * Calculate Absolute (relatively to Earth) Chute Velocity \r\n     * along Line Segment (we suppose that chute is flying along this line segment).\r\n     * @param {number[]} pointA - Yandex Maps Coordinates: (latitude, longitude).\r\n     * @param {number[]} pointB - Yandex Maps Coordinates: (latitude, longitude). \r\n     * @param {Chute} chute \r\n     * @param {Wind} wind\r\n     * @param [boolean] edgeChuteDirection - Skydiver can fly with his face directed \r\n     * with or against edge.      \r\n     * @return {number} chuteEdgeVelocity - Absolute Chute Velocity along \r\n     * line segment [pointA, pointB]; in m/sec; \r\n     * Cases: chuteEdgeVelocity < 0 - If it is impossible to fly this segment;\r\n     * chuteEdgeVelocity == 0 - hanging above pointA all time;    \r\n     * chuteEdgeVelocity > 0 - chute will fly from pointA to pointB.\r\n     */    \r\n    calculateChuteEdgeVelocity(\r\n      pointA, pointB, chute, wind, edgeChuteDirection = true\r\n    ) {\r\n          \r\n      // Let's find right orthonormal basis (e, f), first vector of which (e)\r\n      // has the same direction with vector [pointA, pointB].      \r\n      // Yandex Maps Coordinates: (latitude, longitude)\r\n      // Latitude is increasing from bottom to top (-90deg, 90deg)\r\n      // Longitude is increasing from West to East (-180deg, 180deg)\r\n            \r\n      function sign(a) {\r\n        if (a>0) return 1;\r\n        if (a==0) return 0;\r\n        return -1;\r\n      }      \r\n      \r\n      var sx = sign(pointB[1] - pointA[1]);\r\n      var sy = sign(pointB[0] - pointA[0]);       \r\n    \r\n      var pointC = [pointA[0], pointB[1]];\r\n      \r\n      // now (ex, ey) are coordinates of vector e in standart orthonormal basis:\r\n      // x has direction from left to right, \r\n      // y has direction from bottom to top, \r\n      // scale: 1 meter\r\n      var ex = sx * ymaps.coordSystem.geo.getDistance(pointC, pointA);\r\n      var ey = sy * ymaps.coordSystem.geo.getDistance(pointC, pointB);\r\n                \r\n      var d = Math.sqrt(ex*ex + ey*ey);\r\n      ex = ex / d;\r\n      ey = ey / d;\r\n      \r\n      var fx = -ey;\r\n      var fy = ex;\r\n      \r\n      // Let's find coordinates (we, wf) of vector 'wind' in basis (e, f).\r\n      // (e, f) is orthogonal basis, so we = (wind, e), wf = (wind, f).\r\n      var [wx, wy] = wind.getXY();\r\n   \r\n      var we = wx * ex + wy * ey; \r\n      var wf = wx * fx + wy * fy;     \r\n       \r\n      // Let's find coordinates (ce, cf) of chute velocity \r\n      // in basis (e, f):\r\n      \r\n      var cf = (-1)*wf;\r\n      \r\n      // it is impossible to fly this segment\r\n      if (chute.horizontalVel < Math.abs(cf)) return(-1);\r\n  \r\n      var directionSign = edgeChuteDirection ? 1 : -1; \r\n  \r\n      var ce = directionSign * Math.sqrt(chute.horizontalVel**2 - cf**2);\r\n      \r\n      // We consider only case, where ce >= 0 \r\n      // (it's always the case, if chute velocity is greater than wind velocity)    \r\n      // In general case you should consider case, \r\n      // when ce < 0 (case when diver flies forward with his back)   \r\n\r\n      var chuteEdgeVelocity = ce + we;\r\n      return(chuteEdgeVelocity);       \r\n    }   \r\n  }\r\n      \r\n  provide(Calculator);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Calculator.js?");

/***/ }),

/***/ "./src/scripts/Chute.js":
/*!******************************!*\
  !*** ./src/scripts/Chute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Chute', [],\r\nfunction(provide) {\r\n\r\n  class Chute {\r\n    /**\r\n     * @param {number} horizontalVel - Horizontal chute velocity, in m/sec.\r\n     * @param {number} verticalVel - Vertical chute velocity, in m/sec.     \r\n     */\r\n    constructor(horizontalVel, verticalVel) {\r\n      this.horizontalVel = horizontalVel; \r\n      this.verticalVel = verticalVel;   \r\n    }   \r\n  }\r\n      \r\n  provide(Chute);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Chute.js?");

/***/ }),

/***/ "./src/scripts/Constant.js":
/*!*********************************!*\
  !*** ./src/scripts/Constant.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Constant */\r\nymaps.modules.define('Constant', [],\r\nfunction(provide) {\r\n\r\n// Determine mobile or desktop case.\r\nvar isMobile = false;\r\nif(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\r\n  isMobile = true;\r\n}\r\n  /** These varialables are constants for app */\r\n  var Constant = {\r\n    defaultStartHeight: 300,\r\n    defaultFinalHeight: 0,\r\n    defaultZoom: 16,\r\n    defaultCalculationDirection: true,  \r\n    // We will not consider cases when horizontal velocity\r\n    // is more than maxChuteHorizontalVelocity\r\n    maxChuteHorizontalVelocity: 100,  // wingsuit\r\n    maxChuteVerticalVelocity: 50,  // free fall\r\n    maxHeight: 10000,\r\n    maxWindValue: 40,\r\n    // If we will fly more than maxFlightTime, then\r\n    // it is impossible to fly this path\r\n    maxFlightTime: 3600, // 1 hour\r\n    isMobile: isMobile\r\n  }\r\n\r\n  provide(Constant);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Constant.js?");

/***/ }),

/***/ "./src/scripts/DialogWindows.js":
/*!**************************************!*\
  !*** ./src/scripts/DialogWindows.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('DialogWindows', ['Constant'],\r\nfunction(provide, Constant) {\r\n\r\n  var DialogWindows = {};\r\n  /**\r\n   * @param {Calculator} calculator\r\n   */\r\n\r\n  DialogWindows.initMenu = function(calculator) {\r\n    \r\n    var path = calculator.path;\r\n        chute = calculator.chute;\r\n        windList = calculator.windList;\r\n        boundaryHeights = calculator.boundaryHeights;    \r\n    var map = path.map;    \r\n\r\n    // First active link in Menu will be Dz link  \r\n    this.prevLinkId = 'dzLink';\r\n\r\n\r\n\r\n    initMenuWindow();\r\n    initDzWindow();\r\n    initChuteWindow();\r\n    initPathWindow();\r\n    initHeightWindow();\r\n    initWindWindow();\r\n\r\n    \r\n    /**\r\n     * Settings Menu initialization\r\n     */\r\n    function initMenuWindow() {\r\n\r\n      $('#dzLinkContent').css('display', 'block');\r\n      $('#dzLink').addClass('active');\r\n\r\n      $('nav a').on('click', function(e) {\r\n        e.preventDefault();\r\n\r\n        let currentLinkId = $(this).attr('id');\r\n\r\n        $('#' + DialogWindows.prevLinkId + \"Content\").css('display', 'none');\r\n        $('#' + currentLinkId + \"Content\").css('display', 'block');\r\n\r\n        $('#' + DialogWindows.prevLinkId).removeClass('active');\r\n        $(this).addClass('active');\r\n            \r\n        DialogWindows.prevLinkId = currentLinkId;\r\n      })\r\n\r\n\r\n      // Close Settings Menu after clicking Cross or Dark screen\r\n      $(\"#settingsMenuHeaderRectangle, #settingsMenuDarkScreenClickable\").click(function() {\r\n        \r\n        $(\"#settingsMenuDarkScreen\").css(\"left\", \"-100%\");\r\n\r\n        if (window.matchMedia(\"(min-width: 768px)\").matches) {\r\n          $(\"#settingsMenu\").css(\"left\", \"-50%\");  \r\n        } else {\r\n          $(\"#settingsMenu\").css(\"left\", \"-100%\");              \r\n        }\r\n      });   \r\n\r\n    }\r\n\r\n  \r\n    /**\r\n     * Dz Window initialization\r\n     */\r\n    function initDzWindow() {\r\n      // Set default options: dz array\r\n      for(var i=0; i<map.dz.length; i++) {\r\n        $(\"#dz\").append(\"<option>\" + map.dz[i].name + \"</option>\");    \r\n      }\r\n      \r\n      $(\"#dz\").on(\"change\", function() {\r\n        var mapCenter = map.dz[this.selectedIndex].mapCenter;      \r\n        map.setCenter(mapCenter, Constant.defaultZoom);\r\n        //windList.shiftList(mapCenter);\r\n        map.arrow.setCoordinates(mapCenter);                \r\n        // path.clear() will print results too\r\n        path.clear();\r\n      });\r\n    }\r\n\r\n\r\n    /** \r\n     * Chute Window initialization.\r\n     */\r\n    function initChuteWindow() {\r\n      $(\"#chutehorvel\").val(chute.horizontalVel);\r\n      $(\"#chutevervel\").val(chute.verticalVel);\r\n    \r\n      $(\"#chutehorvel, #chutevervel\").on(\"change\", function () {      \r\n        var chutehorvel = Number.parseFloat($(\"#chutehorvel\").val());\r\n        if ((chutehorvel>=0) && (chutehorvel<=Constant.maxChuteHorizontalVelocity)) {\r\n          chute.horizontalVel = chutehorvel;\r\n        }\r\n        $(\"#chutehorvel\").val(chute.horizontalVel);\r\n                     \r\n        var chutevervel = Number.parseFloat($(\"#chutevervel\").val());\r\n        if (( chutevervel>=0) && (chutevervel<=Constant.maxChuteVerticalVelocity)) {\r\n          chute.verticalVel = chutevervel;    \r\n        } \r\n        $(\"#chutevervel\").val(chute.verticalVel);        \r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();              \r\n        }\r\n      });\r\n    }    \r\n\r\n\r\n    /** \r\n     * Path Window initialization.\r\n     */  \r\n    function initPathWindow() {            \r\n      $(\"#pathDirection\").change(function() {\r\n        var isChecked = $(this).prop(\"checked\");\r\n        path.setPathDirection(!isChecked);                \r\n      }); \r\n    }    \r\n              \r\n    \r\n    /**\r\n     * This function is empty.\r\n     * All work is made in BoudaryHeights class.\r\n     * In the future that part of BoundaryHeights class \r\n     * should be transpose to this function. \r\n     */\r\n    function initHeightWindow() {\r\n    }\r\n\r\n\r\n\r\n    /** \r\n     * Wind Window initialization.\r\n     */    \r\n    function initWindWindow() {\r\n\r\n      drawWindScreen();\r\n\r\n      /**\r\n       * Draw WindScreen window in Wind Menu\r\n       */\r\n      function drawWindScreen() {\r\n        $(\"#windInput\").addClass(\"displayNone\");\r\n        $(\"#windScreen\").removeClass(\"displayNone\");\r\n\r\n        var windTable = document.getElementById(\"windTable\"); \r\n        windTable.innerHTML = '';    \r\n        var wind = windList.firstWind;windList\r\n        for(var i=0; i < windList.numberOfWinds; i++) {\r\n          var row = windTable.insertRow(i);\r\n          wind.rowClickEvent = row.addEventListener(\"click\", createRowClickListener(wind));\r\n          var cell1 = row.insertCell(0);\r\n          var cell2 = row.insertCell(1);\r\n          var cell3 = row.insertCell(2);\r\n          cell1.innerHTML = (wind.height == null)? \"?\" : wind.height + \" м\";      \r\n          cell2.innerHTML = '<div class=\\\"arrow\\\"></div>';\r\n          cell2.firstChild.style.transform = \"rotate(\" + (-1)*wind.getAngle() + \"deg)\";\r\n          cell3.innerHTML = wind.value + \" м/c\";\r\n          wind = wind.nextWind;\r\n          //if (wind == null) break;\r\n        } \r\n      }\r\n\r\n      function createRowClickListener(w) {\r\n        return (function(e) {\r\n          $(\"#windScreen\").addClass(\"displayNone\");\r\n          windList.currentWind = w;\r\n          $(\"#windInput\").removeClass(\"displayNone\");\r\n          //windList.printCurrentWindWindow();\r\n          drawWindInput();    \r\n        }); \r\n      }\r\n\r\n      // Button Add Wind in WindScreen window\r\n      $(\"#addWind\").click(function() {\r\n        windList.addWind();\r\n        drawWindInput();\r\n      });\r\n\r\n      \r\n      /**\r\n       * Draw WindInput window in Wind Menu\r\n       */\r\n      function drawWindInput() {\r\n        $(\"#windScreen\").addClass(\"displayNone\");\r\n        $(\"#windInput\").removeClass(\"displayNone\");\r\n\r\n        if (windList.currentWind == windList.firstWind) {\r\n          $(\"#windHeightInput\").prop(\"disabled\", true);\r\n          //$(\"#removeWind\").prop(\"disabled\", true);   \r\n          $(\"#removeWind\").addClass(\"displayNone\");       \r\n        } else {\r\n          $(\"#windHeightInput\").prop(\"disabled\", false);\r\n          //$(\"#removeWind\").prop(\"disabled\", false);\r\n          $(\"#removeWind\").removeClass(\"displayNone\");\r\n        }\r\n        $(\"#windHeightInput\").val(windList.currentWind.getHeight());    \r\n        $(\"#windDirectionInput\").val(windList.currentWind.getAngle());\r\n        $(\"#windValueInput\").val(windList.currentWind.getValue());\r\n        //$(\"#arrowScale\").prop(\"checked\", this.currentWind.arrow.getIsScaled());\r\n        var angle = windList.currentWind.getAngle();\r\n        $(\"#menuArrow\").css(\"transform\", \"rotate(\" + (-1)*angle + \"deg)\");\r\n        $(\"#menuWindValue\").html(windList.currentWind.getValue() + \" м/с\");      \r\n      }              \r\n\r\n\r\n      // Button 'Back to WindScreen' in WindInput window\r\n      $(\"#windInputHeaderArrowRectangle\").click(function() {\r\n        if (windList.currentWind.height == null) {\r\n          windList.removeWind();\r\n        }\r\n        drawWindScreen();\r\n      });\r\n\r\n      // Button 'Remove current wind' in WindInput window\r\n      $(\"#removeWind\").click(function() {\r\n        windList.removeWind();\r\n        drawWindScreen();\r\n      });\r\n\r\n          \r\n      // Input for WindHeight in WindInput window  \r\n      $(\"#windHeightInput\").on(\"change\", function() {        \r\n        // Remember that #windHeightInput is disabled for firstWind\r\n        \r\n        // If we jump to firstWind by use of Tab button (our app has such \r\n        // possibility), it will call windList.setHeightToCurrentWind (it will be error).\r\n        if (windList.currentWind == windList.firstWind) return;\r\n        \r\n        var s = $(\"#windHeightInput\").val();        \r\n        var n = Number.parseFloat(s);\r\n        \r\n        if ((n > 0) && (n <= Constant.maxHeight)) { \r\n          if (windList.setHeightToCurrentWind(n)) { \r\n            $(\"#windHeightInput\").val(n);\r\n          } else {\r\n            var v = windList.currentWind.getHeight();\r\n            var w = (v == null) ? '' : v;             \r\n            $(\"#windHeightInput\").val(w);\r\n            alert(\"Такая высота уже была!\");            \r\n          }            \r\n        } else {\r\n          var v = windList.currentWind.getHeight();\r\n          var w = (v == null) ? '' : v;             \r\n          $(\"#windHeightInput\").val(w);\r\n          if (n == 0) {\r\n            alert(\"Поверхностный ветер уже задан!\");\r\n          } else {\r\n            alert(\"Значение не попадает в допустимый интервал!\");\r\n          }\r\n        } \r\n                        \r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();          \r\n        }        \r\n      });\r\n      \r\n                       \r\n      // Range Input Slider for Wind Direction in WindInput window.  \r\n      $(\"#windDirectionInput\").on('input change', function() {\r\n        var angleStr = $(\"#windDirectionInput\").val();          \r\n        var angle = Number.parseInt(angleStr);\r\n        \r\n        windList.setCurrentAngle(angle);\r\n        //windList.printCurrentWindWindow();\r\n        //var angle = windList.currentWind.getAngle();\r\n        $(\"#menuArrow\").css(\"transform\", \"rotate(\" + (-1)*angle + \"deg)\");\r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();           \r\n        }            \r\n      });\r\n\r\n\r\n      $(\"#windValueInput\").prop(\"max\", \"\" + Constant.maxWindValue);\r\n\r\n      // Range Input Slider for  Wind Value in WindInput window.   \r\n      $(\"#windValueInput\").on('input change', function() {\r\n        var valueStr = $(\"#windValueInput\").val();\r\n        var value = Number.parseInt(valueStr);\r\n\r\n        windList.setCurrentValue(value);\r\n        //windList.printCurrentWindWindow();\r\n        $(\"#menuWindValue\").html(value + \" м/с\");\r\n        \r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();          \r\n        }       \r\n      });\r\n      \r\n      // Draw scales for Range Input Sliders in WindInput window    \r\n      drawWindScales();\r\n      \r\n      /*      \r\n      $(\"#arrowScale\").prop(\"checked\", windList.firstWind.arrow.getIsScaled());\r\n      \r\n      $(\"#arrowScale\").change(function() {\r\n        var isChecked = $(this).prop(\"checked\");\r\n        windList.currentWind.arrow.setArrowToBeScaled(isChecked);               \r\n      });   */\r\n      \r\n      /*\r\n      function initWindWindow() {\r\n        if (windList.currentWind == windList.firstWind) {\r\n          $(\"#windHeightInput\").prop(\"disabled\", true);        \r\n        } else {\r\n          $(\"#windHeightInput\").prop(\"disabled\", false);\r\n        }\r\n        $(\"#windHeightInput\").val(windList.currentWind.getHeight());    \r\n        $(\"#windDirectionInput\").val(windList.currentWind.getAngle());\r\n        $(\"#windValueInput\").val(windList.currentWind.getValue());  \r\n        //$(\"#arrowScale\").prop(\"checked\", windList.currentWind.arrow.getIsScaled());        \r\n      }         */   \r\n\r\n    }\r\n   \r\n    /**\r\n     * Draw scales for Wind Window:\r\n     *   wind direction scale (E, N, W, S, E),\r\n     *   wind velocity scale (0, ..., Constant.maxWindValue m/s)\r\n     */\r\n    function drawWindScales() {\r\n\r\n      // Create legend for direction range input\r\n      var directionPlateSpan = 5;\r\n      var directionPlateNumber = 4*directionPlateSpan + 1;\r\n      var windValuePlateNumber = 0;\r\n      \r\n      for(var i=0; i<directionPlateNumber; i++) {\r\n        var str = \"\";\r\n        switch (i) {\r\n          case 0: \r\n            str = \"В\";\r\n            break;\r\n          case directionPlateSpan: \r\n            str = \"С\";\r\n            break;\r\n          case directionPlateSpan*2: \r\n            str = \"З\";\r\n            break;      \r\n          case directionPlateSpan*3: \r\n            str = \"Ю\";\r\n            break;\r\n          case directionPlateSpan*4: \r\n            str = \"В\";\r\n            break;\r\n          default:\r\n            str = \"&nbsp\";          \r\n        }\r\n        $(\"#windDirectionInputScale\").append(\"<div class='directionPlate'>\" + str + \"</div>\");\r\n    \r\n        var str2;        \r\n        if (i % 5 == 0) {\r\n          str2 = windValuePlateNumber;\r\n          windValuePlateNumber += (Constant.maxWindValue / 4);\r\n        } else {\r\n          str2 = \"&nbsp\";\r\n        }        \r\n        $(\"#windValueInputScale\").append(\"<div class='directionPlate'>\" + str2 + \"</div>\");\r\n       \r\n      }\r\n      $(\".directionPlate\").css({\r\n        \"width\": 100/(directionPlateNumber) + \"%\",\r\n        \"float\": \"left\", \r\n        \"text-align\": \"center\"\r\n      });     \r\n    }     \r\n  }\r\n\r\n  provide(DialogWindows);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/DialogWindows.js?");

/***/ }),

/***/ "./src/scripts/Edge.js":
/*!*****************************!*\
  !*** ./src/scripts/Edge.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Edge', [\r\n  'Polygon', \r\n  'VectorMath'  \r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n  /**\r\n   * PathEdge consists of two Rectangles: \r\n   * Image Rectangle and Invisible Event Rectangle.\r\n   * Invisible Event Rectangle is aimed for catching events \r\n   * (we use it to make GUI more friendly for Users in mobile case). \r\n   */\r\n  class Edge {    \r\n    /**\r\n     * @param {Vertex} prevVertex\r\n     * @param {Vertex} nextVertex\r\n     * @param {Path} edgeImageWidthWidth\r\n     * @param {boolean} chuteDirection      \r\n     */\r\n    constructor(\r\n      prevVertex, \r\n      nextVertex,\r\n      path, \r\n      chuteDirection = true\r\n    ) {\r\n\r\n      this.prevVertex = prevVertex;\r\n      this.nextVertex = nextVertex;\r\n      this.path = path; \r\n      // true - if Chute motion and Edge has the same direction\r\n      this.chuteDirection = chuteDirection;\r\n\r\n      this.edgeWidth = path.edgeEventRectangleWidth; // edgeWidth; \r\n      this.edgeImageWidth = this.edgeWidth / 10; // edgeImageWidth;\r\n\r\n      // Edge connects prevVertex, nextVertex, itself.\r\n      prevVertex.nextVertex = nextVertex;\r\n      prevVertex.nextEdge = this;\r\n      nextVertex.prevVertex  = prevVertex;\r\n      nextVertex.prevEdge = this;\r\n      \r\n      var zIndex = 0;\r\n\r\n      // Rectangle vertices will be calculated later\r\n      this.eventRectangle = new Polygon([], {}, {\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: zIndex\r\n      });\r\n\r\n      var color = this.getColor();\r\n      \r\n      this.image = new Polygon([], {}, {\r\n        fillColor: color,\r\n        strokeColor: color, \r\n        zIndex: (zIndex - 1)        \r\n      });\r\n            \r\n      this.calculateEdgeRectangles();\r\n      \r\n      this.clickNumber = 0;\r\n\r\n      this.edgeIsOnMap = false;\r\n\r\n      //this.processVertexClick = this.processVertexClick.bind(this);\r\n      \r\n      this.eventRectangle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick(e);\r\n      }.bind(this));      \r\n    }\r\n\r\n    \r\n    scale(scale) {\r\n      this.edgeWidth *= scale;\r\n      this.edgeImageWidth *= scale;\r\n      this.calculateEdgeRectangles();\r\n    }\r\n\r\n    \r\n    addToMap() {\r\n      if (!this.edgeIsOnMap) {\r\n        this.path.map.geoObjects.add(this.eventRectangle);         \r\n        this.path.map.geoObjects.add(this.image);    \r\n        this.edgeIsOnMap = true;\r\n      }\r\n    }\r\n\r\n    removeFromMap() {\r\n      if (this.edgeIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.eventRectangle);         \r\n        this.path.map.geoObjects.remove(this.image);    \r\n        this.edgeIsOnMap = false;\r\n      }\r\n    }\r\n\r\n\r\n    getChuteDirection() {\r\n      return this.chuteDirection;\r\n    }\r\n    \r\n    getColor() {\r\n      var color = this.chuteDirection ? \"#0000FF\" : \"#000050\";\r\n      return color;\r\n    }\r\n\r\n    /**\r\n     * Process both click and dblclick on this edge.\r\n     * Single clicking is for adding new Vertex. \r\n     * Double clicking is for changing chute direction \r\n     * on this edge (skydiver can fly with his face directed \r\n     * with or against edge).\r\n     */       \r\n    processVertexClick(e) {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (this.clickNumber == 1) {  // Single Click (add Vertex)\r\n            this.divideEdge(e);                           \r\n            this.clickNumber = 0;\r\n          } else {   \r\n            if (this.clickNumber == 2) {  // Double Click (change chute direction)\r\n              this.chuteDirection = !this.chuteDirection;        \r\n              let color = this.getColor();              \r\n              this.image.options.set(\"fillColor\", color);\r\n              this.image.options.set(\"strokeColor\", color);                            \r\n              this.clickNumber = 0;\r\n              \r\n              this.path.calculator.calculateHeight();\r\n              this.path.printHeightsAndWindPoints();              \r\n            }             \r\n          }  \r\n        }.bind(this), 200);\r\n      }  \r\n    }    \r\n\r\n      \r\n    /**    \r\n     * Here we calculate projection of point = e.get('coords') to \r\n     * line segment {this.pointA, this.pointB} and then \r\n     * send that projection to path.divideEdge.     \r\n     * @param {Event} e\r\n     */\r\n    divideEdge(e) {\r\n                \r\n      var point = e.get('coords');\r\n      \r\n      var pointA = this.prevVertex.getCoordinates(), \r\n          pointB = this.nextVertex.getCoordinates();\r\n              \r\n      var vector1 = VectorMath.subVectors(point, pointA), \r\n          vector2 = VectorMath.subVectors(pointB, pointA);\r\n      vector2 = VectorMath.normaliseVector(vector2);                \r\n      var c = VectorMath.scalarProduct(vector1, vector2);        \r\n      var vector3 = VectorMath.multVectorConstant(vector2, c);\r\n      \r\n      var point2 = VectorMath.addVectors(pointA, vector3);\r\n                            \r\n      this.path.divideEdge(this, point2);    \r\n    }\r\n        \r\n    /**\r\n     * Run this function when geometric parameters of prevVertex or nextVertex are changed. \r\n     * It will recalculate Edge parameters.\r\n     */\r\n    calculateEdgeRectangles() {\r\n      var pointA = this.prevVertex.getCoordinates();\r\n      var pointB = this.nextVertex.isTriangleVertex ?   \r\n        this.nextVertex.image.getEdgePoint() : this.nextVertex.getCoordinates();\r\n      \r\n      var vertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeWidth);\r\n\r\n      this.eventRectangle.geometry.setCoordinates([vertices]);        \r\n      \r\n      var imageVertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeImageWidth);\r\n\r\n      this.image.geometry.setCoordinates([imageVertices]);           \r\n    }\r\n\r\n              \r\n    /**\r\n     * @param {number} width - Width of Rectangle, in meters. \r\n     */    \r\n    calculateRectangleVertices (pointA, pointB, width) {\r\n                  \r\n      var latitude = pointA[0],\r\n          geodesicVectorAB = VectorMath.subVectors(pointB, pointA);\r\n\r\n      var cartVectorAB = \r\n            VectorMath.toLocalVector(geodesicVectorAB, latitude);         \r\n\r\n      var v = VectorMath.normaliseVector(cartVectorAB);\r\n      \r\n      var w = [(-v[1])*width , v[0]*width];\r\n            \r\n      var wg = VectorMath.toGeodesicVector(w, latitude);\r\n      var wwg = [wg[0]*(-1), wg[1]*(-1)];\r\n      \r\n      var vertices = [];  \r\n      vertices[0] = VectorMath.addVectors(pointA, wg);\r\n      vertices[1] = VectorMath.addVectors(pointB, wg);\r\n      vertices[2] = VectorMath.addVectors(pointB, wwg); \r\n      vertices[3] = VectorMath.addVectors(pointA, wwg);       \r\n                  \r\n      return vertices;  \r\n    }              \r\n  } \r\n  provide(Edge);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Edge.js?");

/***/ }),

/***/ "./src/scripts/MenuButton.js":
/*!***********************************!*\
  !*** ./src/scripts/MenuButton.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('MenuButton', [\r\n  'control.Button'       \r\n],\r\nfunction(provide, Button) {\r\n  /**\r\n   * MenuButton creates Yandex.Maps API Button.\r\n   * If you click this Button, then CSS property \r\n   * 'left' of two DOM elements (Element1 with jQuerySelector1 and \r\n   *  Element2 with jQuerySelector2) will be set to be 0. \r\n   * @extends control.Button\r\n   */\r\n  class MenuButton extends Button {\r\n    /**\r\n     * @param {string} [title] - Button hint.\r\n     * @param {string} [image] - Src for <img> tag of this button.\r\n     * @param {string} [jQuerySelector1] - jQuery selector for Element1. \r\n     * @param {string} [jQuerySelector2] - jQuery selector for Element2. \r\n     * @param {string} [cssclass] - Css for this button.          \r\n     */ \r\n    constructor(\r\n      title, \r\n      image, \r\n      jQuerySelector1,\r\n      jQuerySelector2,\r\n      cssclass='inputControlElement' \r\n    ) {\r\n      super({\r\n        data: {\r\n          title: title,\r\n          image: image, \r\n          cssclass: cssclass        \r\n        },  \r\n        options: {\r\n          layout: ymaps.templateLayoutFactory.createClass(\r\n            \"<div title='{{data.title}}' class='{{data.cssclass}}'>\" + \r\n              \"<img class='iconimage' src='{{data.image}}'>\" +           \r\n            \"</div>\"\r\n          ),\r\n          maxWidth: 300\r\n        }\r\n      });\r\n                      \r\n      // Result of this Button clicking\r\n      this.events.add('click', function() {         \r\n        $(jQuerySelector2).css(\"left\", \"0\");\r\n        $(jQuerySelector1).css(\"left\", \"0\");      \r\n      });    \r\n    }        \r\n  } \r\n  provide(MenuButton);  \r\n});\r\n\n\n//# sourceURL=webpack:///./src/scripts/MenuButton.js?");

/***/ }),

/***/ "./src/scripts/OutputElement.js":
/*!**************************************!*\
  !*** ./src/scripts/OutputElement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('OutputElement', [\r\n  'control.Button', \r\n  'templateLayoutFactory'  \r\n],\r\nfunction(provide, Button, templateLayoutFactory) {\r\n  \r\n  class OutputElement extends Button {\r\n    /**\r\n     * @param {string} content   \r\n     */\r\n    constructor(content='') {\r\n      \r\n      super({\r\n        data: {content: content},  \r\n          \r\n        options: {\r\n          layout: templateLayoutFactory.createClass(\r\n            \"<div class='outputControlElement'>{{data.content}}</div>\"\r\n          ),\r\n         maxWidth: 300 \r\n        }\r\n      });           \r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} str \r\n     */\r\n    print(str) {\r\n      this.data.set('content', str);   \r\n    }\r\n  } \r\n  provide(OutputElement);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/OutputElement.js?");

/***/ }),

/***/ "./src/scripts/Path.js":
/*!*****************************!*\
  !*** ./src/scripts/Path.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Path', [\r\n  'Vertex',\r\n  'Edge',\r\n  'Constant'\r\n],\r\nfunction(\r\n  provide,\r\n  Vertex,\r\n  Edge,\r\n  Constant\r\n) {\r\n  /**\r\n   * List of Vertices and Edges.\r\n   * Image of Last Vertex is Triangle. Images of other Vertices are Circles.\r\n   */\r\n  class Path {\r\n    /**\r\n     * @param {Map} map - link to Yandex map.\r\n     */\r\n    constructor(map) {\r\n      this.map = map;\r\n      this.firstVertex = null;\r\n      this.lastVertex = null;\r\n      // number of vertices\r\n      this.length = 0;\r\n\r\n      // If pathDirection is true, we add new vertex to the start of Path;\r\n      // if false, we add it to end of Path.\r\n      this.pathDirection = true;\r\n\r\n      // Radius of Circle Image of Vertices, in meters\r\n      this.vertexRadius = Constant.isMobile ? 4 : 4;\r\n      // Define size of Triangle Image of Vertices\r\n      this.triangleScale = 1;\r\n      // Radius for Event Circle of Vertices, in meters\r\n      this.vertexEventRadius = Constant.isMobile ? 6*this.vertexRadius : 3*this.vertexRadius;\r\n      // Width of Event Rectangle of Edges\r\n      this.edgeEventRectangleWidth = 1;\r\n\r\n      // On the map: line segments should be under vertex images,\r\n      // vertex images should be under vertices\r\n      this.vertexZIndex = 2;\r\n      this.vertexImageZIndex = 1;\r\n      this.edgeZIndex = 0;\r\n      this.edgeImageZIndex = -1;\r\n\r\n      // Distance from vertex to it's heightPlacemark\r\n      //this.heightPlacemarkShift = 0.0002;\r\n\r\n      this.calculator = null;\r\n\r\n      this.pathBoundChange = this.pathBoundChange.bind(this);   \r\n\r\n      this.map.events.add('boundschange', this.pathBoundChange);\r\n\r\n    }\r\n\r\n\r\n    pathBoundChange(e) {\r\n      //console.log(\"Scale is changed\");\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        //var scale = (2**(newZoom - Constant.defaultZoom));\r\n        var scale = (2**(oldZoom - newZoom));\r\n        //console.log('scale: ' + scale);\r\n        this.scale(scale);\r\n      }\r\n    }\r\n\r\n\r\n    scale(scale) {\r\n      this.vertexRadius *= scale;\r\n      this.vertexEventRadius *= scale;\r\n      this.edgeEventRectangleWidth *= scale;\r\n      this.triangleScale *= scale;\r\n      if (this.length > 0 ) {\r\n        var vertex = this.lastVertex;\r\n        vertex.scale(scale);\r\n        for(var i=1; i < this.length; i++) {\r\n          vertex = vertex.prevVertex;\r\n          vertex.scale(scale);\r\n          vertex.nextEdge.scale(scale);\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n\r\n    setPathDirection(pathDirection) {\r\n      this.pathDirection = pathDirection;\r\n    }\r\n\r\n    getPathDirection() {\r\n      return(this.pathDirection);\r\n    }\r\n\r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n\r\n    setHeightOutput(heightOutput) {\r\n      this.heightOutput = heightOutput;\r\n    }\r\n\r\n    /**\r\n     * Add new Vertex to Path and to Map.\r\n     * Add corresponding Edge to Path and to Map.\r\n     * @param {number[]} point - Yandex.Maps coordinates, point = [x, y].\r\n     * @return {Array} New Last Vertex and new Vast Edge of Path.\r\n     */\r\n    addVertex(point) {\r\n\r\n      var vertex = new Vertex(point, this.vertexEventRadius, this);\r\n\r\n      var edge = null;\r\n\r\n      if (this.length > 0) {\r\n\r\n        if (this.pathDirection) {\r\n          // We should add vertex to the end of path\r\n\r\n          var lastPoint = this.lastVertex.getCoordinates();\r\n          vertex.setTriangleVertex(lastPoint);\r\n\r\n          edge = new Edge(this.lastVertex, vertex, this);\r\n\r\n          if (this.length > 1) {\r\n            this.lastVertex.setCircleVertex(this.vertexRadius);\r\n            this.lastVertex.prevEdge.calculateEdgeRectangles(); \r\n          }  \r\n\r\n          this.lastVertex = vertex;          \r\n        } else {\r\n          // We should add vertex to the beginning of path\r\n\r\n          vertex.setCircleVertex(this.vertexRadius);\r\n\r\n          if (this.length == 1) {\r\n            this.firstVertex.setTriangleVertex(point);\r\n          } \r\n\r\n          edge = new Edge(vertex, this.firstVertex, this);\r\n      \r\n          this.firstVertex = vertex;\r\n        }\r\n\r\n        edge.addToMap();\r\n\r\n      } else {  // this.length == 0;        \r\n        this.firstVertex = vertex;\r\n        this.lastVertex = vertex;\r\n        vertex.setCircleVertex(this.vertexRadius);\r\n      }\r\n      \r\n      vertex.addToMap();\r\n\r\n      this.length++;\r\n\r\n      this.calculator.calculateHeight();\r\n      this.printHeightsAndWindPoints();\r\n\r\n      return([vertex, edge]);\r\n    }\r\n\r\n\r\n    /**\r\n     * Divide Edge by point.\r\n     * Point should be on that Edge.\r\n     * @param {Edge} edge\r\n     * @param {number[]} point - Yandex.maps coordinates.\r\n     * @return {Array} New Vertex and two new Edges.\r\n     */\r\n    divideEdge(edge, point) {\r\n\r\n      var prevVertex = edge.prevVertex,\r\n          nextVertex = edge.nextVertex;\r\n          \r\n      var edgeChuteDirection = edge.getChuteDirection();\r\n         \r\n      var vertex = new Vertex(point, this.vertexEventRadius, this);    \r\n      vertex.setCircleVertex(this.vertexRadius);\r\n\r\n      var edge1 = new Edge(prevVertex, vertex, this, edgeChuteDirection);\r\n      var edge2 = new Edge(vertex, nextVertex, this, edgeChuteDirection);\r\n\r\n      this.length++;\r\n\r\n      edge.removeFromMap();\r\n      vertex.addToMap();\r\n      edge1.addToMap();\r\n      edge2.addToMap();\r\n\r\n      this.calculator.calculateHeight();\r\n      this.printHeightsAndWindPoints();\r\n\r\n      return([vertex, edge1, edge2]);\r\n    }\r\n\r\n    /**\r\n     * Remove vertex from Path and from map.\r\n     * @param {Vertex} vertex\r\n     * @return {(Edge|null)} Edge between previous and next vertices.\r\n     */\r\n    removeVertex(vertex) {\r\n\r\n      vertex.removeFromMap();\r\n\r\n      var prevVertex = vertex.prevVertex;\r\n      var nextVertex = vertex.nextVertex;\r\n\r\n      var edge = null;\r\n\r\n      if (this.length > 1) {\r\n        if ((prevVertex != null) && (nextVertex != null)) {\r\n\r\n          var prevEdge = vertex.prevEdge;\r\n          var nextEdge = vertex.nextEdge;\r\n          \r\n          var edgeChuteDirection = \r\n            prevEdge.getChuteDirection() || nextEdge.getChuteDirection();\r\n\r\n          prevEdge.removeFromMap();\r\n          nextEdge.removeFromMap();\r\n          \r\n          var prevPoint = prevVertex.getCoordinates();\r\n          \r\n          if (nextVertex == this.lastVertex) {\r\n            nextVertex.setTriangleVertex(prevPoint);\r\n          } \r\n\r\n          edge = new Edge(prevVertex, nextVertex, this, edgeChuteDirection);\r\n          edge.addToMap();\r\n\r\n        } else if (nextVertex == null) {  // last vertex case\r\n          var prevEdge = vertex.prevEdge;\r\n\r\n          prevEdge.removeFromMap(); \r\n\r\n          this.lastVertex = prevVertex;\r\n          this.lastVertex.nextVertex = null;\r\n          this.lastVertex.nextEdge = null;\r\n\r\n          if (prevVertex.prevVertex != null) {\r\n\r\n            var prevPrevPoint = prevVertex.prevVertex.getCoordinates();\r\n\r\n            prevVertex.setTriangleVertex(prevPrevPoint);\r\n            prevVertex.prevEdge.calculateEdgeRectangles();  \r\n          }\r\n\r\n          if (!this.calculator.getCalculationDirection()) {\r\n            if (!this.pathDirection) {\r\n              this.calculator.setFinalHeight(this.lastVertex.height);  \r\n            } \r\n          }\r\n        } else {  // first vertex case\r\n\r\n          vertex.nextEdge.removeFromMap(); \r\n\r\n          nextVertex.prevVertex = null;\r\n          this.firstVertex = nextVertex;\r\n\r\n          if (this.length == 2) {\r\n            nextVertex.setCircleVertex(this.vertexRadius);\r\n          }\r\n\r\n          if (this.calculator.getCalculationDirection()) {\r\n            if (this.pathDirection) {\r\n              this.calculator.setStartHeight(this.firstVertex.height);  \r\n            } \r\n          } \r\n        }\r\n      } else {  // case: only one circle\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.length--;\r\n\r\n      if (this.length > 0) {\r\n        this.calculator.calculateHeight();\r\n        this.printHeightsAndWindPoints();\r\n      }\r\n\r\n      return(edge);\r\n    }\r\n\r\n    /**\r\n     * Drag vertex with neibour edges.\r\n     * @param {Vertex} vertex\r\n     */\r\n    dragVertex(vertex) {\r\n \r\n      this.calculator.calculateHeight();\r\n      this.printHeightsAndWindPoints();\r\n\r\n      if (vertex.nextEdge != null) {\r\n        vertex.nextEdge.calculateEdgeRectangles();\r\n      }\r\n\r\n      if (vertex.prevEdge != null) {\r\n        vertex.prevEdge.calculateEdgeRectangles();\r\n      }\r\n    }\r\n\r\n\r\n    /** Remove all vetrices and edges from Path and from map. */\r\n    clear() {\r\n\r\n      if (this.length > 0 ) {\r\n\r\n        var vertex = this.lastVertex;\r\n\r\n        vertex.removeFromMap();\r\n\r\n        for(var i=1; i < this.length; i++) {\r\n          vertex = vertex.prevVertex;\r\n          vertex.removeFromMap();\r\n          vertex.nextEdge.removeFromMap();\r\n        }\r\n\r\n        this.length = 0;\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.calculator.boundaryHeights.makeHeightsEqual(); \r\n      this.calculator.windList.removeWindVertices();\r\n    }\r\n\r\n\r\n    /**\r\n     * Print heights in vertices ballons and hints.\r\n     * Print wind points on the Path.\r\n     */\r\n    printHeightsAndWindPoints() {\r\n      if (this.length > 0) {\r\n\r\n        if (this.calculator.getCalculationDirection()) {\r\n          \r\n          if (this.firstVertex.height == null) {\r\n            let vertex = this.lastVertex;          \r\n            while(vertex != this.firstVertex) {\r\n\r\n              vertex.printHint(\"h=?\");\r\n              if (vertex.singleClickingIsOn) {              \r\n                vertex.turnOffSingleClicking();\r\n              }               \r\n              vertex = vertex.prevVertex;              \r\n            }\r\n            \r\n            // Now: vertex = this.firstVertex\r\n\r\n            vertex.printPlacemark(\"Введите высоту\");\r\n            vertex.printHint(\"h=?\");\r\n            if (vertex.singleClickingIsOn) {             \r\n              vertex.turnOffSingleClicking();\r\n            }             \r\n                        \r\n            this.calculator.windList.removeWindVertices();                                      \r\n            return;  \r\n          }            \r\n       \r\n          var vertex = this.firstVertex;\r\n          \r\n          // First unreachable vertex placemark will be shown, \r\n          // next placemarks will be hide. \r\n          var firstUnreachable = true;\r\n\r\n          while(vertex != null) {\r\n            \r\n            if (!vertex.singleClickingIsOn) {             \r\n              vertex.turnOnSingleClicking();\r\n            } \r\n            \r\n            if (typeof(vertex.height) == 'number') {\r\n              vertex.printHint(Math.floor(vertex.height) + \"&nbsp;м\");\r\n              vertex.printPlacemark(Math.floor(vertex.height) + \"&nbsp;м\");\r\n                \r\n            } else {\r\n              vertex.printHint(\"&#x26D4;\");\r\n              vertex.printPlacemark(\"&#x26D4;\");\r\n              if (firstUnreachable) {\r\n                firstUnreachable = false;\r\n              } else {\r\n              }\r\n            }\r\n            vertex = vertex.nextVertex;\r\n          }\r\n        } else {\r\n                    \r\n          if (this.lastVertex.height == null) {\r\n\r\n            let vertex = this.firstVertex;          \r\n            while(vertex != this.lastVertex) {\r\n              vertex.printHint(\"h=?\");\r\n              if (vertex.singleClickingIsOn) {              \r\n                vertex.turnOffSingleClicking();\r\n              }               \r\n              vertex = vertex.nextVertex;              \r\n            }\r\n            \r\n            // Now: vertex = this.lastVertex\r\n\r\n            vertex.printPlacemark(\"Введите высоту\");\r\n            vertex.printHint(\"h=?\");\r\n            if (vertex.singleClickingIsOn) {             \r\n              vertex.turnOffSingleClicking();\r\n            }             \r\n                        \r\n            this.calculator.windList.removeWindVertices();                                      \r\n            return;  \r\n          }  \r\n                      \r\n          var vertex = this.lastVertex;\r\n\r\n          var firstBackUnreachable = true;\r\n\r\n          while(vertex != null) {\r\n\r\n            if (!vertex.singleClickingIsOn) {             \r\n              vertex.turnOnSingleClicking();\r\n            }\r\n          \r\n            if (typeof(vertex.height) == 'number') {\r\n              vertex.printHint(\"h=\" + Math.floor(vertex.height) + \" м\");\r\n              vertex.printPlacemark(Math.floor(vertex.height) + \" м\");\r\n            } else {\r\n              vertex.printHint(\"&#x26D4;\");\r\n              vertex.printPlacemark(\"Отсюда не долететь!\");\r\n              if (firstBackUnreachable) {\r\n                firstBackUnreachable = false;\r\n              } \r\n            }\r\n            vertex = vertex.prevVertex;\r\n          }\r\n        }\r\n\r\n        this.calculator.windList.createWindVertices();\r\n      }\r\n    }\r\n  }\r\n  provide(Path);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Path.js?");

/***/ }),

/***/ "./src/scripts/TriangleVertexImage.js":
/*!********************************************!*\
  !*** ./src/scripts/TriangleVertexImage.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('TriangleVertexImage', [\r\n  'Polygon', \r\n  'VectorMath'  \r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n \r\n  /** \r\n   * Let point1, point2 - two points with Yandex.maps (geodesic) coordinates. \r\n   * TriangleVertex is Yandex maps triangle, \r\n   * such that vector (point1, point2) and that triangle \r\n   * form arrow (end of path).\r\n   * Size of arrow is about several meters.\r\n   */ \r\n  class TriangleVertexImage extends Polygon {\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates. \r\n     * @param {number} triangleScale - It defines size of Triangle.\r\n     * @param {number} zIndex - z-index of Polygon.     \r\n     */\r\n    constructor(point1, point2, triangleScale = 1, zIndex=0) {\r\n      // four square brackets is a must for Polygon constructor, \r\n      // non empty super constructor is a must     \r\n      super([], {}, {\r\n        fillColor: \"#0000FF\", \r\n        strokeColor: \"#0000FF\", \r\n        zIndex: zIndex          \r\n      });   \r\n      \r\n      // Three vertices of triangle \r\n      this.triangleVertices = null;\r\n      // Point on triangle side to which edge will be connected\r\n      this.edgePoint = null;\r\n\r\n      this.triangleScale = triangleScale;\r\n      this.point1 = point1;\r\n      this.point2 = point2;\r\n      \r\n      this.setCoordinates(point1, point2);       \r\n    }\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.    \r\n     */    \r\n    setCoordinates (point1, point2) {\r\n      this.point1 = point1;\r\n      this.point2 = point2;  \r\n\r\n      var p = this.calculateVertices(point1, point2);\r\n\r\n      this.triangleVertices = [p[0], p[1], p[2]];\r\n      this.edgePoint = p[3]; \r\n      \r\n      this.geometry.setCoordinates([this.triangleVertices]); \r\n    }\r\n    \r\n    getEdgePoint() {\r\n      return(this.edgePoint);\r\n    }\r\n    \r\n    setScale(scale) {\r\n      this.triangleScale = scale;\r\n      this.setCoordinates(this.point1, this.point2);\r\n    }\r\n\r\n    getScale() {\r\n      return this.triangleScale;\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps point coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps point coordinates.\r\n     * @return {number[][]} points - First three points of this array are \r\n     * the vertices of triangle; last point is a point at the triangle side \r\n     * to which edge will be connected.  \r\n     */     \r\n    calculateVertices (point1, point2) {\r\n                   \r\n      var latitude = point1[0],\r\n          geodesicArrowVector = VectorMath.subVectors(point2, point1),\r\n          localArrowVector = \r\n            VectorMath.toLocalVector(geodesicArrowVector, latitude);         \r\n\r\n      localArrowVector = VectorMath.normaliseVector(localArrowVector);                \r\n      \r\n      // Points coordinates in local cartesian coordinate system.\r\n      // First three point are the vertices of triangle.\r\n      // Last point is a point at the triangle side \r\n      // to which edge will be connected.\r\n      var pointsLocal = [[-2, 0.5], [-2, -0.5], [0, 0], [-2,0]];\r\n      for(var i=0; i<4; i++) {\r\n        for(var j=0; j<2; j++) {\r\n          pointsLocal[i][j] *= this.triangleScale;\r\n        }\r\n      }\r\n      \r\n      var points = [];                 \r\n      for(var i=0; i<pointsLocal.length; i++) {   \r\n        points[i] = VectorMath.rotateVector(pointsLocal[i], localArrowVector);\r\n        points[i] = VectorMath.addVectors(\r\n          point2, \r\n          VectorMath.toGeodesicVector(points[i], latitude)\r\n        );\r\n      }\r\n \r\n      return(points);  \r\n    }        \r\n  }\r\n  \r\n  provide(TriangleVertexImage);      \r\n});\n\n//# sourceURL=webpack:///./src/scripts/TriangleVertexImage.js?");

/***/ }),

/***/ "./src/scripts/VectorMath.js":
/*!***********************************!*\
  !*** ./src/scripts/VectorMath.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('VectorMath', [],\r\nfunction(provide) {\r\n  /** Set of functions for working with Sphere (2 dimensional) vectors. */\r\n  class VectorMath {\r\n       \r\n    /**\r\n     * We consider following local cartesian coordinate system: \r\n     *  axis have the same direction as Latitude-Longtitude, \r\n     *  axis have the same length (with each other), \r\n     *  default scale parameter (0.00008) makes this \r\n     *  coordinate system be of the size we need in our tasks.\r\n     * @param {number[]} geodesicVector - Latitude-Longtitude vector coordinates.\r\n     * @param {number} latitude\r\n     * @param {number} scale - Default value is 0.00008\r\n     * @return {number[]} [vx, vy] - Vector coordinates in cartesian coordinate system.\r\n     */      \r\n    static toLocalVector(geodesicVector, latitude, scale=0.00008) {  \r\n      var vx = geodesicVector[0]/scale;\r\n      var vy = (geodesicVector[1]/scale) * \r\n                Math.cos((Math.PI/180)*latitude);\r\n      return([vx, vy]);\r\n    }\r\n    \r\n    /**\r\n     * Convert Cartesian coordinate to Latitude-Longtitude coordinates.\r\n     * @param {number[]} localVector - Cartesian vector. \r\n     * @param {number} latitude\r\n     * @param {number} scale \r\n     * @return {number[]|0} [vlat, vlon] - [Latitude, Longtitude] or 0 \r\n     *  (if impossible to convert).       \r\n     */\r\n    static toGeodesicVector(localVector, latitude, scale=0.00008) {\r\n      var vlat = localVector[0]*scale;\r\n      var c = Math.cos((Math.PI/180)*latitude);\r\n      if (c == 0) return 0;\r\n      var vlon = (localVector[1]*scale) / c;\r\n      return([vlat, vlon]);\r\n    }\r\n\r\n    static normaliseVector(v) {\r\n      var d = Math.sqrt(v[0]**2 + v[1]**2);\r\n      if (d>0) {\r\n        return ([v[0]/d, v[1]/d]);\r\n      } else {        \r\n        return ([0, 0]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * n = (cos(alpha), sin(alpha)), \r\n     * alpha is angle of rotation\r\n     */\r\n    static rotateVector(v, n) {\r\n      var wx = n[0]*v[0] - n[1]*v[1];\r\n      var wy = n[1]*v[0] + n[0]*v[1];\r\n      return ([wx, wy]);        \r\n    }\r\n\r\n    static addVectors(v1, v2) {\r\n      return([v1[0] + v2[0], v1[1] + v2[1]]);\r\n    } \r\n    \r\n    static subVectors(v1, v2) {\r\n      return([v1[0] - v2[0], v1[1] - v2[1]]);\r\n    }\r\n\r\n    static multVectorConstant(v, a) {\r\n      return([v[0]*a, v[1]*a]);\r\n    }\r\n\r\n    static scalarProduct(v1, v2) {\r\n      return(v1[0]*v2[0] + v1[1]*v2[1]);      \r\n    }\r\n    \r\n    static length(v) {\r\n      return(Math.sqrt(v[0]*v[0] + v[1]*v[1]));\r\n    }\r\n    \r\n    /**\r\n     * pointA + {pointA, pointB} * t\r\n     */       \r\n    static findIntermediatePoint(pointA, pointB, t) {\r\n      var v = this.subVectors(pointB, pointA);      \r\n      var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);      \r\n      v = this.multVectorConstant(v, t);                   \r\n      var point = this.addVectors(pointA, v);\r\n      return(point);  \r\n    }\r\n            \r\n  }\r\n      \r\n  provide(VectorMath);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/VectorMath.js?");

/***/ }),

/***/ "./src/scripts/Vertex.js":
/*!*******************************!*\
  !*** ./src/scripts/Vertex.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Vertex', [\r\n  'Circle',\r\n  'Rectangle',\r\n  'TriangleVertexImage', \r\n  'Placemark',   \r\n  'templateLayoutFactory'\r\n],\r\nfunction(provide, Circle, Rectangle, TriangleVertexImage,   Placemark, templateLayoutFactory) {\r\n  /**\r\n   * Vertex of Path. \r\n   * Vertex consists of: Invisible Event Circle (it is used for catching \r\n   * events for Vertex), Vertex Placemark for Output, Vertex Image (Circle or Triangle).\r\n   * Also it contains references to previous and next Vertices. \r\n   */\r\n  class Vertex {    \r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {number} eventRadius - Radius of Event Circle.\r\n     * @param {Path} path - Link to parent Path; we need it because some vertex\r\n     * operations (like clicking on Placemark Cross = Path clear) change the Path.   \r\n     */\r\n    constructor(point, eventRadius, path) {\r\n\r\n      // Event Circle\r\n      this.eventCircle = new ymaps.Circle(\r\n        [point, eventRadius], \r\n        {}, \r\n        {\r\n          draggable: true,\r\n          // vertex will be invisible\r\n          fillOpacity: 0,\r\n          strokeOpacity: 0, \r\n          strokeWidth: 0, \r\n          zIndex: 2\r\n        }\r\n      );\r\n\r\n            \r\n      // Output Placemark\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        [point[0], point[1]], \r\n        {iconContent: ''}, \r\n        {\r\n          iconOffset: [0, -35],\r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n\r\n      this.placemarkHintContent = null;\r\n      this.placemarkIsVisible = true;\r\n      \r\n      // Image of Vertex. \r\n      // To set it, use this.setTriangleImage() or this.setCircleImage()\r\n      // You should not add Vertex to Map until Image is not set up.\r\n      this.image = null;\r\n      this.imageZIndex = 1;      \r\n      \r\n      // null - for undefined, true - for Triangle Vertex Image, false - for Circle Vertex Image.\r\n      this.isTriangleVertex = null;\r\n\r\n      this.path = path; \r\n\r\n      // References to some another Vertices.\r\n      this.prevVertex = null;\r\n      this.nextVertex = null;\r\n\r\n      this.prevEdge = null;\r\n      this.nextEdge = null;\r\n      \r\n      this.clickNumber = 0;\r\n\r\n      this.vertexIsOnMap = false;\r\n      // Vertex single clicking switcher\r\n      this.singleClickingIsOn = true;\r\n     \r\n      // Turning on/off vertex when conditon \r\n      // \"reachable/unreachable\" was changed\r\n      this.wasTurnOffBecauseUnreachable = false;\r\n      // The same for back direction\r\n      this.wasTurnOffBecauseBackUnreachable = false;\r\n\r\n      // Chute height at this vertex. It will be calculated later.      \r\n      this.height = null;      \r\n              \r\n      this.eventCircle.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n      \r\n      // remove standart map zoom for double click\r\n      this.eventCircle.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });\r\n      \r\n      this.eventCircle.events.add('drag', function(e) {\r\n        e.stopPropagation();\r\n        var point = this.eventCircle.geometry.getCoordinates();\r\n        this.setCoordinates(point);       \r\n        this.path.dragVertex(this);     \r\n      }.bind(this));\r\n    \r\n    }\r\n\r\n\r\n    scale(scale) {\r\n      var radius = this.eventCircle.geometry.getRadius();  \r\n      radius = radius * scale;\r\n      this.eventCircle.geometry.setRadius(radius);\r\n      \r\n      if (this.isTriangleVertex) {\r\n        var triangleScale = this.image.getScale();\r\n        triangleScale *= scale;\r\n        this.image.setScale(triangleScale);\r\n\r\n      } else {\r\n        radius = this.image.geometry.getRadius();  \r\n        radius = radius * scale;\r\n        this.image.geometry.setRadius(radius);\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {Vertex | null} vertex \r\n     */\r\n    setNextVertex(vertex) {\r\n      this.nextVertex = vertex;\r\n      if (vertex != null) {        \r\n        vertex.prevVertex = this;\r\n      } \r\n    }\r\n\r\n    setPrevVertex(vertex) {\r\n      this.prevVertex = vertex;\r\n      if (vertex != null) {        \r\n        vertex.nextVertex = this;\r\n      } \r\n    }\r\n\r\n\r\n    setNextEdge(edge) {\r\n      this.nextEdge = edge;\r\n      if (edge != null) {        \r\n        edge.prevVertex = this;\r\n        edge.nextVertex = this.nextVertex;\r\n        if (this.nextVertex != null) {\r\n          this.nextVertex.prevEdge = edge;\r\n        }\r\n      } \r\n    }\r\n\r\n    setPrevEdge(edge) {\r\n      this.prevEdge = edge;\r\n      if (edge != null) {\r\n        edge.nextVertex = this;\r\n        edge.prevVertex = this.prevVertex;\r\n        if (this.prevVertex != null) {\r\n          this.prevVertex.nextEdge = edge;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {number[]} prevPoint - Previuos point that define direction of Triangle.\r\n     */\r\n    setTriangleVertex(prevPoint) {\r\n\r\n      this.isTriangleVertex = true;\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.image);\r\n        this.path.map.geoObjects.remove(this.heightPlacemark);  \r\n      }\r\n\r\n      var point1 = prevPoint;\r\n      var point2 = this.getCoordinates();\r\n      \r\n      // Set Triangle Image \r\n      this.image = new TriangleVertexImage(point1, point2, this.path.triangleScale, this.imageZIndex);\r\n\r\n      // Set Placemark with Closing Cross\r\n      var path = this.path;\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(   \r\n        '<div class=\"px-2 py-1 bg-info d-inline-flex rounded border align-items-center\"' + \r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' +\r\n          '<div class=\"bg-info pr-2\">$[properties.iconContent]</div>' +            \r\n          '<div class=\"bg-info placemarkCross placemarkCrossImage\"></div>' +\r\n          //'<div class=\"p-0 bg-info hoverColor\">&#10006;</div>' +\r\n        '</div>', {\r\n          build: function () {\r\n            this.constructor.superclass.build.call(this);\r\n            this.path = path;\r\n            var elem = this.getData().geoObject;\r\n            //console.log(elem);\r\n            //console.log(\"getData()\"); console.log(this.getData());\r\n            //console.log(\"getShape()\"); console.log(this.getShape());\r\n            elem.events.add('click', this.clickFunc, this);\r\n            elem.events.add('mouseenter', this.mouseEnter, this);\r\n            elem.events.add('mouseleave', this.mouseLeave, this); \r\n            //var domelem = $(\".d-inline-flex\", this.getParentElement())[0];\r\n          }, \r\n\r\n          clear: function () {\r\n\r\n            //console.log(\"clear\");\r\n            \r\n            var elem = this.getData().geoObject;\r\n            elem.events.remove('click', this.clickFunc, this);\r\n            elem.events.remove('mouseenter', this.mouseEnter, this);\r\n            elem.events.remove('mouseleave', this.mouseLeave, this); \r\n\r\n            this.constructor.superclass.clear.call(this);\r\n          },\r\n\r\n        \r\n          getShape: function () {\r\n            //console.log(\"this.getParentElement(): \");\r\n            //console.log(this.getParentElement());\r\n            var parentElement = this.getParentElement();\r\n            if (parentElement != null) {\r\n              var element = $('.d-inline-flex', parentElement);\r\n              var width = element[0].offsetWidth;\r\n              var height = element[0].offsetHeight;\r\n              var position = element.position();\r\n              \r\n              return new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([\r\n                [position.left + width - 15, position.top],\r\n                [position.left + width, position.top + height]\r\n              ]));\r\n            } else {\r\n              return null;\r\n            }  \r\n          },\r\n\r\n \r\n          clickFunc: function(e) {\r\n            //console.log(\"click\");\r\n            e.preventDefault();\r\n            if (this.path.length > 2) { \r\n              if (confirm(\"Удалить все метки? \\n\\n (для удаления только одной метки дважды щелкните по ней)\")) {\r\n                this.path.clear();\r\n              };\r\n            } else {\r\n              this.path.clear();\r\n            }\r\n          }.bind(this),\r\n          \r\n          mouseEnter: function() {\r\n            //console.log('mouseenter');\r\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\r\n            $(elem).removeClass('placemarkCrossImage');\r\n            $(elem).addClass('placemarkCrossImagePointed');\r\n          \r\n          },\r\n\r\n          mouseLeave: function() {\r\n            //console.log('mouseleave');\r\n            var elem = this.getParentElement().getElementsByClassName('placemarkCross')[0];\r\n            $(elem).removeClass('placemarkCrossImagePointed');\r\n            $(elem).addClass('placemarkCrossImage');\r\n          }           \r\n        }\r\n      );\r\n\r\n      var MyIconShape = {\r\n        type: 'Rectangle',\r\n        coordinates: [[71, 0], [96, 25]]\r\n      };\r\n           \r\n      this.heightPlacemark.options.set('iconLayout', MyIconLayout);\r\n      this.heightPlacemark.options.set('iconShape', MyIconShape);\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.add(this.image);\r\n        this.path.map.geoObjects.add(this.heightPlacemark);  \r\n      }     \r\n    }\r\n\r\n    /**\r\n     * @param {number} radius - Radious of Vertex Image.\r\n     */\r\n    setCircleVertex(radius) {\r\n\r\n      this.isTriangleVertex = false;\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.image);\r\n        this.path.map.geoObjects.remove(this.heightPlacemark);  \r\n      }\r\n\r\n      var point = this.getCoordinates();      \r\n      var color = '#0000FF';\r\n      this.image = new ymaps.Circle([point, radius], {}, {\r\n        fillColor: color, \r\n        strokeColor: color, \r\n        zIndex: this.imageZIndex\r\n      });\r\n\r\n      // Set Placemark without Closing Cross\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(   \r\n        '<div class=\"px-2 py-1 bg-info text-center rounded border d-inline-block\"' + \r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' + \r\n          '$[properties.iconContent]' + \r\n        '</div>'\r\n      );  \r\n            \r\n      this.heightPlacemark.options.set('iconLayout', MyIconLayout);\r\n      this.heightPlacemark.options.set('iconShape', null);\r\n\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.add(this.image); \r\n        this.path.map.geoObjects.add(this.heightPlacemark); \r\n      }  \r\n    }  \r\n    \r\n        \r\n    addToMap() {\r\n      if (!this.vertexIsOnMap && this.isTriangleVertex != null) {\r\n        this.path.map.geoObjects.add(this.eventCircle);         \r\n        this.path.map.geoObjects.add(this.image);\r\n        this.path.map.geoObjects.add(this.heightPlacemark);       \r\n        this.vertexIsOnMap = true;\r\n      }      \r\n    }\r\n    \r\n    \r\n    removeFromMap() {\r\n      if (this.vertexIsOnMap) {\r\n        this.path.map.geoObjects.remove(this.eventCircle);         \r\n        this.path.map.geoObjects.remove(this.image);\r\n        this.path.map.geoObjects.remove(this.heightPlacemark);       \r\n        this.vertexIsOnMap = false;\r\n      }               \r\n    }  \r\n\r\n    \r\n    /** \r\n     * Turn off single clicking on vertex.\r\n     * Remember, that single clicking on vertex \r\n     * shows or hides Placemark.     \r\n     */\r\n    turnOffSingleClicking() {\r\n      if (this.singleClickingIsOn) {\r\n        this.singleClickingIsOn = false;\r\n      } else {\r\n        console.warn(\"Single clicking is already off!\");\r\n      }        \r\n    }\r\n\r\n    /** \r\n     * Turn on single clicking on vertex.\r\n     * Remember, that single clicking on vertex \r\n     * shows or hides Placemark.     \r\n     */    \r\n    turnOnSingleClicking() {\r\n      if (!this.singleClickingIsOn) {\r\n        this.singleClickingIsOn = true;\r\n      } else {\r\n        console.warn(\"Single clicking is already on!\");\r\n      }            \r\n    }\r\n         \r\n    /**\r\n     * Process both click and dblclick on this vertex.\r\n     * Single clicking is for showing/hiding Placemark. \r\n     * Double clicking is for vertex removing.\r\n     */       \r\n    processVertexClick() {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (this.clickNumber == 1) {  // Single Click (show/hide Placemark)\r\n            if (this.singleClickingIsOn) {\r\n              if (this.nextVertex != null) {\r\n                this.placemarkIsVisible = !this.placemarkIsVisible;\r\n                this.heightPlacemark.options.set('visible', this.placemarkIsVisible);\r\n                //console.log(this.heightPlacemark);\r\n                if (this.placemarkIsVisible) {                \r\n                  this.path.map.geoObjects.remove(this.eventCircle);                    \r\n                  this.eventCircle.properties.set('hintContent', null);\r\n                  this.path.map.geoObjects.add(this.eventCircle); \r\n                } else {\r\n                  this.eventCircle.properties.set('hintContent', this.placemarkHintContent);\r\n                }\r\n              }\r\n            }                            \r\n            this.clickNumber = 0;\r\n          } else {  // Double Click (remove Vertex)               \r\n            this.path.removeVertex(this);                 \r\n          }  \r\n        }.bind(this), 200);\r\n      }  \r\n    }\r\n\r\n    \r\n    /**\r\n     * Set the same coordinates for Event Circle, \r\n     * Vertex Placemark, Vertex Image.\r\n     * Change Direction of Triangles (if vertex is Triangle vertex) \r\n     * for this Vertex, prevVertex, nextVertex. \r\n     */     \r\n    setCoordinates(point) {\r\n     \r\n      this.eventCircle.geometry.setCoordinates(point);\r\n      this.heightPlacemark.geometry.setCoordinates(point);\r\n      \r\n      // Note: it supposed in in case of Triangle Vertex, pervVertex != null.\r\n      if (this.isTriangleVertex) {\r\n         var prevPoint = this.prevVertex.eventCircle.geometry.getCoordinates();\r\n         // Here we calculate vertices of Image Triangle\r\n         this.image.setCoordinates(prevPoint, point);\r\n      } else {\r\n        // In this case, this.image is a Circle, so \r\n        // we can set coordinates of it center.\r\n        this.image.geometry.setCoordinates(point);\r\n      }\r\n       \r\n      if (this.nextVertex != null && this.nextVertex.isTriangleVertex) {\r\n        var nextPoint = this.nextVertex.eventCircle.geometry.getCoordinates();\r\n        this.nextVertex.image.setCoordinates(point, nextPoint);\r\n      }    \r\n    }\r\n\r\n\r\n    getCoordinates() {\r\n      return this.eventCircle.geometry.getCoordinates();\r\n    }\r\n\r\n    \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set('iconContent', str); \r\n    }\r\n    \r\n    printHint(str) {\r\n      this.placemarkHintContent = str;\r\n\r\n      if (!this.placemarkIsVisible) {\r\n        this.eventCircle.properties.set('hintContent', str);\r\n      }     \r\n    }       \r\n  } \r\n  provide(Vertex);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Vertex.js?");

/***/ }),

/***/ "./src/scripts/Wind.js":
/*!*****************************!*\
  !*** ./src/scripts/Wind.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Wind', [],\r\nfunction(provide) {\r\n\r\n  /**\r\n   * Wind at particular height.  \r\n   */\r\n  class Wind {\r\n    /** \r\n     * Wind at special height.\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     * @param {number} angle - Angle between current wind and West wind; in degrees.    \r\n     * @param {(number | null)} height - In meters; height must be >= 0.\r\n     */\r\n    constructor(value, angle, height) {\r\n            \r\n      this.setValue(value);\r\n      this.setAngle(angle);\r\n      this.setHeight(height); \r\n\r\n      this.prevWind = null;\r\n      this.nextWind = null; \r\n\r\n      this.pathVertex = null;   \r\n    }\r\n\r\n    setNextWind(wind) {\r\n      this.nextWind = wind;\r\n      if (wind != null) {\r\n        wind.prevWind = this;\r\n      }\r\n    }  \r\n\r\n    setPrevWind(wind) {\r\n      this.prevWind = wind;\r\n      if (wind != null) {\r\n        wind.nextWind = this;\r\n      }\r\n    }  \r\n   \r\n    /**\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     */\r\n    setValue(value) {\r\n      this.value = value;             \r\n    }\r\n\r\n    /**\r\n     * angle will be reduced to interval (-180, 180] degrees.\r\n     * @param {number} angle\r\n     */\r\n    setAngle(angle) {\r\n      \r\n      angle = Math.floor(angle); \r\n      \r\n      if (angle != -180) {  // we want to differ -180 degree and 180 degree at wind menu scale             \r\n        if (angle >= 0) {\r\n          angle = angle % 360;\r\n        } else {\r\n          // negative angle case\r\n          angle = angle * (-1);\r\n          angle = angle % 360;\r\n          angle = 360 - angle;        \r\n        }\r\n        \r\n        if (angle > 180) {\r\n          angle -= 360;\r\n        }\r\n      }      \r\n      this.angle = angle;            \r\n    }\r\n\r\n    /**\r\n     * Set this.height and print it to Arrow Output Icon.\r\n     * @param {(number | null)} height - In meters; height must be >= 0.\r\n     */\r\n    setHeight(height) {\r\n      this.height = height;      \r\n    }\r\n         \r\n    getAngle() {\r\n      return(this.angle);\r\n    }\r\n    \r\n    getValue() {\r\n      return(this.value);\r\n    }\r\n    \r\n    getHeight() {\r\n      return(this.height);\r\n    }\r\n\r\n    toString() {\r\n      var str = (this.height == 0) ? 'Поверхностный ветер: ' : ('h=' + this.height + 'м');\r\n      str += (this.value + ' м/с, ' + this.getDirection());\r\n      return str;\r\n    }\r\n        \r\n    /**\r\n     * Calculate wind coordinates in cartesian coordinate system.\r\n     * @return {number[]} [vx, vy] - coordinates, in m/sec.\r\n     */\r\n    getXY () {      \r\n      var radiandirection = this.angle * ((2*Math.PI)/360);       \r\n      var vx = this.value * Math.cos(radiandirection);\r\n      var vy = this.value * Math.sin(radiandirection);\r\n      return [vx, vy];      \r\n    } \r\n    \r\n    /**\r\n     * Get name of wind direction (E, EN, N, NW, W, WS, S, SE)\r\n     */    \r\n    getDirection() {     \r\n      var angleSwitch = Math.floor((this.angle + 180 + 22)/45);\r\n      var direction;\r\n      \r\n      switch(angleSwitch) {\r\n        case 0: direction = \"В\"; break;\r\n        case 1: direction = \"СВ\"; break;\r\n        case 2: direction = \"С\"; break;\r\n        case 3: direction = \"СЗ\"; break;\r\n        case 4: direction = \"З\"; break;\r\n        case 5: direction = \"ЮЗ\"; break;\r\n        case 6: direction = \"Ю\"; break;\r\n        case 7: direction = \"ЮВ\"; break;\r\n        case 8: direction = \"В\"; break;    \r\n      }\r\n      \r\n      return(direction);     \r\n    }      \r\n  }\r\n      \r\n  provide(Wind);  \r\n});      \r\n\n\n//# sourceURL=webpack:///./src/scripts/Wind.js?");

/***/ }),

/***/ "./src/scripts/WindList.js":
/*!*********************************!*\
  !*** ./src/scripts/WindList.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindList', [\r\n  'Wind', \r\n  'WindVertex'\r\n],\r\nfunction(provide, Wind, WindVertex) {\r\n\r\n  /**\r\n   * List of winds at different heights; \r\n   * always contains wind at height = 0m (surface wind); \r\n   * that surface wind is always first and cannot be removed.\r\n   * List will be sorted for height (from bottom to top); \r\n   * all winds should have different heights.\r\n   */\r\n  class WindList {\r\n    constructor(map) {\r\n      this.map = map; \r\n\r\n      // Surface wind: 5 m/sec, West\r\n      var angle = 0;\r\n      this.firstWind = new Wind(5, angle, 0);\r\n      this.map.windOutput.print(this.firstWind.toString());\r\n      this.map.arrow.rotate(angle);\r\n          \r\n      this.currentWind = this.firstWind;\r\n      this.lastWind = this.firstWind;\r\n      this.numberOfWinds = 1;\r\n\r\n      // calculator and path are set up in index.js\r\n      this.calculator = null;\r\n      this.path = null;       \r\n\r\n      this.windVertexRadius = 4;   \r\n      \r\n      this.pathBoundChange = this.pathBoundChange.bind(this);   \r\n\r\n      this.map.events.add('boundschange', this.pathBoundChange);      \r\n    }\r\n    \r\n       \r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;      \r\n    }\r\n    \r\n    setPath(path) {\r\n      this.path = path;\r\n    }\r\n\r\n    /**\r\n     * Create new wind (value = 5, angle = 0, height is unknown) and \r\n     * add it to the end of the list.\r\n     */\r\n    addWind() {      \r\n      var wind = new Wind(5, 0, null);\r\n      this.lastWind.setNextWind(wind);      \r\n      this.lastWind = wind;\r\n      this.currentWind = wind;\r\n      this.numberOfWinds++;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Remove wind from WindList. If wind equals currentWind then \r\n     * after removing currentWind will be equal currentWind.prevWind.\r\n     * Note: you cannot remove firstWind by construction.\r\n     * @param {Wind} wind - It is supposed that wind belongs to WindList.  \r\n     */\r\n    removeWind(wind = this.currentWind) {\r\n      \r\n      // First wind, that is, surface wind, cannot be removed\r\n      if (wind == this.firstWind) {\r\n        console.warn(\"This wind was not removed, because it was firstWind.\");\r\n        return;\r\n      }\r\n      \r\n      if (wind.pathVertex != null) {\r\n        wind.pathVertex.removeFromMap();\r\n        wind.PathVertex = null;\r\n      }      \r\n\r\n      wind.prevWind.setNextWind(wind.nextWind);\r\n      if (wind == this.lastWind) {\r\n        this.lastWind = this.lastWind.prevWind;\r\n      }\r\n      \r\n      if (wind == this.currentWind) {\r\n        this.currentWind = wind.prevWind;       \r\n      }\r\n                                    \r\n      this.numberOfWinds--;       \r\n      \r\n      if (this.path.length > 0) {\r\n       this.calculator.calculateHeight();\r\n       this.path.printHeightsAndWindPoints();\r\n      }            \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Set height to this.currentWind (number or null) and then order WindList for heights \r\n     * (increasing order, null is greater then number).\r\n     * It is supposed that List was ordered before.\r\n     * @param {(number | null)} height - Height of wind.\r\n     * @return {boolean} - False iff:\r\n     *   height is a number and height <= 0m OR \r\n     *   height is a number and such height has already existed.\r\n     */ \r\n    setHeightToCurrentWind(height) {\r\n      \r\n      if ((typeof(height) == 'number') && (height <= 0)) {\r\n        return false;\r\n      }      \r\n               \r\n      // Different cones must have different heights  \r\n      if (typeof(height) == 'number') {  \r\n        var wind = this.firstWind;        \r\n        while(true) {\r\n          if ((wind != this.currentWind) && (wind.getHeight() == height)) { \r\n            return(false);\r\n          }            \r\n          if ((wind == this.lastWind) || (wind.getHeight() == null)) break;          \r\n          wind = wind.nextWind;         \r\n        }\r\n      }     \r\n                        \r\n      var currentWind = this.currentWind;\r\n      \r\n      this.currentWind.setHeight(height);         \r\n      //this.windOutput.print(this.currentWind);\r\n            \r\n      var wind = this.currentWind;\r\n \r\n      // Order windList by heights (increasing order, \r\n      // null values are greater than numbers)               \r\n      if (height == null) {         \r\n        while(true) {          \r\n          if (wind.nextWind == null || wind.nextWind.getHeight() == null) break;\r\n          var wind = wind.nextWind;        \r\n        }\r\n         \r\n        this.moveWind(currentWind, wind);\r\n              \r\n      } else {  // height is a number\r\n        \r\n        // Moving in previous order\r\n        if (wind.prevWind.getHeight() == null || \r\n            height < wind.prevWind.getHeight()) {  \r\n        \r\n          while(true) {\r\n            if (wind.prevWind.getHeight() != null) break; \r\n            wind = wind.prevWind;       \r\n          }\r\n              \r\n          while(true) {\r\n            if (height > wind.prevWind.getHeight()) break;\r\n            wind = wind.prevWind;\r\n          }\r\n          \r\n          this.moveWind(currentWind, wind.prevWind);\r\n          \r\n        } else {\r\n                \r\n          while(true) {\r\n            if (wind.nextWind == null || wind.nextWind.getHeight() == null ||\r\n                height < wind.nextWind.getHeight()) break;\r\n            wind = wind.nextWind;    \r\n          }\r\n          \r\n          this.moveWind(currentWind, wind);        \r\n        }                        \r\n      }\r\n            \r\n      return true;            \r\n    }\r\n    \r\n    /**\r\n     * Move windA to be next wind for windB;\r\n     * Here both windA and windB belong to windList;\r\n     * Remember, that in WindList first wind always exists. \r\n     */\r\n    moveWind(windA, windB) {\r\n      if (windA == windB || windA == windB.nextWind) return;\r\n              \r\n      if (windB == this.lastWind) {\r\n        \r\n        windA.nextWind.prevWind = windA.prevWind;\r\n        windA.prevWind.nextWind = windA.nextWind;        \r\n                \r\n        windB.nextWind = windA;\r\n        windA.prevWind = windB;\r\n\r\n        this.lastWind = windA;         \r\n      } else if (windA == this.lastWind) {\r\n        \r\n        this.lastWind = windA.prevWind;\r\n        windA.prevWind.nextWind = null;        \r\n\r\n        windA.nextWind = windB.nextWind;        \r\n        windB.nextWind.prevWind = windA;\r\n        \r\n        windA.prevWind = windB;\r\n        windB.nextWind = windA;              \r\n      } else {  // both windA and windB are not lastWind\r\n        \r\n        windA.nextWind.prevWind = windA.prevWind;\r\n        windA.prevWind.nextWind = windA.nextWind;         \r\n        \r\n        windA.nextWind = windB.nextWind;        \r\n        windB.nextWind.prevWind = windA;\r\n\r\n        windA.prevWind = windB;\r\n        windB.nextWind = windA;                    \r\n      }       \r\n    }\r\n    \r\n        \r\n    setCurrentAngle(angle) {\r\n      this.currentWind.setAngle(angle);\r\n      if (this.currentWind == this.firstWind) {\r\n        this.map.windOutput.print(this.firstWind.toString()); \r\n        this.map.arrow.rotate(angle);\r\n      }             \r\n    }\r\n    \r\n    setCurrentValue(value) {\r\n      this.currentWind.setValue(value);\r\n      if (this.currentWind == this.firstWind) {\r\n        this.map.windOutput.print(this.firstWind.toString()); \r\n      }                \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Shift coordinates of all winds in such way \r\n     * that firstWind's coordinates will be point.\r\n     */ /*\r\n    shiftList(point) {\r\n      var wind = this.firstWind;\r\n      var [x0, y0] = wind.arrow.geometry.getCoordinates();\r\n      var [cx, cy] = point;\r\n      while(true) {\r\n        var [x1, y1] = wind.arrow.geometry.getCoordinates();\r\n        var [x, y] = [x1 - x0 + cx, (y1 - y0) + cy];\r\n        wind.arrow.setCoordinates([x, y]);\r\n        if (wind == this.lastWind) break;\r\n        wind = wind.nextWind;                      \r\n      }      \r\n    }  */\r\n    \r\n    \r\n    createWindVertices() {\r\n      \r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        \r\n        if (wind.pathPoint == null) {\r\n          if (wind.pathVertex != null) {\r\n            wind.pathVertex.removeFromMap();\r\n            wind.pathVertex = null;             \r\n          }\r\n        } else {\r\n          if (wind.pathVertex == null) {\r\n            wind.pathVertex = new WindVertex(wind, this.map, this.windVertexRadius);\r\n            wind.pathVertex.addToMap();                        \r\n          } else {\r\n            wind.pathVertex.refreshCoordinates();              \r\n          }          \r\n        }        \r\n        wind = wind.nextWind;\r\n      }  \r\n    }\r\n    \r\n    \r\n    removeWindVertices() {\r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        if (wind.pathVertex != null) {        \r\n          wind.pathVertex.removeFromMap();\r\n          wind.pathVertex = null;\r\n          wind.pathPoint = null;\r\n        }        \r\n        wind = wind.nextWind;\r\n      }     \r\n    }\r\n\r\n\r\n    pathBoundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        var scale = (2**(oldZoom - newZoom));\r\n        this.scale(scale);\r\n      }\r\n    }\r\n  \r\n  \r\n    scale(scale) {\r\n      this.windVertexRadius *= scale;\r\n        var wind = this.firstWind;\r\n        while (wind != null) {\r\n          if (wind.pathVertex != null) {\r\n            wind.pathVertex.scale(scale);\r\n          }\r\n          wind = wind.nextWind;\r\n        }      \r\n    }\r\n  }\r\n      \r\n  provide(WindList);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindList.js?");

/***/ }),

/***/ "./src/scripts/WindVertex.js":
/*!***********************************!*\
  !*** ./src/scripts/WindVertex.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindVertex', [\r\n  'Circle', \r\n  'Placemark', \r\n  'templateLayoutFactory'  \r\n],\r\nfunction(provide, Circle, Placemark, templateLayoutFactory) {\r\n  /**\r\n   * Wind Vertex consists of Vertex Image (Circle) and \r\n   * Vertex Placemark for output. \r\n   */\r\n  class WindVertex {  \r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {number} radius   \r\n     */\r\n    constructor(wind, map, radius = 4) {\r\n      \r\n      var point = wind.pathPoint;\r\n      var color = \"#0000FF\";\r\n      var strokeColor = \"#00FF00\";\r\n\r\n      this.image = new ymaps.Circle([point, radius], {}, {\r\n        fillColor: color,\r\n        strokeColor: strokeColor, \r\n        strokeWidth: 2\r\n      }); \r\n          \r\n      this.map = map;\r\n      this.wind = wind;\r\n      this.radius = radius;\r\n\r\n      var MyIconLayout = ymaps.templateLayoutFactory.createClass(   \r\n        '<div class=\"px-2 py-1 bg-success text-center rounded border d-inline-block\"' + \r\n              'style=\"font-size: 11px; font-family: Arial, Verdana, sans-serif;\">' + \r\n          '$[properties.iconContent]' + \r\n        '</div>'\r\n      ); \r\n\r\n      // Placemark for Height of Chute at this vertex\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        [point[0], point[1]], \r\n        {}, \r\n        {\r\n          iconLayout: MyIconLayout,\r\n          iconOffset: [0, -35], \r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n\r\n      this.placemarkIsVisible = true;      \r\n      this.printPlacemark(wind.getHeight() + \"&nbsp;м\");  \r\n            \r\n      this.clickNumber = 0;\r\n      this.placemarkIsShown = true;\r\n      \r\n      this.image.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n      \r\n      // remove standart map zoom for double click\r\n      this.image.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });          \r\n    }\r\n\r\n    \r\n    getCoordinates() {\r\n      return this.image.geometry.getCoordinates();\r\n    }\r\n\r\n\r\n    scale(scale) {\r\n      var radius = this.image.geometry.getRadius();  \r\n      radius = radius * scale;\r\n      this.image.geometry.setRadius(radius);\r\n    }\r\n\r\n          \r\n    processVertexClick() {\r\n      this.placemarkIsVisible = !this.placemarkIsVisible;\r\n      this.heightPlacemark.options.set('visible', this.placemarkIsVisible);\r\n    }\r\n   \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set(\"iconContent\", str);           \r\n    }\r\n    \r\n    printHint(str) {\r\n      this.properties.set(\"hintContent\", str);      \r\n    }\r\n        \r\n    addToMap() {\r\n      this.map.geoObjects.add(this.image);\r\n      this.map.geoObjects.add(this.heightPlacemark);         \r\n    }\r\n    \r\n    removeFromMap() {\r\n      this.map.geoObjects.remove(this.image);\r\n      this.map.geoObjects.remove(this.heightPlacemark);        \r\n    }\r\n    \r\n    refreshCoordinates() {\r\n      var point = this.wind.pathPoint;\r\n      this.image.geometry.setCoordinates(point);\r\n      this.heightPlacemark.geometry.setCoordinates([point[0], point[1]]);\r\n      this.printPlacemark(this.wind.getHeight() + \"&nbsp;м\");      \r\n    }            \r\n  } \r\n  provide(WindVertex);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/WindVertex.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Program calculate heights of Chute for\r\n * Vertices of the Path. Path is a set of line segments (Edges).\r\n * You can input Path by clicking on the Map.\r\n */\r\n\r\nymaps.ready(init);\r\nfunction init() {\r\n  ymaps.modules.require([\r\n    'AppMap',\r\n    'WindList',\r\n    'Chute',\r\n    'Path',\r\n    'Calculator',\r\n    'DialogWindows',\r\n    'BoundaryHeights'\r\n  ]).spread(function (\r\n    AppMap,\r\n    WindList,\r\n    Chute,\r\n    Path,\r\n    Calculator,\r\n    DialogWindows,\r\n    BoundaryHeights\r\n  ) {\r\n    // Yandex map\r\n    var map = new AppMap();\r\n\r\n    // Chute velocity = (10, 5) m/s\r\n    var chute = new Chute(10, 5);\r\n\r\n    // Winds at several heights\r\n    var windList = new WindList(map);\r\n\r\n    // List of vertices and edges\r\n    var path = new Path(map);\r\n    \r\n    // Heights at the beginning and end of the Path\r\n    var boundaryHeights = new BoundaryHeights();\r\n\r\n    // Calculator will make all computations\r\n    var calculator = new Calculator(path, chute, windList, boundaryHeights);\r\n\r\n    path.setCalculator(calculator);\r\n    \r\n    windList.setCalculator(calculator);\r\n    windList.setPath(path);\r\n\r\n    boundaryHeights.setCalculator(calculator);\r\n    boundaryHeights.setPath(path);\r\n\r\n  \r\n    // Click on the map will add vertice to Path,\r\n    // double click on the map will add wind to WindList.\r\n    var clickNumber = 0;\r\n    map.events.add('click', function(e) {\r\n      var point = e.get('coords');\r\n      clickNumber++;\r\n      if (clickNumber == 1) {\r\n        setTimeout(function() {\r\n          if (clickNumber == 1) {  // Single Click\r\n            // We add vertex to path\r\n            path.addVertex(point);\r\n          } else {  // Double Click\r\n            // We add new wind arrow (windsock)\r\n            /*\r\n            if (windList.lastWind.getHeight() != null) {\r\n              windList.addWind(point);\r\n              windList.printCurrentWindWindow();\r\n              menu.windButton.showMenu();\r\n              $(\"#menuArrow\").removeClass(\"arrow\");\r\n              $(\"#menuArrow\").addClass(\"arrow_selected\");\r\n            } */\r\n          }\r\n          clickNumber = 0;\r\n        }, 200);\r\n      }\r\n    });\r\n\r\n\r\n    // This function should be tested after adding Yandex API Key\r\n    // After yandex maps search we should:\r\n    //   move wind arrows to the current screen,\r\n    //   add result of search to Settings Dialog Window.\r\n    /*map.searchControl.events.add('resultshow', function(e) {\r\n                \r\n      path.clear(); \r\n      //this.setZoom(this.defaultZoom);        \r\n      //this.windList.shiftList(this.getCenter());\r\n               \r\n      var index = e.get('index');    \r\n      var geoObjectsArray = map.searchControl.getResultsArray();\r\n      var resultName = geoObjectsArray[index].properties.get('name');\r\n\r\n      var newDz = {\r\n        name: resultName, \r\n        mapCenter: map.getCenter()\r\n      };    \r\n      map.dz.push(newDz);    \r\n      $(\"#dz\").append(\"<option>\" + newDz.name + \"</option>\");    \r\n      $(\"#dz\").children()[map.dz.length - 1].selected = true;    \r\n    }); */  \r\n\r\n\r\n\r\n    /**\r\n     * Menu initialization\r\n     */\r\n    DialogWindows.initMenu(calculator);\r\n  });\r\n}\n\n//# sourceURL=webpack:///./src/scripts/index.js?");

/***/ }),

/***/ 0:
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/scripts/AppMap.js ./src/scripts/Arrow.js ./src/scripts/BoundaryHeights.js ./src/scripts/Calculator.js ./src/scripts/Chute.js ./src/scripts/Constant.js ./src/scripts/DialogWindows.js ./src/scripts/Edge.js ./src/scripts/index.js ./src/scripts/MenuButton.js ./src/scripts/OutputElement.js ./src/scripts/Path.js ./src/scripts/TriangleVertexImage.js ./src/scripts/VectorMath.js ./src/scripts/Vertex.js ./src/scripts/Wind.js ./src/scripts/WindList.js ./src/scripts/WindVertex.js ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/scripts/AppMap.js */\"./src/scripts/AppMap.js\");\n__webpack_require__(/*! ./src/scripts/Arrow.js */\"./src/scripts/Arrow.js\");\n__webpack_require__(/*! ./src/scripts/BoundaryHeights.js */\"./src/scripts/BoundaryHeights.js\");\n__webpack_require__(/*! ./src/scripts/Calculator.js */\"./src/scripts/Calculator.js\");\n__webpack_require__(/*! ./src/scripts/Chute.js */\"./src/scripts/Chute.js\");\n__webpack_require__(/*! ./src/scripts/Constant.js */\"./src/scripts/Constant.js\");\n__webpack_require__(/*! ./src/scripts/DialogWindows.js */\"./src/scripts/DialogWindows.js\");\n__webpack_require__(/*! ./src/scripts/Edge.js */\"./src/scripts/Edge.js\");\n__webpack_require__(/*! ./src/scripts/index.js */\"./src/scripts/index.js\");\n__webpack_require__(/*! ./src/scripts/MenuButton.js */\"./src/scripts/MenuButton.js\");\n__webpack_require__(/*! ./src/scripts/OutputElement.js */\"./src/scripts/OutputElement.js\");\n__webpack_require__(/*! ./src/scripts/Path.js */\"./src/scripts/Path.js\");\n__webpack_require__(/*! ./src/scripts/TriangleVertexImage.js */\"./src/scripts/TriangleVertexImage.js\");\n__webpack_require__(/*! ./src/scripts/VectorMath.js */\"./src/scripts/VectorMath.js\");\n__webpack_require__(/*! ./src/scripts/Vertex.js */\"./src/scripts/Vertex.js\");\n__webpack_require__(/*! ./src/scripts/Wind.js */\"./src/scripts/Wind.js\");\n__webpack_require__(/*! ./src/scripts/WindList.js */\"./src/scripts/WindList.js\");\nmodule.exports = __webpack_require__(/*! ./src/scripts/WindVertex.js */\"./src/scripts/WindVertex.js\");\n\n\n//# sourceURL=webpack:///multi_./src/scripts/AppMap.js_./src/scripts/Arrow.js_./src/scripts/BoundaryHeights.js_./src/scripts/Calculator.js_./src/scripts/Chute.js_./src/scripts/Constant.js_./src/scripts/DialogWindows.js_./src/scripts/Edge.js_./src/scripts/index.js_./src/scripts/MenuButton.js_./src/scripts/OutputElement.js_./src/scripts/Path.js_./src/scripts/TriangleVertexImage.js_./src/scripts/VectorMath.js_./src/scripts/Vertex.js_./src/scripts/Wind.js_./src/scripts/WindList.js_./src/scripts/WindVertex.js?");

/***/ })

/******/ });