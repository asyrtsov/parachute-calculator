/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/AppMap.js":
/*!*******************************!*\
  !*** ./src/scripts/AppMap.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('AppMap', [\r\n  'Map', \r\n  'control.ZoomControl', \r\n  'Constant'  \r\n],\r\nfunction(provide, Map, ZoomControl, Constant) {\r\n  \r\n  class AppMap extends Map {\r\n\r\n    constructor() {\r\n\r\n      // Array of Dropzones and their coordinates.\r\n      var dz = [\r\n        {name: \"Коломна\", mapCenter: [55.091289443603706, 38.917269584802675]}, \r\n        {name: \"Пущино\", mapCenter: [54.78929269708931,37.64268598670033]}, \r\n        {name: \"Ватулино\", mapCenter: [55.663193308717396,36.14121807608322]}\r\n      ];    \r\n        \r\n      super(\"map\", {\r\n        center: dz[0].mapCenter,    \r\n        zoom: Constant.defaultZoom\r\n      }, {\r\n        suppressMapOpenBlock: true  // remove button 'open in yandex maps'\r\n      });\r\n      \r\n      this.dz = dz; \r\n \r\n      // view from space  \r\n      this.setType(\"yandex#satellite\");    \r\n      this.cursors.push('arrow');  \r\n      this.controls.remove('trafficControl');  \r\n      this.controls.remove('zoomControl');\r\n      var zoomControl = new ZoomControl({options: { \r\n        position: { right: 10, top: 105 }, \r\n        size: 'small'\r\n      }}); \r\n      this.controls.add(zoomControl);\r\n      this.controls.remove('geolocationControl');\r\n      this.controls.remove('fullscreenControl');   \r\n       \r\n      this.searchControl = this.controls.get('searchControl');\r\n      this.searchControl.options.set('size', 'small');\r\n      this.searchControl.options.set('noPlacemark', true);\r\n      this.searchControl.options.set('noSelect', true);\r\n\r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.preventDefault();  \r\n      }); \r\n\r\n      this.menu = null;       \r\n    }\r\n    \r\n    /**\r\n     * Processing of yandex.maps search\r\n     */\r\n    setSearchProcessor(calculator) {\r\n\r\n      this.calculator = calculator;    \r\n      this.path = calculator.path;\r\n      this.windList = calculator.windList;\r\n      \r\n      this.defaultZoom = Constant.defaultZoom;\r\n      \r\n      this.searchControl.events.add('resultshow', function(e) {\r\n                \r\n        this.path.clear(); \r\n        this.setZoom(this.defaultZoom);        \r\n        this.windList.shiftList(this.getCenter());\r\n                 \r\n        var index = e.get('index');    \r\n        var geoObjectsArray = this.searchControl.getResultsArray();\r\n        var resultName = geoObjectsArray[index].properties.get('name');\r\n\r\n        var newDz = {\r\n          name: resultName, \r\n          mapCenter: this.getCenter()\r\n        };    \r\n        this.dz.push(newDz);    \r\n        $(\"#dz\").append(\"<option>\" + newDz.name + \"</option>\");    \r\n        $(\"#dz\").children()[this.dz.length - 1].selected = true;    \r\n      }.bind(this));      \r\n    }\r\n        \r\n  } \r\n  provide(AppMap);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/AppMap.js?");

/***/ }),

/***/ "./src/scripts/Arrow.js":
/*!******************************!*\
  !*** ./src/scripts/Arrow.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Arrow */\r\nymaps.modules.define('Arrow', [\r\n  'Placemark',\r\n  'templateLayoutFactory', \r\n  'Constant'  \r\n],\r\nfunction(provide, Placemark, templateLayoutFactory, Constant) {\r\n  \r\n  /**\r\n   * Yandex Maps Placemark for Wind Arrow. \r\n   */\r\n  class Arrow extends Placemark {\r\n\r\n    constructor() {      \r\n      var arrowStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var arrowStartRadius = Constant.isMobile ? arrowStartSize : arrowStartSize/2; \r\n      \r\n      super(\r\n        //map.getCenter(),\r\n        [],        \r\n        {\r\n          arrowClass: \"arrow_selected\",  \r\n          //rotation: 90,\r\n          rotation: 0,           \r\n          size: arrowStartSize\r\n        }, \r\n        {\r\n          draggable: true,\r\n          iconLayout: templateLayoutFactory.createClass(\r\n              '<div class=\"$[properties.arrowClass]\" style=\"transform: rotate($[properties.rotation]deg);' + \r\n              'width: $[properties.size]px; height: $[properties.size]px;\"/>'\r\n            ), \r\n          iconShape: {\r\n            type: 'Circle',\r\n            coordinates: [arrowStartSize/2, arrowStartSize/2],\r\n            radius: arrowStartRadius\r\n          }          \r\n        }\r\n      );\r\n                    \r\n      this.arrowStartSize = arrowStartSize;\r\n      this.arrowStartRadius = arrowStartRadius;   \r\n      \r\n      this.heightPlacemarkShift = 0.0001;\r\n      \r\n      //var point = this.geometry.getCoordinates();\r\n      \r\n      // Placemark for Height of Chute at this vertex\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        //[point[0] + this.heightPlacemarkShift, point[1]],\r\n        [],         \r\n        {}, \r\n        {\r\n          preset: 'islands#darkOrangeStretchyIcon', \r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n    \r\n      //this.placemarkIsOn = true;    \r\n      this.isSelected = false;\r\n      this.isScaled = true;\r\n            \r\n      // when we drag arrow, we should drag its heightPlacemark too\r\n      this.events.add('drag', function(e) {\r\n        e.stopPropagation();\r\n        var newPoint = this.geometry.getCoordinates();       \r\n        this.heightPlacemark.geometry.setCoordinates(\r\n          [newPoint[0] + this.heightPlacemarkShift, newPoint[1]]\r\n        );          \r\n      }.bind(this)); \r\n            \r\n      this.map = null;\r\n\r\n      this.boundChange = this.boundChange.bind(this);\r\n            \r\n    }\r\n    \r\n    setCoordinates(coordinates) {\r\n      this.geometry.setCoordinates(coordinates);\r\n      this.heightPlacemark.geometry.setCoordinates(\r\n        [coordinates[0] + this.heightPlacemarkShift, coordinates[1]]\r\n      );      \r\n    }\r\n   \r\n   /**\r\n    * Change arrow selection\r\n    * @param {boolean || null} - isSelected    \r\n    */   \r\n    setSelection(isSelected = null) {\r\n\r\n      this.isSelected = (isSelected == null) ? \r\n        !this.isSelected : isSelected; \r\n      \r\n      var arrowClass = this.isSelected ? 'arrow_selected' : 'arrow';      \r\n      this.properties.set('arrowClass', arrowClass);   \r\n    }\r\n\r\n    getSelection() {\r\n      return(this.isSelected);\r\n    }    \r\n                 \r\n   /**\r\n    * Rotate arrow\r\n    */\r\n    rotate(angle) {\r\n      //this.properties.set('rotation', (-1)*angle + 90);\r\n      this.properties.set('rotation', (-1)*angle);      \r\n    }\r\n    \r\n    /**\r\n     * Arrow will have different size for different Zoom.\r\n     */\r\n    changeSize(newZoom) {\r\n      var size = (2**(newZoom - Constant.defaultZoom))*(this.arrowStartSize);\r\n      \r\n      var shape = \r\n        {\r\n          type: 'Circle',\r\n          coordinates: [size/2, size/2],\r\n          radius: (2**(newZoom - Constant.defaultZoom))*(this.arrowStartRadius)\r\n        };\r\n      \r\n      this.options.set('iconShape', shape);      \r\n      this.properties.set('size', size);\r\n      // properties.set call rebuild of Placemark, \r\n      // so, properties.set should stay after options.set      \r\n    }\r\n    \r\n    \r\n    addToMap(map, coordinates = null) {\r\n      this.map = map;\r\n      map.geoObjects.add(this);\r\n      \r\n      map.geoObjects.add(this.heightPlacemark);\r\n            \r\n      if (coordinates == null) {\r\n        var e = 0.005;\r\n        var mapCenter = map.getCenter();\r\n        var dlatitude = \r\n          (Math.random() - 0.5) * e * Math.cos((Math.PI/180) * mapCenter[0]);\r\n        var dlongtitude = (Math.random() - 0.5) * e;  \r\n        coordinates = mapCenter;\r\n        coordinates[0] += dlatitude;\r\n        coordinates[1] += dlongtitude;\r\n      }\r\n\r\n      this.setCoordinates(coordinates);\r\n      \r\n      this.setArrowToBeScaled(true);      \r\n    }\r\n    \r\n    removeFromMap(map) {\r\n      map.geoObjects.remove(this);\r\n      map.geoObjects.remove(this.heightPlacemark);         \r\n    }\r\n        \r\n    addPlacemark() {\r\n      this.map.geoObjects.add(this.heightPlacemark);      \r\n    } \r\n        \r\n    removePlacemark() {\r\n      this.map.geoObjects.remove(this.heightPlacemark);      \r\n    } \r\n      \r\n    /**\r\n     * Set arrow to be scaled with map zooming or \r\n     * not to be scaled. Map should be defined. \r\n     * @param {boolean} arrowIsScaled\r\n     */     \r\n    setArrowToBeScaled(arrowIsScaled) {\r\n      \r\n      this.isScaled = arrowIsScaled;\r\n    \r\n      if (arrowIsScaled) {\r\n        this.map.events.add('boundschange', this.boundChange);\r\n        var zoom = this.map.getZoom();\r\n        this.changeSize(zoom);\r\n                \r\n      } else {\r\n        this.map.events.remove('boundschange', this.boundChange); \r\n        this.changeSize(Constant.defaultZoom);       \r\n      }       \r\n    }\r\n    \r\n    getIsScaled() {\r\n      return(this.isScaled);\r\n    }\r\n    \r\n    /**\r\n     * Event function for boundChange event from \r\n     * this.setArrowToBeScaled function.\r\n     * @param {Event} e     \r\n     */\r\n    boundChange(e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        this.changeSize(newZoom);\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    print(str) {\r\n      this.heightPlacemark.properties.set(\"iconContent\", str);           \r\n    }\r\n    \r\n  }\r\n\r\n  provide(Arrow);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/Arrow.js?");

/***/ }),

/***/ "./src/scripts/BoundaryHeights.js":
/*!****************************************!*\
  !*** ./src/scripts/BoundaryHeights.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('BoundaryHeights', ['Constant'],\r\nfunction(provide, Constant) {\r\n  \r\n  /**\r\n   * Object consists of three varialables: startHeight, finalHeight and \r\n   * calculationDirection.\r\n   * StartHeight is a height of first vertex of Path.\r\n   * FinalHeight is a height of last vertex of Path.   \r\n   * StartHeight and finalHeight can have following values: number or null.\r\n   * CalculationDirection has boolean value. If it equal to true, \r\n   * calculation will be made from first vertex of Path to last vertex, \r\n   * otherwise - from last vertex to first vertex.   \r\n   * StartHeight and finalHeight have connection to html <input> \r\n   * elements $(\"#startHeight\") and $(\"#finalHeight\").\r\n   * CalculationDirection has connection to $(\"#calculationDirection\") \r\n   * checkbox element. In constructor, we create two-side connection \r\n   * between those varialables and html elements.   \r\n   */\r\n  class BoundaryHeights {\r\n\r\n    constructor() {\r\n      // Value must be null or number\r\n      this.startHeight = null;\r\n      this.finalHeight = null;\r\n      \r\n      // Value must be bool\r\n      this.calculationDirection = Constant.defaultCalculationDirection;\r\n      $(\"#calculationDirection\").prop(\"checked\", !this.calculationDirection);\r\n            \r\n      // This objects should be set up by \r\n      // setPath() and setCalculator() methods\r\n      this.path = null;\r\n      this.calculator = null;\r\n      \r\n      this.setDefaultHeights();      \r\n      this.startProcessingHeightFields();\r\n      this.startProcessingCalculationDirectionField();      \r\n    }\r\n    \r\n    getCalculationDirection() {\r\n      return this.calculationDirection;\r\n    }\r\n    \r\n    setCalculationDirection(calculationDirection) {\r\n      this.calculationDirection = calculationDirection;      \r\n    }\r\n    \r\n        \r\n    setPath(path) {\r\n      this.path = path;\r\n    }\r\n    \r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @param {boolean} calculationDirection\r\n     */    \r\n    setDefaultHeights() {\r\n      if (this.calculationDirection) {\r\n        this.setStartHeight(Constant.defaultStartHeight);\r\n        this.setFinalHeight(Constant.defaultStartHeight);\r\n      } else {\r\n        this.setStartHeight(Constant.defaultFinalHeight);\r\n        this.setFinalHeight(Constant.defaultFinalHeight);        \r\n      }\r\n      \r\n      this.setPropDisabled();    \r\n    } \r\n    \r\n    /**\r\n     * Disable/enable heights field with dependence of \r\n     * calculationDirection.\r\n     */\r\n    setPropDisabled() {\r\n      $(\"#startHeight\").prop(\"disabled\", !this.calculationDirection);\r\n      $(\"#finalHeight\").prop(\"disabled\", this.calculationDirection);            \r\n    }\r\n\r\n    /**\r\n     * @param {number || null} finalHeight\r\n     */    \r\n    setStartHeight(startHeight) {\r\n      this.startHeight = startHeight;\r\n      this.printStartHeight();\r\n    }\r\n    \r\n    printStartHeight() {\r\n      if (this.startHeight != null) {\r\n        $(\"#startHeight\").val(Math.floor(this.startHeight));\r\n      } else {\r\n        if (this.calculationDirection) {\r\n          $(\"#startHeight\").val(\"\");  \r\n        } else {\r\n          $(\"#startHeight\").val(\"не определена\");\r\n        }  \r\n      }                \r\n    }\r\n    \r\n    /**\r\n     * @param {number || null} finalHeight\r\n     */\r\n    setFinalHeight(finalHeight) {\r\n      this.finalHeight = finalHeight;\r\n      this.printFinalHeight(); \r\n    }\r\n\r\n    printFinalHeight() {\r\n      if (this.finalHeight != null) {\r\n        $(\"#finalHeight\").val(Math.floor(this.finalHeight));\r\n      } else {        \r\n        if (this.calculationDirection) {\r\n          $(\"#finalHeight\").val(\"не определена\");  \r\n        } else {\r\n          $(\"#finalHeight\").val(\"\");\r\n        }  \r\n      }                \r\n    }        \r\n    \r\n    \r\n    makeHeightsEqual() {\r\n      if (this.calculationDirection) {\r\n        this.setFinalHeight(this.startHeight);        \r\n      } else {\r\n        this.setStartHeight(this.finalHeight);  \r\n      }      \r\n    }\r\n    \r\n    \r\n    startProcessingHeightFields() {\r\n      \r\n      $(\"#startHeight\").change(function () {       \r\n        var s = $(\"#startHeight\").val();\r\n        var n = Number.parseInt(s);\r\n        if ((n >= 0) && (n <= Constant.maxHeight)) {\r\n          \r\n          this.startHeight = n;\r\n          this.printStartHeight();\r\n     \r\n          if (this.path.length > 0) {  \r\n            this.calculator.calculateHeight();\r\n            this.path.printHeightsAndWindPoints();\r\n          } \r\n        } else {\r\n          this.printStartHeight();\r\n        }\r\n      }.bind(this));\r\n\r\n      \r\n      $(\"#finalHeight\").change(function () {       \r\n        var s = $(\"#finalHeight\").val();\r\n        var n = Number.parseFloat(s);\r\n        if ((n >= 0) && (n <= Constant.maxHeight)) {\r\n          this.finalHeight = n;\r\n          this.printFinalHeight();\r\n          \r\n          if (this.path.length > 0) {\r\n            this.calculator.calculateHeight();\r\n            this.path.printHeightsAndWindPoints();                       \r\n          } \r\n        } else {\r\n          this.printFinalHeight();\r\n        }    \r\n      }.bind(this));    \r\n    }  \r\n\r\n\r\n    startProcessingCalculationDirectionField() { \r\n  \r\n      $(\"#calculationDirection\").change(function() {\r\n        var isChecked = $(\"#calculationDirection\").prop(\"checked\");\r\n        this.calculationDirection = !isChecked;\r\n        this.setPropDisabled();\r\n                \r\n        if (this.path.length > 0) {         \r\n          this.calculator.calculateHeight();\r\n          this.printStartHeight();\r\n          this.printFinalHeight();\r\n          this.path.printHeightsAndWindPoints();              \r\n        } else {           \r\n          this.makeHeightsEqual();         \r\n        }                              \r\n      }.bind(this));     \r\n    } \r\n  } \r\n  provide(BoundaryHeights);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/BoundaryHeights.js?");

/***/ }),

/***/ "./src/scripts/Calculator.js":
/*!***********************************!*\
  !*** ./src/scripts/Calculator.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Calculator */\r\nymaps.modules.define('Calculator', [\r\n  'VectorMath', \r\n  'Constant'\r\n],\r\nfunction(provide, VectorMath, Constant) {\r\n  /**\r\n   * This class calculates: \r\n   * a) heights at all vertices of the Path \r\n   * (it will be kept in vertex.height varialables where vertex belongs \r\n   * to Path), \r\n   * b) points on the Path where wind changes (it will be kept in \r\n   * wind.pathPoint varialables where wind belongs to WindList). \r\n   * Calculation can be done from start vertex to final vertex or \r\n   * vice versa. Direction of calculation is determined by \r\n   * calculationDirection varialable.\r\n   */\r\n  class Calculator {\r\n    /**\r\n     * @param {Path} path - list of vertices and edges of Chute Path.\r\n     * @param {Chute} chute - Chute velocity.     \r\n     * @param {WindList} windList\r\n     * @param {BoundaryHeights} boundaryHeights     \r\n     */\r\n    constructor(path, chute, windList, boundaryHeights) {            \r\n      this.path = path;\r\n      this.chute = chute;\r\n      this.windList = windList;      \r\n\r\n      this.boundaryHeights = boundaryHeights;\r\n\r\n      // 'true' for calculation from the beginning of Path to the end of Path, \r\n      // 'false' for calculation from the end of Path to the beginning of Path.       \r\n      //this.calculationDirection = boundaryHeights.calculationDirection;\r\n    }\r\n\r\n    getCalculationDirection() {\r\n      return this.boundaryHeights.getCalculationDirection();      \r\n    }    \r\n    \r\n    setCalculationDirection(calculationDirection) {\r\n      this.boundaryHeights.setCalculationDirection(calculationDirection);      \r\n    }\r\n    \r\n    setStartHeight(startHeight) {\r\n      this.boundaryHeights.setStartHeight(startHeight);\r\n    }\r\n    \r\n    setFinalHeight(finalHeight) {\r\n      this.boundaryHeights.setFinalHeight(finalHeight);\r\n    }\r\n\r\n    setDefaultHeights() {\r\n      this.boundaryHeights.setDefaultHeights();      \r\n    }\r\n    \r\n\r\n    /**\r\n     * Main calculation function.\r\n     * If this.calculationDirection == true, then calculator begins computation \r\n     * from start vertex and boundaryHeights.startHeight height; \r\n     * if this.calculationDirection == false, then calculator begins computation \r\n     * from final vertex and boundaryHeights.finalHeight height.          \r\n     */\r\n    calculateHeight() {\r\n      if (this.path.length == 0) {\r\n        console.warn(\"Cannot calculate: Path is empty\");\r\n        return;\r\n      }  \r\n    \r\n      if (this.boundaryHeights.getCalculationDirection()) {\r\n        this.calculateHeightForward();\r\n      } else {\r\n        this.calculateHeightBack();\r\n      }       \r\n    }\r\n    \r\n    /**\r\n     * Case: forward calculation.\r\n     * It calculates: 1) heights at vertices of Path,  \r\n     * 2) points on Path which corresponding to winds from WindList, \r\n     * 3) boundaryHeights.finalHeight.  \r\n     */     \r\n    calculateHeightForward() {\r\n                                     \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n\r\n      var wind = windList.lastWind;       \r\n      while(wind != null) {\r\n        wind.pathPoint = null;\r\n        wind = wind.prevWind;\r\n      }           \r\n            \r\n      var vertex = path.firstVertex;\r\n      while(vertex != null) {\r\n        vertex.height = null;\r\n        vertex = vertex.nextVertex;\r\n      }      \r\n            \r\n      // Case: startHeight is undefined (equals null)      \r\n      if (this.boundaryHeights.startHeight == null) {\r\n        this.boundaryHeights.setFinalHeight(null);        \r\n        return;        \r\n      }\r\n          \r\n      var vertexA = path.firstVertex;      \r\n      var pointA = vertexA.geometry.getCoordinates();\r\n      vertexA.height = this.boundaryHeights.startHeight; \r\n            \r\n      // Skip winds without heights\r\n      // (remember that suface wind always exists)      \r\n      wind = windList.lastWind;\r\n      while(wind.getHeight() == null) {\r\n        wind = wind.prevWind;\r\n      }\r\n      \r\n      // Skip to wind corresponding to first (highest) vertex      \r\n      while(wind.getHeight() >= vertexA.height) {\r\n        \r\n        if (wind.getHeight() == vertexA.height) {\r\n          wind.pathPoint = pointA;  \r\n        }\r\n        if (wind == windList.firstWind) break;\r\n        \r\n        wind = wind.prevWind;\r\n      }\r\n\r\n      if (path.length == 1) return;        \r\n                                    \r\n      var vertex = vertexA.nextVertex;\r\n      while(vertex != null) {\r\n        vertex.height = null;\r\n        vertex = vertex.nextVertex;\r\n      } \r\n      \r\n      var vertexB = vertexA.nextVertex;\r\n                  \r\n      // Later, pointA can be any point of edge, \r\n      // pointB always will be vertex, \r\n      // pointA and pointB belong to the one edge \r\n      var pointB = vertexB.geometry.getCoordinates();      \r\n      var pointAHeight = vertexA.height;\r\n\r\n      var edgeChuteDirection = vertexA.nextLine.getChuteDirection();\r\n      \r\n      while(true) {\r\n        \r\n        //console.log(\"edgeChuteDirection: \" + edgeChuteDirection); \r\n                \r\n        // edgeChuteVelocity is velocity along edge [pointA, pointB] at pointA.\r\n        // 'wind' is a wind in pointA. \r\n        // Our aim is to calculate height in pointB.       \r\n        var edgeChuteVelocity = \r\n          this.calculateChuteEdgeVelocity(\r\n            pointA, pointB, chute, wind, edgeChuteDirection\r\n          ); \r\n                                                                               \r\n        if (edgeChuteVelocity < 0) break;\r\n\r\n        // Case: chute is hanging above pointA\r\n        // This is top boundary of previous wind        \r\n        if (edgeChuteVelocity == 0) {\r\n          if (wind != windList.firstWind) {\r\n            pointAHeight = wind.getHeight();\r\n            wind.pathPoint = pointA;             \r\n            wind = wind.prevWind;            \r\n            continue;\r\n          } else break;          \r\n        }\r\n                                       \r\n        if (edgeChuteVelocity > 0) {\r\n          \r\n          var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n          var t1 = dist / edgeChuteVelocity;\r\n          \r\n          if (wind != windList.firstWind) {\r\n          \r\n            var t2 = (pointAHeight - wind.getHeight()) / chute.verticalVel;\r\n                        \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, chute will reach (vertex) pointB\r\n                                                                      \r\n              vertexB.height = pointAHeight - t1 * this.chute.verticalVel;\r\n                            \r\n              if (t2 == t1) {\r\n                wind.pathPoint = pointB;\r\n                wind = wind.prevWind;                \r\n              } \r\n                            \r\n              if (vertexB == path.lastVertex) break;\r\n              \r\n              vertexA = vertexB;\r\n              vertexB = vertexA.nextVertex;\r\n              \r\n              pointA = vertexA.geometry.getCoordinates();\r\n              pointB = vertexB.geometry.getCoordinates(); \r\n\r\n              edgeChuteDirection = vertexA.nextLine.getChuteDirection();              \r\n\r\n              pointAHeight = vertexA.height;  \r\n              \r\n              continue;\r\n              \r\n            } else {              \r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n              \r\n              pointA = VectorMath.findIntermediatePoint(\r\n                pointA, pointB, (t2 * edgeChuteVelocity)/dist\r\n              );\r\n              \r\n              pointAHeight -= t2 * this.chute.verticalVel;\r\n                            \r\n              wind.pathPoint = pointA;                                                                      \r\n              wind = wind.prevWind;\r\n              \r\n              continue;\r\n            }\r\n\r\n          } else {\r\n            // case: wind = windList.firstWind\r\n                        \r\n            if (t1 > Constant.maxFlightTime) break;\r\n                   \r\n            vertexB.height = pointAHeight - t1 * this.chute.verticalVel;\r\n                                    \r\n            if (vertexB.height == 0) {\r\n              wind.pathPoint = pointB;\r\n            }\r\n                             \r\n            if (pointAHeight > 0 && vertexB.height < 0) {                   \r\n              wind.pathPoint = \r\n                VectorMath.findIntermediatePoint(\r\n                  pointA, pointB,  pointAHeight/(pointAHeight - vertexB.height)\r\n                );              \r\n            }                 \r\n                                                                                  \r\n            if (vertexB == path.lastVertex) break;\r\n            \r\n            vertexA = vertexB;\r\n            vertexB = vertexA.nextVertex;\r\n            \r\n            pointA = vertexA.geometry.getCoordinates();\r\n            pointB = vertexB.geometry.getCoordinates();\r\n\r\n            edgeChuteDirection = vertexA.nextLine.getChuteDirection();            \r\n\r\n            pointAHeight = vertexA.height;              \r\n\r\n            continue;                  \r\n          }          \r\n        }               \r\n      }\r\n      \r\n      this.boundaryHeights.setFinalHeight(path.lastVertex.height);       \r\n    }\r\n    \r\n\r\n    /**\r\n     * Case: back calculation.\r\n     * It calculates: 1) heights at vertices of Path,  \r\n     * 2) points on Path which corresponding to winds from WindList, \r\n     * 3) boundaryHeights.startHeight.    \r\n     */    \r\n    calculateHeightBack() {\r\n      \r\n      //console.log(\"back computation\");\r\n      \r\n      var path = this.path, \r\n          chute = this.chute, \r\n          windList = this.windList;\r\n\r\n      var wind = windList.firstWind;       \r\n      while(wind != null) {\r\n        wind.pathPoint = null;\r\n        wind = wind.nextWind;\r\n      }           \r\n\r\n      var vertex = path.firstVertex;\r\n      while(vertex != null) {\r\n        vertex.height = null;\r\n        vertex = vertex.nextVertex;\r\n      }      \r\n      \r\n      // Case: finalHeight is undefined (equals null)\r\n      if (this.boundaryHeights.finalHeight == null) {\r\n        this.boundaryHeights.setStartHeight(null);        \r\n        return;    \r\n      }    \r\n                    \r\n      var vertexB = path.lastVertex;      \r\n      var pointB = vertexB.geometry.getCoordinates();\r\n      vertexB.height = this.boundaryHeights.finalHeight;\r\n      \r\n      wind = windList.firstWind;      \r\n      if (wind.getHeight() < vertexB.height) {\r\n        // that is, 0 < vertexB.height\r\n            \r\n        while(true) {\r\n                    \r\n          if (wind.nextWind == null) break;          \r\n          if (wind.nextWind.getHeight() == null) break;\r\n          \r\n          if (wind.nextWind.getHeight() > vertexB.height) break;\r\n          \r\n          if (wind.nextWind.getHeight() == vertexB.height) {\r\n            wind = wind.nextWind;\r\n            wind.pathPoint = pointB;\r\n            break;\r\n          }\r\n          \r\n          wind = wind.nextWind;          \r\n        }   \r\n      }  \r\n\r\n      if (path.length == 1) return;\r\n\r\n      var vertexA = vertexB.prevVertex;\r\n      \r\n      // pointA will always be vertex, \r\n      // pointB can be vertex or point on the edge      \r\n      var pointA = vertexA.geometry.getCoordinates();\r\n     \r\n      var pointBHeight = vertexB.height;\r\n\r\n      var edgeChuteDirection = vertexA.nextLine.getChuteDirection();\r\n            \r\n      while(true) {\r\n         \r\n        // Note: here pointA is only for setting direction; \r\n        // if there will be changing wind on the edge, \r\n        // the chute will fly with following velocity only after \r\n        // last changing (in the direction, determined by \r\n        // vector pointApointB)        \r\n        var edgeChuteVelocity = \r\n          this.calculateChuteEdgeVelocity(\r\n            pointA, pointB, chute, wind, edgeChuteDirection\r\n          );\r\n        \r\n        //console.log(\"edgeChuteVelocity: \" + edgeChuteVelocity);\r\n        \r\n        // In this case it is impossible to flight this edge        \r\n        if (edgeChuteVelocity < 0) break;\r\n\r\n        // Case: chute is hanging above pointB.          \r\n        // This is bottom boundary of current wind        \r\n        if (edgeChuteVelocity == 0) {\r\n          \r\n          if (wind == windList.lastWind || wind.nextWind.getHeight() == null) {\r\n            break;\r\n          }                   \r\n          \r\n          wind = wind.nextWind;          \r\n          pointBHeight = wind.getHeight();                                      \r\n          wind.pathPoint = pointB;          \r\n          continue;                       \r\n        }\r\n                             \r\n        if (edgeChuteVelocity > 0) {\r\n          \r\n          if (wind != windList.lastWind && wind.nextWind.getHeight() != null) {\r\n          \r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n            var t1 = dist / edgeChuteVelocity;\r\n                         \r\n            var t2 = \r\n              (wind.nextWind.getHeight() - pointBHeight) / chute.verticalVel;\r\n          \r\n            if (t2 >= t1) {\r\n              // Case: with current wind, pointB is reachable from pointA  \r\n            \r\n              //if (t1 > Constant.maxFlightTime) break;\r\n              \r\n              vertexA.height = pointBHeight + t1 * this.chute.verticalVel;\r\n              \r\n              if (\r\n                wind == windList.firstWind \r\n                && (pointBHeight < 0) \r\n                && (vertexA.height > 0) \r\n              ) {\r\n                wind.pathPoint = \r\n                  VectorMath.findIntermediatePoint(\r\n                    pointA, pointB,  vertexA.height/(vertexA.height - pointBHeight)\r\n                  );            \r\n              }               \r\n                  \r\n              if (vertexA == path.firstVertex) break;\r\n              \r\n              vertexB = vertexA;\r\n              vertexA = vertexB.prevVertex;\r\n              \r\n              pointA = vertexA.geometry.getCoordinates();\r\n              pointB = vertexB.geometry.getCoordinates();\r\n\r\n              pointBHeight = vertexB.height;\r\n              \r\n              edgeChuteDirection = vertexA.nextLine.getChuteDirection();\r\n                                                               \r\n              continue;  \r\n            } else {\r\n\r\n              var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);\r\n                           \r\n              pointB = VectorMath.findIntermediatePoint(\r\n                pointB, pointA, (t2 * edgeChuteVelocity)/dist \r\n              ); \r\n             \r\n              pointBHeight += t2 * this.chute.verticalVel;\r\n                                                                      \r\n              wind = wind.nextWind;\r\n              wind.pathPoint = pointB;\r\n              \r\n              continue;\r\n            }\r\n          } else {  \r\n            // case: wind == windList.lastWind || wind.nextWind.getHeight() == null \r\n            \r\n            var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);          \r\n            var t1 = dist / edgeChuteVelocity;\r\n            \r\n            if (t1 > Constant.maxFlightTime) break;\r\n                                    \r\n            vertexA.height = pointBHeight + (t1 * this.chute.verticalVel);\r\n\r\n            if (\r\n              wind == windList.firstWind \r\n              && (pointBHeight < 0) \r\n              && (vertexA.height > 0) \r\n            ) {\r\n              wind.pathPoint = \r\n                VectorMath.findIntermediatePoint(\r\n                  pointA, pointB,  vertexA.height/(vertexA.height - pointBHeight)\r\n                );            \r\n            } \r\n                                                                      \r\n            if (vertexA == path.firstVertex) break;\r\n            \r\n            vertexB = vertexA;\r\n            vertexA = vertexB.prevVertex;\r\n            \r\n            pointA = vertexA.geometry.getCoordinates();\r\n            pointB = vertexB.geometry.getCoordinates(); \r\n\r\n            pointBHeight = vertexB.height;            \r\n\r\n            edgeChuteDirection = vertexA.nextLine.getChuteDirection();\r\n            \r\n            continue;                     \r\n          }\r\n        }                                \r\n      }\r\n\r\n      this.boundaryHeights.setStartHeight(path.firstVertex.height);         \r\n      return;      \r\n    }\r\n\r\n    \r\n    /** \r\n     * Calculate Absolute (relatively to Earth) Chute Velocity \r\n     * along Line Segment (we suppose that chute is flying along this line segment).\r\n     * @param {number[]} pointA - Yandex Maps Coordinates: (latitude, longitude).\r\n     * @param {number[]} pointB - Yandex Maps Coordinates: (latitude, longitude). \r\n     * @param {Chute} chute \r\n     * @param {Wind} wind\r\n     * @param [boolean] edgeChuteDirection - Skydiver can fly with his face directed \r\n     * with or against edge.      \r\n     * @return {number} chuteEdgeVelocity - Absolute Chute Velocity along \r\n     * line segment [pointA, pointB]; in m/sec; \r\n     * Cases: chuteEdgeVelocity < 0 - If it is impossible to fly this segment;\r\n     * chuteEdgeVelocity == 0 - hanging above pointA all time;    \r\n     * chuteEdgeVelocity > 0 - chute will fly from pointA to pointB.\r\n     */    \r\n    calculateChuteEdgeVelocity(\r\n      pointA, pointB, chute, wind, edgeChuteDirection = true\r\n    ) {\r\n          \r\n      // Let's find right orthonormal basis (e, f), first vector of which (e)\r\n      // has the same direction with vector [pointA, pointB].      \r\n      // Yandex Maps Coordinates: (latitude, longitude)\r\n      // Latitude is increasing from bottom to top (-90deg, 90deg)\r\n      // Longitude is increasing from West to East (-180deg, 180deg)\r\n            \r\n      function sign(a) {\r\n        if (a>0) return 1;\r\n        if (a==0) return 0;\r\n        return -1;\r\n      }      \r\n      \r\n      var sx = sign(pointB[1] - pointA[1]);\r\n      var sy = sign(pointB[0] - pointA[0]);       \r\n    \r\n      var pointC = [pointA[0], pointB[1]];\r\n      \r\n      // now (ex, ey) are coordinates of vector e in standart orthonormal basis:\r\n      // x has direction from left to right, \r\n      // y has direction from bottom to top, \r\n      // scale: 1 meter\r\n      var ex = sx * ymaps.coordSystem.geo.getDistance(pointC, pointA);\r\n      var ey = sy * ymaps.coordSystem.geo.getDistance(pointC, pointB);\r\n                \r\n      var d = Math.sqrt(ex*ex + ey*ey);\r\n      ex = ex / d;\r\n      ey = ey / d;\r\n      \r\n      var fx = -ey;\r\n      var fy = ex;\r\n      \r\n      // Let's find coordinates (we, wf) of vector 'wind' in basis (e, f).\r\n      // (e, f) is orthogonal basis, so we = (wind, e), wf = (wind, f).\r\n      var [wx, wy] = wind.getXY();\r\n   \r\n      var we = wx * ex + wy * ey; \r\n      var wf = wx * fx + wy * fy;     \r\n       \r\n      // Let's find coordinates (ce, cf) of chute velocity \r\n      // in basis (e, f):\r\n      \r\n      var cf = (-1)*wf;\r\n      \r\n      // it is impossible to fly this segment\r\n      if (chute.horizontalVel < Math.abs(cf)) return(-1);\r\n  \r\n      var directionSign = edgeChuteDirection ? 1 : -1; \r\n  \r\n      var ce = directionSign * Math.sqrt(chute.horizontalVel**2 - cf**2);\r\n      \r\n      // We consider only case, where ce >= 0 \r\n      // (it's always the case, if chute velocity is greater than wind velocity)    \r\n      // In general case you should consider case, \r\n      // when ce < 0 (case when diver flies forward with his back)   \r\n\r\n      var chuteEdgeVelocity = ce + we;\r\n      return(chuteEdgeVelocity);       \r\n    }   \r\n  }\r\n      \r\n  provide(Calculator);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Calculator.js?");

/***/ }),

/***/ "./src/scripts/Chute.js":
/*!******************************!*\
  !*** ./src/scripts/Chute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Chute', [],\r\nfunction(provide) {\r\n\r\n  class Chute {\r\n    /**\r\n     * @param {number} horizontalVel - Horizontal chute velocity, in m/sec.\r\n     * @param {number} verticalVel - Vertical chute velocity, in m/sec.     \r\n     */\r\n    constructor(horizontalVel, verticalVel) {\r\n      this.horizontalVel = horizontalVel; \r\n      this.verticalVel = verticalVel;   \r\n    }   \r\n  }\r\n      \r\n  provide(Chute);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Chute.js?");

/***/ }),

/***/ "./src/scripts/CircleVertex.js":
/*!*************************************!*\
  !*** ./src/scripts/CircleVertex.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('CircleVertex', ['Circle'],\r\nfunction(provide, Circle) {\r\n\r\n  class CircleVertex extends Circle {\r\n    /**\r\n     * @param {number[]} center - Yandex.Maps coordinates.\r\n     * @param {number} radius\r\n     * @param {number} zIndex - z-index of Circle.\r\n     */\r\n    constructor(center, radius, zIndex=0) {\r\n      super([center, radius]);\r\n      this.options.set(\"fillColor\", \"#0000FF\");\r\n      this.options.set(\"strokeColor\", \"#0000FF\");\r\n      this.options.set(\"zIndex\", zIndex);\r\n    }\r\n  }\r\n  provide(CircleVertex);\r\n});\r\n\n\n//# sourceURL=webpack:///./src/scripts/CircleVertex.js?");

/***/ }),

/***/ "./src/scripts/Constant.js":
/*!*********************************!*\
  !*** ./src/scripts/Constant.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Constant', [],\r\nfunction(provide) {\r\n\r\n// Determine mobile or desktop case.\r\nvar isMobile = false;\r\nif(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\r\n  isMobile = true;\r\n}\r\n\r\n  var Constant = {\r\n    defaultStartHeight: 300,\r\n    defaultFinalHeight: 0,\r\n    defaultZoom: 16,\r\n    defaultCalculationDirection: true,  \r\n    // We will not consider cases when horizontal velocity\r\n    // is more than maxChuteHorizontalVelocity\r\n    maxChuteHorizontalVelocity: 100,  // wingsuit\r\n    maxChuteVerticalVelocity: 50,  // free fall\r\n    maxHeight: 10000,\r\n    maxWindValue: 40,\r\n    // If we will fly more than maxFlightTime, then\r\n    // it is impossible to fly this path\r\n    maxFlightTime: 3600, // 1 hour\r\n    isMobile: isMobile\r\n  }\r\n\r\n  provide(Constant);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Constant.js?");

/***/ }),

/***/ "./src/scripts/DialogWindows.js":
/*!**************************************!*\
  !*** ./src/scripts/DialogWindows.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('DialogWindows', ['Constant'],\r\nfunction(provide, Constant) {\r\n\r\n  var DialogWindows = {};\r\n  /**\r\n   * @param {Calculator} calculator\r\n   */\r\n  DialogWindows.initializeWindows = function(calculator) {\r\n    \r\n    var path = calculator.path;\r\n        chute = calculator.chute;\r\n        windList = calculator.windList;\r\n        boundaryHeights = calculator.boundaryHeights;    \r\n    var map = path.map;    \r\n    var wind = windList.currentWind;\r\n    \r\n    initSettingsWindow();\r\n    initChuteWindow();\r\n    initWindListWindow();\r\n           \r\n    /**\r\n     * Settings (Dz and Start Height Window) initialization:\r\n     *   default options for <input> tags, \r\n     *   events 'change' for <input> tags.\r\n     */\r\n    function initSettingsWindow() {\r\n      // Set default options: dz array\r\n      for(var i=0; i<map.dz.length; i++) {\r\n        $(\"#dz\").append(\"<option>\" + map.dz[i].name + \"</option>\");    \r\n      }\r\n      \r\n      $(\"#dz\").on(\"change\", function() {\r\n        var mapCenter = map.dz[this.selectedIndex].mapCenter;      \r\n        map.setCenter(mapCenter, Constant.defaultZoom);\r\n        windList.shiftList(mapCenter);                \r\n        // path.clear() will print results too\r\n        path.clear();\r\n      });\r\n            \r\n      $(\"#pathDirection\").change(function() {\r\n        var isChecked = $(this).prop(\"checked\");\r\n        path.setPathDirection(!isChecked);                \r\n      }); \r\n    }    \r\n              \r\n    /** \r\n     * Chute Window initialization.\r\n     */\r\n    function initChuteWindow() {\r\n      $(\"#chutehorvel\").val(chute.horizontalVel);\r\n      $(\"#chutevervel\").val(chute.verticalVel);\r\n    \r\n      $(\"#chutehorvel, #chutevervel\").on(\"change\", function () {      \r\n        var chutehorvel = Number.parseFloat($(\"#chutehorvel\").val());\r\n        if ((chutehorvel>=0) && (chutehorvel<=Constant.maxChuteHorizontalVelocity)) {\r\n          chute.horizontalVel = chutehorvel;\r\n        }\r\n        $(\"#chutehorvel\").val(chute.horizontalVel);\r\n                     \r\n        var chutevervel = Number.parseFloat($(\"#chutevervel\").val());\r\n        if (( chutevervel>=0) && (chutevervel<=Constant.maxChuteVerticalVelocity)) {\r\n          chute.verticalVel = chutevervel;    \r\n        } \r\n        $(\"#chutevervel\").val(chute.verticalVel);        \r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();              \r\n        }\r\n      });\r\n    }    \r\n\r\n    /** \r\n     * WindList Window initialization.\r\n     */    \r\n    function initWindListWindow() {\r\n      \r\n      $(\"#windValueInput\").prop(\"max\", \"\" + Constant.maxWindValue);\r\n        \r\n      windList.printCurrentWindWindow();   \r\n                   \r\n      $(\"#windHeightInput\").on(\"change\", function() {        \r\n        // Remember that #windHeightInput is disabled for firstWind\r\n        \r\n        // If we jump to firstWind by use of Tab button (our app has such \r\n        // possibility), it will call windList.setHeightToCurrentWind (it will be error).\r\n        if (windList.currentWind == windList.firstWind) return;\r\n        \r\n        var s = $(\"#windHeightInput\").val();        \r\n        var n = Number.parseFloat(s);\r\n        \r\n        if ((n > 0) && (n <= Constant.maxHeight)) { \r\n          if (windList.setHeightToCurrentWind(n)) { \r\n            $(\"#windHeightInput\").val(n);\r\n          } else {\r\n            var v = windList.currentWind.getHeight();\r\n            var w = (v == null) ? '' : v;             \r\n            $(\"#windHeightInput\").val(w);\r\n            alert(\"Такая высота уже была!\");            \r\n          }            \r\n        } else {\r\n          var v = windList.currentWind.getHeight();\r\n          var w = (v == null) ? '' : v;             \r\n          $(\"#windHeightInput\").val(w);\r\n          alert(\"Значение не попадает в допустимый интервал!\");\r\n        } \r\n                        \r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();          \r\n        }        \r\n      });\r\n      \r\n                       \r\n      // Change Wind Direction in Wind Window.  \r\n      $(\"#windDirectionInput\").on('input change', function() {\r\n        var angleStr = $(\"#windDirectionInput\").val();          \r\n        var angle = Number.parseInt(angleStr);\r\n        \r\n        windList.setCurrentAngle(angle);\r\n        windList.printCurrentWindWindow();\r\n\r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();           \r\n        }            \r\n      });\r\n\r\n      // Change Wind Value in Wind Window.   \r\n      $(\"#windValueInput\").on('input change', function() {\r\n        var valueStr = $(\"#windValueInput\").val();\r\n        var value = Number.parseInt(valueStr);\r\n\r\n        windList.setCurrentValue(value);\r\n        windList.printCurrentWindWindow();\r\n        \r\n        if (path.length > 0) {\r\n          calculator.calculateHeight();\r\n          path.printHeightsAndWindPoints();          \r\n        }       \r\n      });\r\n      \r\n      // Draw scales for Wind Window    \r\n      drawWindScales();\r\n      \r\n      /*      \r\n      $(\"#arrowScale\").prop(\"checked\", windList.firstWind.arrow.getIsScaled());\r\n      \r\n      $(\"#arrowScale\").change(function() {\r\n        var isChecked = $(this).prop(\"checked\");\r\n        windList.currentWind.arrow.setArrowToBeScaled(isChecked);               \r\n      });   */\r\n      \r\n      \r\n      function initWindWindow() {\r\n        if (windList.currentWind == windList.firstWind) {\r\n          $(\"#windHeightInput\").prop(\"disabled\", true);        \r\n        } else {\r\n          $(\"#windHeightInput\").prop(\"disabled\", false);\r\n        }\r\n        $(\"#windHeightInput\").val(windList.currentWind.getHeight());    \r\n        $(\"#windDirectionInput\").val(windList.currentWind.getAngle());\r\n        $(\"#windValueInput\").val(windList.currentWind.getValue());  \r\n        //$(\"#arrowScale\").prop(\"checked\", windList.currentWind.arrow.getIsScaled());        \r\n      }                        \r\n    }\r\n   \r\n    /**\r\n     * Draw scales for Wind Window:\r\n     *   wind direction scale (E, N, W, S, E),\r\n     *   wind velocity scale (0, ..., Constant.maxWindValue m/s)\r\n     */\r\n    function drawWindScales() {\r\n      // Create legend for direction range input\r\n      var directionPlateSpan = 5;\r\n      var directionPlateNumber = 4*directionPlateSpan + 1;\r\n      var windValuePlateNumber = 0;\r\n      \r\n      for(var i=0; i<directionPlateNumber; i++) {\r\n        var str = \"\";\r\n        switch (i) {\r\n          case 0: \r\n            str = \"В\";\r\n            break;\r\n          case directionPlateSpan: \r\n            str = \"С\";\r\n            break;\r\n          case directionPlateSpan*2: \r\n            str = \"З\";\r\n            break;      \r\n          case directionPlateSpan*3: \r\n            str = \"Ю\";\r\n            break;\r\n          case directionPlateSpan*4: \r\n            str = \"В\";\r\n            break;\r\n          default:\r\n            str = \"&nbsp\";          \r\n        }\r\n        $(\"#windDirectionInputScale\").append(\"<div class='directionPlate'>\" + str + \"</div>\");\r\n    \r\n        var str2;        \r\n        if (i % 5 == 0) {\r\n          str2 = windValuePlateNumber;\r\n          windValuePlateNumber += (Constant.maxWindValue / 4);\r\n        } else {\r\n          str2 = \"&nbsp\";\r\n        }        \r\n        $(\"#windValueInputScale\").append(\"<div class='directionPlate'>\" + str2 + \"</div>\");\r\n       \r\n      }\r\n      $(\".directionPlate\").css({\r\n        \"width\": 100/(directionPlateNumber) + \"%\",\r\n        \"float\": \"left\", \r\n        \"text-align\": \"center\"\r\n      });     \r\n    }     \r\n  }\r\n\r\n  provide(DialogWindows);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/DialogWindows.js?");

/***/ }),

/***/ "./src/scripts/Keyboard.js":
/*!*********************************!*\
  !*** ./src/scripts/Keyboard.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Keyboard', ['Constant'],\r\nfunction(provide, Constant) {\r\n\r\n  var Keyboard = {};\r\n  \r\n  /**\r\n   * Keys: left, right, up, down are for changing wind direction\r\n   * and wind value. TAB is for selecting next wind.\r\n   * Enter key on <input> tag will cause loose of focus.\r\n   * @param {Calculator} calculator   \r\n   */\r\n  Keyboard.startKeyboardProcessing = function(calculator) {\r\n    \r\n    var windList = calculator.windList, \r\n        path = calculator.path;\r\n    \r\n    //  Change Wind by keyboard.\r\n    $(\"html\").keydown(function(e) {\r\n   \r\n      var angle = windList.currentWind.getAngle(),\r\n          value = windList.currentWind.getValue();\r\n          \r\n      var key = e.which;\r\n      switch(key) {\r\n        case 39:\r\n          angle += 5;\r\n          windList.setCurrentAngle(angle);\r\n          windList.printCurrentWindWindow();\r\n          calculatePrintRresults();           \r\n          break;\r\n        case 37:\r\n          angle -= 5;\r\n          windList.setCurrentAngle(angle);\r\n          windList.printCurrentWindWindow();\r\n          calculatePrintRresults();          \r\n          break;\r\n        case 38:\r\n          if (value <= Constant.maxWindValue - 1) {\r\n            value++;            \r\n            windList.setCurrentValue(value);\r\n            windList.printCurrentWindWindow();\r\n            calculatePrintRresults();\r\n          }           \r\n          break;\r\n        case 40:\r\n          if (value >= 1) {\r\n            value--;\r\n            windList.setCurrentValue(value);\r\n            windList.printCurrentWindWindow();            \r\n            calculatePrintRresults();\r\n          }          \r\n          break;\r\n        case 9:  // Tab keydown event\r\n          e.preventDefault();\r\n          windList.moveCurrentPointerToNext();\r\n          windList.printCurrentWindWindow();           \r\n          break;          \r\n      }      \r\n    });\r\n\r\n    // To loose focus after pressing Enter on <input>\r\n    // This is for dzHeightMenu and chuteMenu  \r\n    $(\"input\").keypress(function(e) {\r\n      if (e.keyCode === 13 || e.keyCode === 9) {  // Enter keycode\r\n        $(\"input\").blur();     // Forced loose of focus\r\n      }    \r\n    });\r\n            \r\n    function calculatePrintRresults() {     \r\n      if (path.length > 0) {      \r\n        calculator.calculateHeight();\r\n        path.printHeightsAndWindPoints();\r\n      }                   \r\n    }\r\n  }\r\n    \r\n  provide(Keyboard);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Keyboard.js?");

/***/ }),

/***/ "./src/scripts/Menu.js":
/*!*****************************!*\
  !*** ./src/scripts/Menu.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Menu', [\r\n  'MenuButton'\r\n],\r\nfunction(provide, MenuButton) {\r\n  /**\r\n   * Set of buttons at the left side of screen.\r\n   */\r\n  class Menu {\r\n    /**\r\n     * @param {Map} map\r\n     * @param {Path} path\r\n     */\r\n    constructor(map, path, windList) {\r\n      \r\n      this.path = path;\r\n      this.windList = windList;\r\n      \r\n      this.pressedButton = null;\r\n         \r\n      // Clear Button\r\n      var clearButton = new MenuButton(\"Очистить\", \"images/icon_eraser.svg\");\r\n      clearButton.events.add('click', function() {\r\n        this.path.clear();          \r\n      }.bind(this));\r\n          \r\n      // DzStartHeight Button\r\n      var dzHeightButton = \r\n        new MenuButton(\"Настройки\", \"images/icon_settings.svg\", \"#dzHeightMenu\", this);\r\n\r\n      // Chute Button\r\n      var chuteButton = \r\n        new MenuButton(\"Настройки парашюта\", \"images/icon_chute.svg\", \"#chuteMenu\", this);\r\n\r\n      // Help Button\r\n      var helpButton = \r\n        new MenuButton(\"Справка\", \"images/icon_help.svg\", \"#helpMenu\", this);\r\n\r\n      // Wind Button\r\n      this.windButton = \r\n        new MenuButton(\"Настройка ветра\", \"images/icon_arrow.svg\", \"#windMenu\", this);\r\n\r\n      // Add Wind Button\r\n      var addWindButton = \r\n        new MenuButton(\"Добавить ветер\", \"images/icon_add_arrow.svg\");\r\n      addWindButton.events.add('click', function() {\r\n        // We add new wind arrow (windsock)\r\n        if (this.windList.lastWind.getHeight() != null) {   \r\n          var point = findPlaceForNewArrow(this); \r\n          \r\n          this.windList.addWind();\r\n          this.windList.printCurrentWindWindow();\r\n          this.windButton.showMenu();\r\n          $(\"#menuArrow\").removeClass(\"arrow\");\r\n          $(\"#menuArrow\").addClass(\"arrow_selected\");\r\n        }\r\n\r\n        function findPlaceForNewArrow(context) {\r\n          \r\n          return(context.windList.firstWind.arrow.geometry.getCoordinates());\r\n        }  \r\n        \r\n      }.bind(this));        \r\n\r\n      // Remove Wind Button\r\n      var removeWindButton = \r\n        new MenuButton(\"Удалить ветер\", \"images/icon_remove_arrow.svg\");\r\n      removeWindButton.events.add('click', function() {\r\n        if (this.windList.currentWind != this.windList.firstWind) {\r\n          this.windList.removeWind(this.windList.currentWind);\r\n          if (this.windList.numberOfWinds == 1) {\r\n            $(\"#menuArrow\").removeClass(\"arrow_selected\");\r\n            $(\"#menuArrow\").addClass(\"arrow\"); \r\n          }\r\n        }\r\n      }.bind(this));  \r\n\r\n        \r\n      // Adding Buttons to Map.  \r\n      map.controls.add(dzHeightButton, {position: {top: 45, left: 10}});\r\n      map.controls.add(chuteButton, {position: {top: 75, left: 10}});\r\n      map.controls.add(this.windButton, {position: {top: 105, left: 10}});\r\n      map.controls.add(addWindButton, {position: {top: 135, left: 10}});\r\n      map.controls.add(removeWindButton, {position: {top: 165, left: 10}});      \r\n      map.controls.add(helpButton, {position: {top: 195, left: 10}});   \r\n      map.controls.add(clearButton, {position: {top: 225, left: 10}});      \r\n    }  \r\n  }\r\n      \r\n  provide(Menu);  \r\n});   \n\n//# sourceURL=webpack:///./src/scripts/Menu.js?");

/***/ }),

/***/ "./src/scripts/MenuButton.js":
/*!***********************************!*\
  !*** ./src/scripts/MenuButton.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('MenuButton', [\r\n  'control.Button'       \r\n],\r\nfunction(provide, Button) {\r\n  /**\r\n   * @extends control.Button\r\n   */\r\n  class MenuButton extends Button {\r\n    /**\r\n     * @param {string} [title] - Button hint.\r\n     * @param {string} [image] - Src for <img> tag of this button.\r\n     * @param {string} [windowjQuerySelector] - jQuery selector for corresponding window. \r\n     * @param {Menu} [menu] - Link to parent menu.   \r\n     * @param {string} [cssclass] - Css for this button.          \r\n     */ \r\n    constructor(\r\n      title='', \r\n      image='', \r\n      windowjQuerySelector='', \r\n      menu=null, \r\n      cssclass='inputControlElement' \r\n    ) {\r\n      super({\r\n        data: {\r\n          title: title,\r\n          image: image, \r\n          cssclass: cssclass        \r\n        },  \r\n        options: {\r\n          layout: ymaps.templateLayoutFactory.createClass(\r\n            \"<div title='{{data.title}}' class='{{data.cssclass}}'>\" + \r\n              \"<img class='iconimage' src='{{data.image}}'>\" +           \r\n            \"</div>\"\r\n          ),\r\n          maxWidth: 300\r\n        }\r\n      });\r\n\r\n      this.menu = menu;\r\n      this.buttonIsOn = false;\r\n      this.windowjQuerySelector = windowjQuerySelector;  \r\n \r\n      // When the button is clicked, corresponding window \r\n      // (with jquery selector this.windowjQuerySelector) will be shown.      \r\n      if (this.windowjQuerySelector != '') {    \r\n        this.events.add('click', function() {\r\n          this.buttonIsOn = !this.buttonIsOn;\r\n          if (this.buttonIsOn) {\r\n            // show() is jQuery function\r\n            $(this.windowjQuerySelector).show();      \r\n            //arrow.geometry.setCoordinates(map.getCenter());\r\n            this.data.set('cssclass', 'pressedInputControlElement');\r\n\r\n            if ((this.menu.pressedButton != null) && (this.menu.pressedButton != this)) {\r\n              this.menu.pressedButton.turnOffButton();\r\n            }\r\n            this.menu.pressedButton = this;        \r\n          } else {\r\n            this.turnOffButton();\r\n            this.menu.pressedButton = null;        \r\n          }   \r\n        }.bind(this));\r\n                \r\n        // Cross closing of window element\r\n        $(this.windowjQuerySelector + \"Rectangle\").click(function() {\r\n          this.turnOffButton();  \r\n          this.menu.pressedButton = null;      \r\n        }.bind(this));\r\n        \r\n        this.turnOffButton = this.turnOffButton.bind(this);        \r\n      }   \r\n    }\r\n    \r\n    \r\n    showMenu() {\r\n      //this.buttonIsOn = !this.buttonIsOn;\r\n      if (this.buttonIsOn == false) {\r\n        this.buttonIsOn = true;          \r\n        \r\n        // show() is jQuery function\r\n        $(this.windowjQuerySelector).show();      \r\n        //arrow.geometry.setCoordinates(map.getCenter());\r\n        this.data.set('cssclass', 'pressedInputControlElement');\r\n\r\n        if ((this.menu.pressedButton != null) && (this.menu.pressedButton != this)) {\r\n          this.menu.pressedButton.turnOffButton();\r\n        }\r\n        this.menu.pressedButton = this;        \r\n      } else {\r\n        //this.turnOffButton();\r\n        //this.menu.pressedButton = null;        \r\n      }       \r\n    }\r\n    \r\n        \r\n    /**\r\n     * Turn off button.\r\n     */     \r\n    turnOffButton() {\r\n      $(this.windowjQuerySelector).hide();\r\n      this.buttonIsOn = false;\r\n      this.data.set('cssclass', 'inputControlElement');\r\n    }     \r\n    \r\n  } \r\n  provide(MenuButton);  \r\n}); \r\n\n\n//# sourceURL=webpack:///./src/scripts/MenuButton.js?");

/***/ }),

/***/ "./src/scripts/OutputElement.js":
/*!**************************************!*\
  !*** ./src/scripts/OutputElement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('OutputElement', [\r\n  'control.Button', \r\n  'templateLayoutFactory'  \r\n],\r\nfunction(provide, Button, templateLayoutFactory) {\r\n  \r\n  class OutputElement extends Button {\r\n    /**\r\n     * @param {string} content   \r\n     */\r\n    constructor(content='') {\r\n      \r\n      super({\r\n        data: {content: content},  \r\n          \r\n        options: {\r\n          layout: templateLayoutFactory.createClass(\r\n            \"<div class='outputControlElement'>{{data.content}}</div>\"\r\n          ),\r\n         maxWidth: 300 \r\n        }\r\n      });           \r\n    }\r\n  } \r\n  provide(OutputElement);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/OutputElement.js?");

/***/ }),

/***/ "./src/scripts/Path.js":
/*!*****************************!*\
  !*** ./src/scripts/Path.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Path */\r\nymaps.modules.define('Path', [\r\n  'CircleVertex',\r\n  'TriangleVertex',\r\n  'Vertex',\r\n  'PathEdge',\r\n  'Constant'\r\n],\r\nfunction(\r\n  provide,\r\n  CircleVertex,\r\n  TriangleVertex,\r\n  Vertex,\r\n  PathEdge,\r\n  Constant\r\n) {\r\n  /**\r\n   * List of vertices and edges of Chute Path.\r\n   * Last vertex consist of one outer invisible Circle (Vertex class that\r\n   * extends ymaps.Circle) and arrow-trianlge (TriangleVertex class that extends ymaps.Polyline).\r\n   * Other vertices consist of one outer invisible Circle (Vertex class)\r\n   * and one visible inner Circle (CircleVertex class that extends ymaps.Circle).\r\n   * Outer vertex circles are invisible and serve for handy clicking\r\n   * vertices.\r\n   */\r\n  class Path {\r\n    /**\r\n     * @param {Map} map - link to Yandex map.\r\n     */\r\n    constructor(map) {\r\n      this.map = map;\r\n      this.firstVertex = null;\r\n      this.lastVertex = null;\r\n      // number of vertices\r\n      this.length = 0;\r\n\r\n      // If pathDirection is true, we add new vertex to the start of Path;\r\n      // if false, we add it to end of Path.\r\n      this.pathDirection = true;\r\n\r\n      // radius for inner circle vertices, in meters\r\n      this.vertexRadius = Constant.isMobile ? 4 : 4;\r\n      // radius for outer invisible circles, in meters\r\n      this.vertexOuterRadius = Constant.isMobile ? 6*this.vertexRadius : 3*this.vertexRadius;\r\n\r\n      // On the map: line segments should be under vertex images,\r\n      // vertex images should be under vertices\r\n      this.vertexZIndex = 2;\r\n      this.vertexImageZIndex = 1;\r\n      this.edgeZIndex = 0;\r\n      this.edgeImageZIndex = -1;\r\n\r\n      // Distance from vertex to it's heightPlacemark\r\n      this.heightPlacemarkShift = 0.0002;\r\n\r\n      this.calculator = null;\r\n    }\r\n\r\n\r\n    setPathDirection(pathDirection) {\r\n      this.pathDirection = pathDirection;\r\n    }\r\n\r\n    getPathDirection() {\r\n      return(this.pathDirection);\r\n    }\r\n\r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;\r\n    }\r\n\r\n    setHeightOutput(heightOutput) {\r\n      this.heightOutput = heightOutput;\r\n    }\r\n\r\n    /**\r\n     * Add new vertex to Path and to map.\r\n     * Add corresponding edge to Path and to map.\r\n     * @param {number[]} point - Yandex.Maps coordinates, point = [x, y].\r\n     * @return {Array} New last vertex and new last edge of Path.\r\n     */\r\n    addVertex(point) {\r\n      var map = this.map;\r\n\r\n      var vertex = new Vertex(point, this.vertexOuterRadius, this);\r\n\r\n      if (this.length > 0) {\r\n\r\n        if (this.pathDirection) {\r\n          // We should add vertex to the end of path\r\n\r\n          var lastPoint = this.lastVertex.geometry.getCoordinates();\r\n\r\n          vertex.image = new TriangleVertex(lastPoint, point, this.vertexImageZIndex);\r\n\r\n          var newEdge = new PathEdge(lastPoint, vertex.image.getEdgePoint(), this);\r\n          map.geoObjects.add(newEdge);\r\n          map.geoObjects.add(newEdge.image);\r\n\r\n          // We change previos last Triangle vertex to Circle vertex\r\n          map.geoObjects.remove(this.lastVertex.image);\r\n          this.lastVertex.image =\r\n            new CircleVertex(lastPoint, this.vertexRadius, this.vertexImageZIndex);\r\n          map.geoObjects.add(this.lastVertex.image);\r\n\r\n          // lastVertex image changed from triangle to circle.\r\n          // So edge from lastVertex.prevVertex to lastVertex should be lengthen.\r\n          if (this.lastVertex.prevVertex != null) {\r\n            // that is, lastVertex != firstVertex\r\n            var lastlastPoint = this.lastVertex.prevVertex.geometry.getCoordinates();\r\n            var lastEdge = this.lastVertex.prevVertex.nextLine;\r\n            lastEdge.setCoordinates(lastlastPoint, lastPoint);\r\n          }\r\n\r\n          this.lastVertex.nextVertex = vertex;\r\n          vertex.prevVertex = this.lastVertex;\r\n\r\n          vertex.nextVertex = null;\r\n\r\n          this.lastVertex.nextLine = newEdge;\r\n          newEdge.prevVertex = this.lastVertex;\r\n\r\n          this.lastVertex = vertex;\r\n        } else {\r\n          // We should add vertex to the beginning of path\r\n\r\n          var firstPoint = this.firstVertex.geometry.getCoordinates();\r\n\r\n          var newEdge = null;\r\n\r\n          if (this.length == 1) {\r\n\r\n            map.geoObjects.remove(this.firstVertex.image);\r\n            this.firstVertex.image = new TriangleVertex(point, firstPoint, this.vertexImageZIndex);\r\n            map.geoObjects.add(this.firstVertex.image);\r\n\r\n            newEdge = new PathEdge(point, this.firstVertex.image.getEdgePoint(), this);\r\n\r\n          } else {\r\n            newEdge = new PathEdge(point, firstPoint, this);\r\n          }\r\n\r\n          map.geoObjects.add(newEdge);\r\n          map.geoObjects.add(newEdge.image);\r\n\r\n          vertex.nextVertex = this.firstVertex;\r\n          this.firstVertex.prevVertex = vertex;\r\n\r\n          vertex.prevVertex = null;\r\n\r\n          vertex.nextLine = newEdge;\r\n          newEdge.prevVertex = vertex;\r\n          this.firstVertex = vertex;\r\n\r\n          vertex.image = new CircleVertex(point, this.vertexRadius, this.vertexImageZIndex);\r\n        }\r\n\r\n      } else {  // this.length == 0;\r\n        vertex.prevVertex = null;\r\n        vertex.nextVertex = null;\r\n\r\n        this.firstVertex = vertex;\r\n        this.lastVertex = vertex;\r\n        vertex.image = new CircleVertex(point, this.vertexRadius, this.vertexImageZIndex);\r\n      }\r\n      \r\n      \r\n      map.geoObjects.add(vertex.image);\r\n      map.geoObjects.add(vertex);\r\n      \r\n      \r\n      vertex.showPlacemark();      \r\n      //map.geoObjects.add(vertex.heightPlacemark);\r\n\r\n      this.length++;\r\n\r\n      this.calculator.calculateHeight();\r\n      this.printHeightsAndWindPoints();\r\n\r\n      return([vertex, newEdge]);\r\n    }\r\n\r\n\r\n    /**\r\n     * Divide edge of Path by point.\r\n     * Point should be on that line segment.\r\n     * @param {Edge} edge\r\n     * @param {number[]} point - Yandex.maps coordinates.\r\n     * @return {Array} New vertex and two new edges of Path.\r\n     */\r\n    divideEdge(edge, point) {\r\n      var map = this.map;\r\n\r\n      var prevVertex = edge.prevVertex,\r\n          nextVertex = edge.prevVertex.nextVertex;\r\n          \r\n      var edgeChuteDirection = edge.getChuteDirection();\r\n         \r\n      var prevPoint = prevVertex.geometry.getCoordinates(),\r\n          nextPoint = nextVertex.geometry.getCoordinates();\r\n\r\n      var vertex = new Vertex(point, this.vertexOuterRadius, this);\r\n      vertex.image = new CircleVertex(point, this.vertexRadius, this.vertexImageZIndex);\r\n\r\n      var newEdge1 = new PathEdge(prevPoint, point, this, edgeChuteDirection);\r\n \r\n      // In case when nextVertex is lastVertex\r\n      if (nextVertex.nextVertex == null) {\r\n        nextPoint = nextVertex.image.getEdgePoint();\r\n      }\r\n\r\n      var newEdge2 = new PathEdge(point, nextPoint, this, edgeChuteDirection);\r\n\r\n      vertex.prevVertex = prevVertex;\r\n      vertex.nextVertex = nextVertex;\r\n\r\n      prevVertex.nextVertex = vertex;\r\n      nextVertex.prevVertex = vertex;\r\n\r\n      prevVertex.nextLine = newEdge1;\r\n      vertex.nextLine = newEdge2;\r\n\r\n      newEdge1.prevVertex = prevVertex;\r\n      newEdge2.prevVertex = vertex;\r\n\r\n      this.length++;\r\n\r\n      map.geoObjects.remove(edge);\r\n      map.geoObjects.remove(edge.image);\r\n      map.geoObjects.add(vertex.image);\r\n      map.geoObjects.add(vertex);\r\n      \r\n      vertex.showPlacemark();\r\n      //map.geoObjects.add(vertex.heightPlacemark);\r\n\r\n      map.geoObjects.add(newEdge1);\r\n      map.geoObjects.add(newEdge2);\r\n      map.geoObjects.add(newEdge1.image);\r\n      map.geoObjects.add(newEdge2.image);\r\n\r\n      this.calculator.calculateHeight();\r\n      this.printHeightsAndWindPoints();\r\n\r\n      return([vertex, newEdge1, newEdge2]);\r\n    }\r\n\r\n    /**\r\n     * Remove vertex from Path and from map.\r\n     * @param {Vertex} removingVertex\r\n     * @return {(Edge|null)} Edge between previous and next vertices.\r\n     */\r\n    removeVertex(removingVertex) {\r\n      var map = this.map;\r\n\r\n      map.geoObjects.remove(removingVertex);\r\n      map.geoObjects.remove(removingVertex.image);\r\n\r\n      if (removingVertex.placemarkIsShown) {\r\n        removingVertex.hidePlacemark();\r\n      } \r\n      //map.geoObjects.remove(removingVertex.heightPlacemark);\r\n\r\n      var prevVertex = removingVertex.prevVertex;\r\n      var nextVertex = removingVertex.nextVertex;\r\n\r\n      var newEdge = null;\r\n\r\n      if (this.length > 1) {\r\n        if ((prevVertex != null) && (nextVertex != null)) {\r\n\r\n          var removingEdge1 = prevVertex.nextLine;\r\n          var removingEdge2 = removingVertex.nextLine;\r\n          \r\n          var edgeChuteDirection = \r\n            removingEdge1.getChuteDirection() || removingEdge2.getChuteDirection();\r\n\r\n          map.geoObjects.remove(removingEdge1);\r\n          map.geoObjects.remove(removingEdge1.image);\r\n          map.geoObjects.remove(removingEdge2);\r\n          map.geoObjects.remove(removingEdge2.image);\r\n\r\n          var prevPoint = prevVertex.geometry.getCoordinates();\r\n          var nextPoint = nextVertex.geometry.getCoordinates();\r\n\r\n          prevVertex.nextVertex = nextVertex;\r\n          nextVertex.prevVertex = prevVertex;\r\n\r\n          var nextEdgePoint = null;\r\n\r\n          // case when nextVertex is lastVertex\r\n          // and so we have to change direction of\r\n          // arrow (triangle) of lastVertex\r\n\r\n          if (nextVertex.nextVertex == null) {\r\n            map.geoObjects.remove(nextVertex.image);\r\n            nextVertex.image =\r\n              new TriangleVertex(prevPoint, nextPoint, this.vertexImageZIndex);\r\n            map.geoObjects.add(nextVertex.image);\r\n\r\n            nextEdgePoint = nextVertex.image.getEdgePoint();\r\n\r\n          } else {\r\n            nextEdgePoint = nextPoint;\r\n          }\r\n\r\n          newEdge = new PathEdge(prevPoint, nextEdgePoint, this, edgeChuteDirection);\r\n          this.map.geoObjects.add(newEdge);\r\n          this.map.geoObjects.add(newEdge.image);\r\n\r\n          newEdge.prevVertex = prevVertex;\r\n          prevVertex.nextLine = newEdge;\r\n\r\n        } else if (nextVertex == null) {  // last vertex case\r\n          var removingEdge = prevVertex.nextLine;\r\n          map.geoObjects.remove(removingEdge);\r\n\r\n          map.geoObjects.remove(removingEdge.image);\r\n\r\n          this.lastVertex = prevVertex;\r\n          prevVertex.nextVertex = null;\r\n          prevVertex.nextLine = null;\r\n\r\n          if (prevVertex.prevVertex != null) {\r\n            map.geoObjects.remove(prevVertex.image);\r\n\r\n            var prevPrevPoint = prevVertex.prevVertex.geometry.getCoordinates();\r\n            var prevPoint = prevVertex.geometry.getCoordinates();\r\n            prevVertex.image =\r\n              new TriangleVertex(prevPrevPoint, prevPoint, this.vertexImageZIndex);\r\n            map.geoObjects.add(prevVertex.image);\r\n\r\n            prevVertex.prevVertex.nextLine.setCoordinates(prevPrevPoint, prevVertex.image.getEdgePoint());\r\n          }\r\n\r\n          // If we remove last vertex (pathDirection == false),\r\n          // initial height will change.\r\n          //if (!this.calculator.getCalculationDirection()) {\r\n           // this.calculator.boundaryHeights.finalHeight = this.lastVertex.height;\r\n          //  $(\"#finalHeight\").val(Math.floor(this.lastVertex.height));\r\n          //}\r\n\r\n          if (!this.calculator.getCalculationDirection()) {\r\n            if (!this.pathDirection) {\r\n              this.calculator.setFinalHeight(this.lastVertex.height);  \r\n            } \r\n          }\r\n        } else {  // first vertex case\r\n          map.geoObjects.remove(removingVertex.nextLine);\r\n          map.geoObjects.remove(removingVertex.nextLine.image);\r\n\r\n          nextVertex.prevVertex = null;\r\n          this.firstVertex = nextVertex;\r\n\r\n          if (this.length == 2) {\r\n            var p = nextVertex.geometry.getCoordinates();\r\n            map.geoObjects.remove(nextVertex.image);\r\n            nextVertex.image =\r\n              new CircleVertex(p, this.vertexRadius, this.vertexImageZIndex);\r\n            map.geoObjects.add(nextVertex.image);\r\n          }\r\n\r\n          // If we remove first vertex (pathPosition == true),\r\n          // initial height will change.\r\n          //if (this.calculator.getCalculationDirection()) {\r\n            //this.calculator.boundaryHeights.startHeight = this.firstVertex.height;\r\n            //$(\"#startHeight\").val(Math.floor(this.firstVertex.height));\r\n          //}\r\n\r\n          if (this.calculator.getCalculationDirection()) {\r\n            if (this.pathDirection) {\r\n              this.calculator.setStartHeight(this.firstVertex.height);  \r\n            } \r\n          } \r\n          \r\n          \r\n          //this.calculator.setStartHeight(this.firstVertex.height);\r\n\r\n        }\r\n      } else {  // case: only one circle\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.length--;\r\n\r\n      if (this.length > 0) {\r\n        this.calculator.calculateHeight();\r\n        this.printHeightsAndWindPoints();\r\n      }\r\n\r\n      return(newEdge);\r\n    }\r\n\r\n    /**\r\n     * Drag vertex with neibour edges.\r\n     * @param {Vertex} vertex\r\n     */\r\n    dragVertex(vertex) {\r\n      var map = this.map;\r\n\r\n      this.calculator.calculateHeight();\r\n      this.printHeightsAndWindPoints();\r\n\r\n      // new vertex coordinates\r\n      var point = vertex.geometry.getCoordinates();\r\n\r\n      var nextVertex = vertex.nextVertex;\r\n      var prevVertex = vertex.prevVertex;\r\n\r\n      // Case: both prevVertex and nextVertex don't exist,\r\n      // that is, path consists of one vertex\r\n      if ((nextVertex == null) && (prevVertex == null)) {\r\n        vertex.image.geometry.setCoordinates(point);\r\n        return;\r\n      }\r\n\r\n      // Case: both prevVertex and nextVertex exist,\r\n      // that is, this vertex is not first and not last.\r\n      if ((nextVertex != null) && (prevVertex != null)) {\r\n\r\n        vertex.image.geometry.setCoordinates(point);\r\n\r\n        var nextPoint = nextVertex.geometry.getCoordinates();\r\n        var prevPoint = prevVertex.geometry.getCoordinates();\r\n\r\n        var nextLine = vertex.nextLine;\r\n        var prevLine = prevVertex.nextLine;\r\n\r\n        var nextEdgePoint = null;\r\n        // Case when vertex.nextVertex is lastVertex:\r\n        // in that case your should change\r\n        // direction of arrow at lastVertex.\r\n        if (nextVertex.nextVertex == null) {\r\n          nextVertex.image.setCoordinates(point, nextPoint);\r\n\r\n          nextEdgePoint = nextVertex.image.getEdgePoint();\r\n        } else {\r\n          nextEdgePoint = nextPoint;\r\n        }\r\n\r\n        nextLine.setCoordinates(point, nextEdgePoint);\r\n        prevLine.setCoordinates(prevPoint, point);\r\n\r\n        return;\r\n      }\r\n\r\n      // Case: prevVertex exists, nextVertex doesn't exist,\r\n      // that is, vertex is lastVertex.\r\n      if (prevVertex != null) {\r\n        var prevPoint = prevVertex.geometry.getCoordinates();\r\n        var prevLine = prevVertex.nextLine;\r\n\r\n        // We should change direction of arrow at the vertex\r\n        vertex.image.setCoordinates(prevPoint, point);\r\n\r\n        var edgePoint = vertex.image.getEdgePoint();\r\n        prevLine.setCoordinates(prevPoint, edgePoint);\r\n\r\n        return;\r\n      }\r\n\r\n      // Case: nextVertex exists, prevVertex doesn't exist,\r\n      // that is, vertex is firstVertex.\r\n      vertex.image.geometry.setCoordinates(point);\r\n\r\n      var nextPoint = nextVertex.geometry.getCoordinates();\r\n\r\n      var nextEdgePoint = null;\r\n      // Case when vertex.nextVertex is lastVertex:\r\n      // in that case your should change\r\n      // direction of arrow at lastVertex.\r\n      if (nextVertex.nextVertex == null) {\r\n        nextVertex.image.setCoordinates(point, nextPoint);\r\n        nextEdgePoint = nextVertex.image.getEdgePoint();\r\n      } else {\r\n        nextEdgePoint = nextPoint;\r\n      }\r\n\r\n      var nextLine = vertex.nextLine;\r\n      nextLine.setCoordinates(point, nextEdgePoint);\r\n\r\n      return;\r\n    }\r\n\r\n\r\n    /** Remove all vetrices and edges from Path and from map. */\r\n    clear() {\r\n      var map = this.map;\r\n\r\n      if (this.length > 0 ) {\r\n\r\n        var vertex = this.lastVertex;\r\n        map.geoObjects.remove(vertex);\r\n        map.geoObjects.remove(vertex.image);\r\n        \r\n        if (vertex.placemarkIsShown) {\r\n          vertex.hidePlacemark();\r\n        }\r\n\r\n        for(var i=1; i < this.length; i++) {\r\n          vertex = vertex.prevVertex;\r\n          map.geoObjects.remove(vertex);\r\n          map.geoObjects.remove(vertex.image);\r\n          map.geoObjects.remove(vertex.nextLine);\r\n          map.geoObjects.remove(vertex.nextLine.image);\r\n          \r\n          if (vertex.placemarkIsShown) {\r\n            vertex.hidePlacemark();\r\n          }  \r\n        }\r\n\r\n        this.length = 0;\r\n        this.lastVertex = null;\r\n      }\r\n\r\n      this.calculator.boundaryHeights.makeHeightsEqual(); \r\n      this.calculator.windList.removeWindVertices();\r\n    }\r\n\r\n\r\n    /**\r\n     * Print heights in vertices ballons and hints.\r\n     * Print wind points on the Path.\r\n     */\r\n    printHeightsAndWindPoints() {\r\n      if (this.length > 0) {\r\n\r\n        if (this.calculator.getCalculationDirection()) {\r\n          \r\n          if (this.firstVertex.height == null) {\r\n            let vertex = this.lastVertex;          \r\n            while(vertex != this.firstVertex) {\r\n              if (vertex.placemarkIsShown) {                              \r\n                vertex.hidePlacemark();\r\n              }\r\n              vertex.printHint(\"h=?\");\r\n              if (vertex.singleClickingIsOn) {              \r\n                vertex.turnOffSingleClicking();\r\n              }               \r\n              vertex = vertex.prevVertex;              \r\n            }\r\n            \r\n            // Now: vertex = this.firstVertex            \r\n            if (!vertex.placemarkIsShown) {\r\n              vertex.showPlacemark();\r\n            }\r\n            vertex.printPlacemark(\"Введите высоту\");\r\n            vertex.printHint(\"h=?\");\r\n            if (vertex.singleClickingIsOn) {             \r\n              vertex.turnOffSingleClicking();\r\n            }             \r\n                        \r\n            this.calculator.windList.removeWindVertices();                                      \r\n            return;  \r\n          }            \r\n       \r\n          var vertex = this.firstVertex;\r\n          \r\n          // First unreachable vertex placemark will be shown, \r\n          // next placemarks will be hide. \r\n          var firstUnreachable = true;\r\n\r\n          while(vertex != null) {\r\n            \r\n            if (!vertex.singleClickingIsOn) {             \r\n              vertex.turnOnSingleClicking();\r\n            } \r\n            \r\n            if (typeof(vertex.height) == 'number') {\r\n              vertex.printHint(\"h=\" + Math.floor(vertex.height) + \"м\");\r\n              vertex.printPlacemark(Math.floor(vertex.height) + \"м\");\r\n\r\n              if (!vertex.placemarkIsShown) {                  \r\n                vertex.showPlacemark();\r\n              }\r\n            } else {\r\n              vertex.printHint(\"&#x26D4;\");\r\n              vertex.printPlacemark(\"Сюда не долететь!\");\r\n              if (firstUnreachable) {\r\n                firstUnreachable = false;\r\n                if (!vertex.placemarkIsShown) {                  \r\n                  vertex.showPlacemark();\r\n                }\r\n              } else {\r\n                if (vertex.placemarkIsShown) {                  \r\n                  vertex.hidePlacemark();\r\n                }\r\n              }\r\n            }\r\n            vertex = vertex.nextVertex;\r\n          }\r\n        } else {\r\n                    \r\n          if (this.lastVertex.height == null) {\r\n\r\n            let vertex = this.firstVertex;          \r\n            while(vertex != this.lastVertex) {\r\n              if (vertex.placemarkIsShown) {                              \r\n                vertex.hidePlacemark();\r\n              }\r\n              vertex.printHint(\"h=?\");\r\n              if (vertex.singleClickingIsOn) {              \r\n                vertex.turnOffSingleClicking();\r\n              }               \r\n              vertex = vertex.nextVertex;              \r\n            }\r\n            \r\n            // Now: vertex = this.lastVertex            \r\n            if (!vertex.placemarkIsShown) {\r\n              vertex.showPlacemark();\r\n            }\r\n            vertex.printPlacemark(\"Введите высоту\");\r\n            vertex.printHint(\"h=?\");\r\n            if (vertex.singleClickingIsOn) {             \r\n              vertex.turnOffSingleClicking();\r\n            }             \r\n                        \r\n            this.calculator.windList.removeWindVertices();                                      \r\n            return;  \r\n          }  \r\n                      \r\n          var vertex = this.lastVertex;\r\n\r\n          var firstBackUnreachable = true;\r\n\r\n          while(vertex != null) {\r\n\r\n            if (!vertex.singleClickingIsOn) {             \r\n              vertex.turnOnSingleClicking();\r\n            }\r\n          \r\n            if (typeof(vertex.height) == 'number') {\r\n              vertex.printHint(\"h=\" + Math.floor(vertex.height) + \"м\");\r\n              vertex.printPlacemark(Math.floor(vertex.height) + \"м\");\r\n\r\n              if (!vertex.placemarkIsShown) {                  \r\n                vertex.showPlacemark();\r\n              }\r\n            } else {\r\n              vertex.printHint(\"&#x26D4;\");\r\n              vertex.printPlacemark(\"Отсюда не долететь!\");\r\n              if (firstBackUnreachable) {\r\n                firstBackUnreachable = false;\r\n\r\n                if (!vertex.placemarkIsShown) {                  \r\n                  vertex.showPlacemark();\r\n                }\r\n              } else {\r\n                if (vertex.placemarkIsShown) {                  \r\n                  vertex.hidePlacemark();\r\n                }\r\n              }\r\n            }\r\n            vertex = vertex.prevVertex;\r\n          }\r\n        }\r\n\r\n        this.calculator.windList.createWindVertices();\r\n      }\r\n    }\r\n  }\r\n  provide(Path);\r\n});\n\n//# sourceURL=webpack:///./src/scripts/Path.js?");

/***/ }),

/***/ "./src/scripts/PathEdge.js":
/*!*********************************!*\
  !*** ./src/scripts/PathEdge.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module PathEdge */\r\nymaps.modules.define('PathEdge', [\r\n  'Polygon', \r\n  'VectorMath'  \r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n  /**\r\n   * PathEdge consists of two rectangles: \r\n   *   visible rectangle and invisible rectangle.\r\n   * Invisible rectangle (shell rectangle) is for the means of \r\n   * more simple clicking (especially in mobile case)\r\n   */\r\n  class PathEdge extends Polygon {\r\n    /**\r\n     * @param {number[]} pointA - Yandex.Maps coordinates of first point.\r\n     * @param {number[]} pointB - Yandex.Maps coordinates of second point.\r\n     * @param {number} edgeImageWidthWidth\r\n     * @param {number} edgeWidth      \r\n     * @param {number} zIndex - z-index of edge, z-index of edgeImage\r\n     *    will equals zIndex-1.     \r\n     */\r\n    constructor(\r\n      pointA, \r\n      pointB,\r\n      path, \r\n      chuteDirection = true    \r\n      //edgeWidth = 1,       \r\n      //edgeImageWidth = 0.1, \r\n      //zIndex = 0\r\n    ) {\r\n        \r\n      var zIndex = 0;               \r\n      // Rectangle vertices will be calculated later\r\n      super([], {}, {\r\n        // edge will be invisible\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: zIndex\r\n      });\r\n\r\n      this.pointA = pointA;\r\n      this.pointB = pointB;\r\n      this.path = path;\r\n      // true - for the same directions of Chute and Edge\r\n      this.chuteDirection = chuteDirection;      \r\n      \r\n      var color = this.getColor();\r\n      \r\n      this.image = new Polygon([], {}, {\r\n        fillColor: color,\r\n        strokeColor: color, \r\n        zIndex: (zIndex - 1)        \r\n      });\r\n            \r\n      this.edgeWidth = 1; // edgeWidth; \r\n      this.edgeImageWidth = 0.1; // edgeImageWidth;\r\n      \r\n      this.setCoordinates(pointA, pointB);\r\n      \r\n      this.clickNumber = 0;\r\n\r\n      this.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick(e);\r\n      }.bind(this));      \r\n    }\r\n    \r\n    getChuteDirection() {\r\n      return this.chuteDirection;\r\n    }\r\n    \r\n    getColor() {\r\n      var color = this.chuteDirection ? \"#0000FF\" : \"#000050\";\r\n      return color;\r\n    }\r\n\r\n    /**\r\n     * Process both click and dblclick on this edge.\r\n     * Single clicking is for adding new Vertex. \r\n     * Double clicking is for changing chute direction \r\n     * on this edge (skydiver can fly with his face directed \r\n     * with or against edge).\r\n     */       \r\n    processVertexClick(e) {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (this.clickNumber == 1) {  // Single Click (add Vertex)\r\n            this.divideEdge(e);                           \r\n            this.clickNumber = 0;\r\n          } else {   \r\n            if (this.clickNumber == 2) {  // Double Click (change chute direction)\r\n              this.chuteDirection = !this.chuteDirection;        \r\n              let color = this.getColor();              \r\n              this.image.options.set(\"fillColor\", color);\r\n              this.image.options.set(\"strokeColor\", color);                            \r\n              this.clickNumber = 0;\r\n              \r\n              this.path.calculator.calculateHeight();\r\n              this.path.printHeightsAndWindPoints();              \r\n            }             \r\n          }  \r\n        }.bind(this), 200);\r\n      }  \r\n    }    \r\n\r\n      \r\n    /**    \r\n     * Here we calculate projection of point = e.get('coords') to \r\n     * line segment {this.pointA, this.pointB} and then \r\n     * send that projection to path.divideEdge.     \r\n     * @param {Event} e\r\n     */\r\n    divideEdge(e) {\r\n                \r\n      var point = e.get('coords');\r\n      \r\n      var pointA = this.pointA, \r\n          pointB = this.pointB;\r\n              \r\n      var vector1 = VectorMath.subVectors(point, pointA), \r\n          vector2 = VectorMath.subVectors(pointB, pointA);\r\n      vector2 = VectorMath.normaliseVector(vector2);                \r\n      var c = VectorMath.scalarProduct(vector1, vector2);        \r\n      var vector3 = VectorMath.multVectorConstant(vector2, c);\r\n      \r\n      var point2 = VectorMath.addVectors(pointA, vector3);\r\n                            \r\n      this.path.divideEdge(this, point2);    \r\n    }\r\n        \r\n        \r\n    setCoordinates(pointA, pointB) {\r\n      \r\n      var vertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeWidth);\r\n\r\n      this.geometry.setCoordinates([vertices]);        \r\n      \r\n      var imageVertices = \r\n        this.calculateRectangleVertices(pointA, pointB, this.edgeImageWidth);\r\n\r\n      this.image.geometry.setCoordinates([imageVertices]); \r\n\r\n      this.pointA = pointA;\r\n      this.pointB = pointB;      \r\n    }\r\n        \r\n    /**\r\n     * @param {number} width - Width of Rectangle, in meters. \r\n     */    \r\n    calculateRectangleVertices (pointA, pointB, width) {\r\n                  \r\n      var latitude = pointA[0],\r\n          geodesicVectorAB = VectorMath.subVectors(pointB, pointA);\r\n\r\n      var cartVectorAB = \r\n            VectorMath.toLocalVector(geodesicVectorAB, latitude);         \r\n\r\n      var v = VectorMath.normaliseVector(cartVectorAB);\r\n      \r\n      var w = [(-v[1])*width , v[0]*width];\r\n            \r\n      var wg = VectorMath.toGeodesicVector(w, latitude);\r\n      var wwg = [wg[0]*(-1), wg[1]*(-1)];\r\n      \r\n      var vertices = [];  \r\n      vertices[0] = VectorMath.addVectors(pointA, wg);\r\n      vertices[1] = VectorMath.addVectors(pointB, wg);\r\n      vertices[2] = VectorMath.addVectors(pointB, wwg); \r\n      vertices[3] = VectorMath.addVectors(pointA, wwg);       \r\n                  \r\n      return vertices;  \r\n    }              \r\n  } \r\n  provide(PathEdge);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/PathEdge.js?");

/***/ }),

/***/ "./src/scripts/TriangleVertex.js":
/*!***************************************!*\
  !*** ./src/scripts/TriangleVertex.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('TriangleVertex', [\r\n  'Polygon', \r\n  'VectorMath'  \r\n],\r\nfunction(provide, Polygon, VectorMath) {\r\n \r\n  /** \r\n   * Let point1, point2 - two points with Yandex.maps (geodesic) coordinates. \r\n   * TriangleVertex is Yandex maps triangle, \r\n   * such that vector (point1, point2) and that triangle \r\n   * form arrow (end of path).\r\n   * Size of arrow is about several meters.\r\n   */ \r\n  class TriangleVertex extends Polygon {\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates. \r\n     * @param {number} zIndex - z-index of Polygon.     \r\n     */\r\n    constructor(point1, point2, zIndex=0) {\r\n      // four square brackets is a must for Polygon constructor, \r\n      // non empty super constructor is a must     \r\n      super([], {}, {\r\n        fillColor: \"#0000FF\", \r\n        strokeColor: \"#0000FF\", \r\n        zIndex: zIndex          \r\n      });   \r\n      \r\n      // Three vertices of triangle \r\n      this.triangleVertices = null;\r\n      // Point on triangle side to which edge will be connected\r\n      this.edgePoint = null;\r\n      \r\n      this.setCoordinates(point1, point2);       \r\n    }\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.    \r\n     */    \r\n    setCoordinates (point1, point2) {\r\n      var p = this.calculateVertices(point1, point2);\r\n\r\n      this.triangleVertices = [p[0], p[1], p[2]];\r\n      this.edgePoint = p[3]; \r\n      \r\n      this.geometry.setCoordinates([this.triangleVertices]); \r\n    }\r\n    \r\n    getEdgePoint() {\r\n      return(this.edgePoint);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps point coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps point coordinates.\r\n     * @return {number[][]} points - First three points of this array are \r\n     * the vertices of triangle; last point is a point at the triangle side \r\n     * to which edge will be connected.  \r\n     */     \r\n    calculateVertices (point1, point2) {\r\n                   \r\n      var latitude = point1[0],\r\n          geodesicArrowVector = VectorMath.subVectors(point2, point1),\r\n          localArrowVector = \r\n            VectorMath.toLocalVector(geodesicArrowVector, latitude);         \r\n\r\n      localArrowVector = VectorMath.normaliseVector(localArrowVector);                \r\n      \r\n      // Points coordinates in local cartesian coordinate system.\r\n      // First three point are the vertices of triangle.\r\n      // Last point is a point at the triangle side \r\n      // to which edge will be connected.\r\n      var pointsLocal = [[-2, 0.5], [-2, -0.5], [0, 0], [-2,0]];\r\n      \r\n      var points = [];                 \r\n      for(var i=0; i<pointsLocal.length; i++) {   \r\n        points[i] = VectorMath.rotateVector(pointsLocal[i], localArrowVector);\r\n        points[i] = VectorMath.addVectors(\r\n          point2, \r\n          VectorMath.toGeodesicVector(points[i], latitude)\r\n        );\r\n      }\r\n \r\n      return(points);  \r\n    }        \r\n  }\r\n  \r\n  provide(TriangleVertex);      \r\n});\n\n//# sourceURL=webpack:///./src/scripts/TriangleVertex.js?");

/***/ }),

/***/ "./src/scripts/VectorMath.js":
/*!***********************************!*\
  !*** ./src/scripts/VectorMath.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('VectorMath', [],\r\nfunction(provide) {\r\n  /** Set of functions for working with Sphere (2 dimensional) vectors. */\r\n  class VectorMath {\r\n       \r\n    /**\r\n     * We consider following local cartesian coordinate system: \r\n     *  axis have the same direction as Latitude-Longtitude, \r\n     *  axis have the same length (with each other), \r\n     *  default scale parameter (0.00008) makes this \r\n     *  coordinate system be of the size we need in our tasks.\r\n     * @param {number[]} geodesicVector - Latitude-Longtitude vector coordinates.\r\n     * @param {number} latitude\r\n     * @param {number} scale - Default value is 0.00008\r\n     * @return {number[]} [vx, vy] - Vector coordinates in cartesian coordinate system.\r\n     */      \r\n    static toLocalVector(geodesicVector, latitude, scale=0.00008) {  \r\n      var vx = geodesicVector[0]/scale;\r\n      var vy = (geodesicVector[1]/scale) * \r\n                Math.cos((Math.PI/180)*latitude);\r\n      return([vx, vy]);\r\n    }\r\n    \r\n    /**\r\n     * Convert Cartesian coordinate to Latitude-Longtitude coordinates.\r\n     * @param {number[]} localVector - Cartesian vector. \r\n     * @param {number} latitude\r\n     * @param {number} scale \r\n     * @return {number[]|0} [vlat, vlon] - [Latitude, Longtitude] or 0 \r\n     *  (if impossible to convert).       \r\n     */\r\n    static toGeodesicVector(localVector, latitude, scale=0.00008) {\r\n      var vlat = localVector[0]*scale;\r\n      var c = Math.cos((Math.PI/180)*latitude);\r\n      if (c == 0) return 0;\r\n      var vlon = (localVector[1]*scale) / c;\r\n      return([vlat, vlon]);\r\n    }\r\n\r\n    static normaliseVector(v) {\r\n      var d = Math.sqrt(v[0]**2 + v[1]**2);\r\n      if (d>0) {\r\n        return ([v[0]/d, v[1]/d]);\r\n      } else {        \r\n        return ([0, 0]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * n = (cos(alpha), sin(alpha)), \r\n     * alpha is angle of rotation\r\n     */\r\n    static rotateVector(v, n) {\r\n      var wx = n[0]*v[0] - n[1]*v[1];\r\n      var wy = n[1]*v[0] + n[0]*v[1];\r\n      return ([wx, wy]);        \r\n    }\r\n\r\n    static addVectors(v1, v2) {\r\n      return([v1[0] + v2[0], v1[1] + v2[1]]);\r\n    } \r\n    \r\n    static subVectors(v1, v2) {\r\n      return([v1[0] - v2[0], v1[1] - v2[1]]);\r\n    }\r\n\r\n    static multVectorConstant(v, a) {\r\n      return([v[0]*a, v[1]*a]);\r\n    }\r\n\r\n    static scalarProduct(v1, v2) {\r\n      return(v1[0]*v2[0] + v1[1]*v2[1]);      \r\n    }\r\n    \r\n    static length(v) {\r\n      return(Math.sqrt(v[0]*v[0] + v[1]*v[1]));\r\n    }\r\n    \r\n    /**\r\n     * pointA + {pointA, pointB} * t\r\n     */       \r\n    static findIntermediatePoint(pointA, pointB, t) {\r\n      var v = this.subVectors(pointB, pointA);      \r\n      var dist = ymaps.coordSystem.geo.getDistance(pointA, pointB);      \r\n      v = this.multVectorConstant(v, t);                   \r\n      var point = this.addVectors(pointA, v);\r\n      return(point);  \r\n    }\r\n            \r\n  }\r\n      \r\n  provide(VectorMath);  \r\n});  \n\n//# sourceURL=webpack:///./src/scripts/VectorMath.js?");

/***/ }),

/***/ "./src/scripts/Vertex.js":
/*!*******************************!*\
  !*** ./src/scripts/Vertex.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Vertex', [\r\n  'Circle', \r\n  'Placemark'  \r\n],\r\nfunction(provide, Circle, Placemark) {\r\n  /**\r\n   * Vertex of Path. \r\n   * It is invisible circle. Vertex image will be vertex.image object.\r\n   */\r\n  class Vertex extends Circle {\r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {number} radius\r\n     * @param {Path} path - Link to path; we need it because \r\n     * double clicking and draging of vertex change path (neibours of vertex).     \r\n     */\r\n    constructor(point, radius, path) {\r\n      super([\r\n        point, \r\n        radius\r\n      ], {}, {\r\n        draggable: true,\r\n        // vertex will be invisible\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: path.vertexZIndex\r\n      }); \r\n            \r\n      // Distance from vertex to it's heightPlacemark\r\n      this.heightPlacemarkShift = 0.0001;\r\n      \r\n      // Placemark for Height of Chute at this vertex\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        [point[0] + this.heightPlacemarkShift, point[1]], \r\n        {}, \r\n        {\r\n          preset: 'islands#blackStretchyIcon', \r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n      \r\n      // This varialable will be set up later.\r\n      this.image = null;\r\n      \r\n      this.path = path; \r\n\r\n      this.prevVertex = null;\r\n      this.nextVertex = null;\r\n      \r\n      this.clickNumber = 0;\r\n      this.placemarkIsShown = false;\r\n      this.vertexIsShown = false;\r\n      // Vertex single clicking switcher\r\n      this.singleClickingIsOn = true;\r\n     \r\n      // Turning on/off vertex when conditon \r\n      // \"reachable/unreachable\" was changed\r\n      this.wasTurnOffBecauseUnreachable = false;\r\n      // The same for back direction\r\n      this.wasTurnOffBecauseBackUnreachable = false;\r\n\r\n      // Chute height at this vertex. It will be calculated later.      \r\n      this.height = null;      \r\n              \r\n      this.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n      \r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });\r\n      \r\n      this.events.add('drag', function(e) {\r\n        e.stopPropagation();\r\n        this.processVertexDrag();       \r\n      }.bind(this));\r\n    \r\n    }\r\n    \r\n\r\n    \r\n    addToMap() {\r\n      if (!this.vertexIsShown) {\r\n        this.path.map.geoObjects.add(this);         \r\n        this.path.map.geoObjects.add(this.image);       \r\n        this.vertexIsShown = true;\r\n      }      \r\n    }\r\n    \r\n    \r\n    removeFromMap() {\r\n      if (this.vertexIsShown) {\r\n        this.path.map.geoObjects.remove(this);         \r\n        this.path.map.geoObjects.remove(this.image);       \r\n        this.vertexIsShown = false;\r\n      }               \r\n    }\r\n\r\n    \r\n    showPlacemark() {\r\n      if (this.path != null) {\r\n        if (!this.placemarkIsShown) {\r\n          this.path.map.geoObjects.add(this.heightPlacemark);\r\n          this.placemarkIsShown = true;\r\n        } else {\r\n          console.warn(\"Placemark has already shown!\");\r\n        }\r\n      } else {\r\n        console.warn(\"this.path == null!\");\r\n      }      \r\n    } \r\n\r\n    \r\n    hidePlacemark() {\r\n      if (this.path != null) {\r\n        if (this.placemarkIsShown) {\r\n          this.path.map.geoObjects.remove(this.heightPlacemark);\r\n          this.placemarkIsShown = false;\r\n        } else {\r\n          console.warn(\"Placemark has already hiden!\");\r\n        }\r\n      } else {\r\n        console.warn(\"this.path == null!\");\r\n      }      \r\n    }\r\n    \r\n    /** \r\n     * Turn off single clicking on vertex.\r\n     * Remember, that single clicking on vertex \r\n     * shows or hides Placemark.     \r\n     */\r\n    turnOffSingleClicking() {\r\n      if (this.singleClickingIsOn) {\r\n        this.singleClickingIsOn = false;\r\n      } else {\r\n        console.warn(\"Single clicking is already off!\");\r\n      }        \r\n    }\r\n\r\n    /** \r\n     * Turn on single clicking on vertex.\r\n     * Remember, that single clicking on vertex \r\n     * shows or hides Placemark.     \r\n     */    \r\n    turnOnSingleClicking() {\r\n      if (!this.singleClickingIsOn) {\r\n        this.singleClickingIsOn = true;\r\n      } else {\r\n        console.warn(\"Single clicking is already on!\");\r\n      }            \r\n    }\r\n         \r\n    /**\r\n     * Process both click and dblclick on this vertex.\r\n     * Single clicking is for showing/hiding Placemark. \r\n     * Double clicking is for vertex removing.\r\n     */       \r\n    processVertexClick() {\r\n      this.clickNumber++;\r\n      if (this.clickNumber == 1) {\r\n        setTimeout(function() {        \r\n          if (this.clickNumber == 1) {  // Single Click (show/hide Placemark)\r\n            if (this.singleClickingIsOn) {\r\n              if (this.placemarkIsShown) {\r\n                this.hidePlacemark();\r\n              } else {\r\n                this.showPlacemark();             \r\n              }\r\n            }                            \r\n            this.clickNumber = 0;\r\n          } else {  // Double Click (remove Vertex)               \r\n            this.path.removeVertex(this);                 \r\n          }  \r\n        }.bind(this), 200);\r\n      }  \r\n    }\r\n\r\n    /**\r\n     * Process vertex dragging.\r\n     */     \r\n    processVertexDrag() {\r\n      var newPoint = this.geometry.getCoordinates();\r\n     \r\n      this.heightPlacemark.geometry.setCoordinates(\r\n        [newPoint[0] + this.heightPlacemarkShift, newPoint[1]]\r\n      );\r\n      \r\n      this.path.dragVertex(this);         \r\n    }\r\n    \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set(\"iconContent\", str);           \r\n    }\r\n    \r\n    printHint(str) {\r\n      this.properties.set(\"hintContent\", str);      \r\n    }       \r\n  } \r\n  provide(Vertex);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/Vertex.js?");

/***/ }),

/***/ "./src/scripts/Wind.js":
/*!*****************************!*\
  !*** ./src/scripts/Wind.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Wind', [\r\n  'Arrow'\r\n],\r\nfunction(provide, Arrow) {\r\n\r\n  /**\r\n   * Wind at particular height.  \r\n   */\r\n  class Wind {\r\n    /** \r\n     * Wind in polar coordinate system.\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     * @param {number} angle - Angle between current wind and West wind; in degrees.    \r\n     * @param {number || null} height - In meters; height must be >= 0.\r\n     */\r\n    constructor(value, angle, height) {\r\n      \r\n      this.arrow = new Arrow();        \r\n      \r\n      this.setValue(value);\r\n      this.setAngle(angle);\r\n      this.setHeight(height); \r\n\r\n      this.prevWind = null;\r\n      this.nextWind = null; \r\n\r\n      // Point on the path, at which height = this.height.  \r\n      //this.pathPoint = null;       \r\n    }\r\n    \r\n    /**\r\n     * @param {number || null} height - In meters; height must be >= 0.\r\n     */\r\n    setHeight(height) {\r\n      if (height != null) {\r\n        this.arrow.print(height + \"м\");        \r\n      } else {\r\n        this.arrow.print(\"h = ?\");\r\n      }\r\n      \r\n      this.height = height;      \r\n    }\r\n    \r\n    /**\r\n     * this.angle will be reduced to interval (-180, 180] degrees.\r\n     * @param {number} angle\r\n     */\r\n    setAngle(angle) {\r\n      \r\n      angle = Math.floor(angle); \r\n      \r\n      if (angle != -180) {  // we want to differ -180 degree and 180 degree at wind menu scale             \r\n        if (angle >= 0) {\r\n          angle = angle % 360;\r\n        } else {\r\n          // negative angle case\r\n          angle = angle * (-1);\r\n          angle = angle % 360;\r\n          angle = 360 - angle;        \r\n        }\r\n        \r\n        if (angle > 180) {\r\n          angle -= 360;\r\n        }\r\n      }      \r\n            \r\n      this.arrow.rotate(angle);\r\n\r\n      this.angle = angle;            \r\n    }\r\n    \r\n    /**\r\n     * @param {number} value - In m/sec; value must be >= 0.\r\n     */\r\n    setValue(value) {\r\n      this.value = value;             \r\n    }\r\n    \r\n     \r\n    getAngle() {\r\n      return(this.angle);\r\n    }\r\n    \r\n    getValue() {\r\n      return(this.value);\r\n    }\r\n    \r\n    getHeight() {\r\n      return(this.height);\r\n    }\r\n        \r\n    /**\r\n     * Calculate wind coordinates in cartesian coordinate system.\r\n     * @return {number[]} [vx, vy] - coordinates, in m/sec.\r\n     */\r\n    getXY () {      \r\n      var radiandirection = this.angle * ((2*Math.PI)/360);       \r\n      var vx = this.value * Math.cos(radiandirection);\r\n      var vy = this.value * Math.sin(radiandirection);\r\n      return [vx, vy];      \r\n    } \r\n    \r\n    /**\r\n     * Get name of wind direction (E, N, W, S, ...)\r\n     */    \r\n    getDirection() {     \r\n      var angleSwitch = Math.floor((this.angle + 180 + 22)/45);\r\n      var direction;\r\n      \r\n      switch(angleSwitch) {\r\n        case 0: direction = \"В\"; break;\r\n        case 1: direction = \"СВ\"; break;\r\n        case 2: direction = \"С\"; break;\r\n        case 3: direction = \"СЗ\"; break;\r\n        case 4: direction = \"З\"; break;\r\n        case 5: direction = \"ЮЗ\"; break;\r\n        case 6: direction = \"Ю\"; break;\r\n        case 7: direction = \"ЮВ\"; break;\r\n        case 8: direction = \"В\"; break;    \r\n      }\r\n      \r\n      return(direction);     \r\n    }  \r\n\r\n    addToMap(map, coordinates = null) {\r\n      this.arrow.addToMap(map, coordinates);\r\n    }\r\n    \r\n    removeFromMap(map) {\r\n      this.arrow.removeFromMap(map);\r\n    }\r\n    \r\n  }\r\n      \r\n  provide(Wind);  \r\n});      \r\n      \n\n//# sourceURL=webpack:///./src/scripts/Wind.js?");

/***/ }),

/***/ "./src/scripts/WindList.js":
/*!*********************************!*\
  !*** ./src/scripts/WindList.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindList', [\r\n  'Wind', \r\n  'WindOutputElement', \r\n  'WindVertex'\r\n],\r\nfunction(provide, Wind, WindOutputElement, WindVertex) {\r\n\r\n  /**\r\n   * List of winds at different heights; \r\n   * always contains wind at height = 0m (surface wind); \r\n   * that surface wind is always first and cannot be removed;\r\n   * list will be sorted for height (from bottom to top); \r\n   * all winds should have different heights.\r\n   * WindList also contains WindOutputElement for showing \r\n   * parameters of current wind.\r\n   * WindList contains function printCurrentWindWindow() \r\n   * for printing parameters of current window to wind dialog window; \r\n   * you should make this printing by hand (that is, call \r\n   * that function when you need).\r\n   */\r\n  class WindList {\r\n    constructor(map) {\r\n      this.map = map; \r\n     \r\n      // 5 m/sec, west wind, h = 0m (surface wind)\r\n      this.firstWind = new Wind(5, 0, 0);\r\n      this.firstWind.arrow.setSelection(false);      \r\n      // we add to map corresponding windsock\r\n      this.firstWind.addToMap(this.map, this.map.getCenter());\r\n      this.firstWind.arrow.removePlacemark();      \r\n      \r\n      this.currentWind = this.firstWind;\r\n      this.lastWind = this.firstWind;\r\n      this.numberOfWinds = 1;\r\n\r\n      // Output window at the top left corner of the screen.    \r\n      this.windOutput = new WindOutputElement(this.firstWind);\r\n      this.map.controls.add(this.windOutput, {float: 'left'}); \r\n      this.windOutput.print(this.currentWind);\r\n\r\n      // calculator and path are set up in index.js\r\n      this.calculator = null;\r\n      this.path = null;       \r\n            \r\n      this.firstWind.arrow.events.add('click', function(e) {\r\n        if (this.numberOfWinds == 1) return;      \r\n        if (this.currentWind != this.firstWind) {\r\n          this.currentWind.arrow.setSelection(false);\r\n          this.firstWind.arrow.setSelection(true);\r\n          this.currentWind = this.firstWind;          \r\n        }         \r\n        this.printCurrentWindWindow();\r\n        this.windOutput.print(this.currentWind);        \r\n      }.bind(this));      \r\n    }\r\n    \r\n       \r\n    setCalculator(calculator) {\r\n      this.calculator = calculator;      \r\n    }\r\n    \r\n    setPath(path) {\r\n      this.path = path;\r\n    }\r\n\r\n    /**\r\n     * Create new wind (value = 5, angle = 0, height is unknown) and \r\n     * add it to the end of the list.\r\n     */\r\n    addWind(point = null) {\r\n      \r\n      var wind = new Wind(5, 0, null);\r\n      wind.addToMap(this.map, point);\r\n           \r\n      this.currentWind.arrow.setSelection(false);\r\n      wind.arrow.setSelection(true);\r\n\r\n      this.lastWind.nextWind = wind;      \r\n      \r\n      wind.prevWind = this.lastWind;\r\n      wind.nextWind = null;\r\n      \r\n      // In this point on path we will have height = wind.height, \r\n      // it is object of class WindVertex.\r\n      wind.pathVertex = null;\r\n      \r\n      this.lastWind = wind;\r\n      this.currentWind = wind;\r\n                      \r\n      var clickNumber = 0;\r\n      \r\n      wind.arrow.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n\r\n        clickNumber++;\r\n        if (clickNumber == 1) {\r\n          setTimeout(function() {        \r\n            if (clickNumber == 1) {  // Single Click (selection arrow)\r\n              \r\n              if (this.currentWind != wind) {\r\n                this.currentWind.arrow.setSelection(false);\r\n                wind.arrow.setSelection(true);\r\n                this.currentWind = wind;          \r\n              }\r\n              \r\n              this.printCurrentWindWindow();\r\n              this.windOutput.print(this.currentWind);\r\n              \r\n            } else {  // Double Click (deletion of arrow which was double clicked)\r\n              this.removeWind(wind);\r\n              if (this.numberOfWinds == 1) {\r\n                $(\"#menuArrow\").removeClass(\"arrow_selected\");\r\n                $(\"#menuArrow\").addClass(\"arrow\"); \r\n              }               \r\n            }\r\n                                               \r\n            clickNumber = 0;\r\n            \r\n          }.bind(this), 200);\r\n        }          \r\n      }.bind(this));\r\n            \r\n      // remove standart map zoom for double click\r\n      wind.arrow.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });      \r\n    \r\n      this.windOutput.print(this.currentWind);       \r\n      this.numberOfWinds++;\r\n      \r\n      if (this.numberOfWinds == 2) {\r\n        this.firstWind.arrow.addPlacemark();\r\n      }       \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Remove wind from WindList. If wind equals currentWind then \r\n     * after removing currentWind will be equal currentWind.prevWind.\r\n     * Note: you cannot remove firstWind by construction.\r\n     * @param {Wind} wind - It is supposed that wind belongs to WindList.  \r\n     */\r\n    removeWind(wind) {\r\n      \r\n      // First wind, that is, surface wind, cannot be removed\r\n      if (wind == this.firstWind) {\r\n        console.warn(\"This wind was not removed, because it was firstWind.\");\r\n        return;\r\n      }\r\n      \r\n      wind.removeFromMap(this.map);\r\n      if (wind.pathVertex != null) {\r\n        wind.pathVertex.removeFromMap();\r\n        wind.PathVertex = null;\r\n      }      \r\n\r\n      wind.prevWind.nextWind = wind.nextWind;      \r\n      if (wind != this.lastWind) {\r\n        wind.nextWind.prevWind = wind.prevWind;\r\n      } else {\r\n        this.lastWind = wind.prevWind;\r\n      }\r\n      \r\n      if (wind == this.currentWind) {\r\n        this.currentWind = wind.prevWind;\r\n        if (this.numberOfWinds > 1) {\r\n          this.currentWind.arrow.setSelection(true);\r\n        } \r\n        this.printCurrentWindWindow();\r\n        this.windOutput.print(this.currentWind);        \r\n      }\r\n                                    \r\n      this.numberOfWinds--;       \r\n      \r\n      if (this.numberOfWinds == 1) {\r\n        this.firstWind.arrow.removePlacemark();\r\n        this.currentWind.arrow.setSelection(false);        \r\n      }\r\n\r\n      this.calculator.calculateHeight();\r\n      this.path.printHeightsAndWindPoints();            \r\n    }\r\n    \r\n    /**\r\n     * Now wind will become currentWind.\r\n     */\r\n    moveCurrentPointer(wind) {      \r\n      if (wind == this.currentWind) return;      \r\n      this.currentWind.arrow.setSelection(false);            \r\n      this.currentWind = wind;\r\n      this.currentWind.arrow.setSelection(true); \r\n      this.windOutput.print(this.currentWind);        \r\n    }\r\n    \r\n    \r\n    moveCurrentPointerToPrev() {\r\n      if (this.numberOfWinds == 1) return;      \r\n      this.currentWind.arrow.setSelection(false);      \r\n      if (this.currentWind != this.firstWind) {\r\n        this.currentWind = this.currentWind.prevWind;\r\n      } else {\r\n        this.currentWind = this.lastWind;\r\n      }  \r\n      this.currentWind.arrow.setSelection(true); \r\n      this.windOutput.print(this.currentWind);   \r\n    }\r\n    \r\n    \r\n    moveCurrentPointerToNext() {\r\n      if (this.numberOfWinds == 1) return;      \r\n      this.currentWind.arrow.setSelection(false);      \r\n      if (this.currentWind != this.lastWind) {\r\n        this.currentWind = this.currentWind.nextWind;\r\n      } else {\r\n        this.currentWind = this.firstWind;\r\n      }\r\n      this.currentWind.arrow.setSelection(true);      \r\n      this.windOutput.print(this.currentWind);             \r\n    }\r\n    \r\n    /**\r\n     * Set height to this.currentWind and then order WindList for heights \r\n     * (increasing order, null is greater then number);\r\n     * you cannot change height of first wind (0) by construction.\r\n     * @param {number || null} height - Height of wind; if it is number then must be > 0.\r\n     * @return {boolean} - False if it is impossible to set this height \r\n     * (height is a number and such height has already existed).\r\n     */ \r\n    setHeightToCurrentWind(height) {\r\n      // We cannot change height for first (surface) wind by construction \r\n      if (this.currentWind == this.firstWind) {\r\n        throw(\"You cannot change height of this.firstWind!\");\r\n      }\r\n      \r\n      if ((typeof(height) == 'number') && (height <= 0)) {\r\n        throw(\"Height of winds must be > 0!\");\r\n      }      \r\n               \r\n      // Different cones must have different heights  \r\n      if (typeof(height) == 'number') {  \r\n        var wind = this.firstWind;        \r\n        while(true) {\r\n          if ((wind != this.currentWind) && (wind.getHeight() == height)) { \r\n            return(false);\r\n          }            \r\n          if ((wind == this.lastWind) || (wind.getHeight() == null)) break;          \r\n          wind = wind.nextWind;         \r\n        }\r\n      }     \r\n                        \r\n      var currentWind = this.currentWind;\r\n      \r\n      this.currentWind.setHeight(height);         \r\n      this.windOutput.print(this.currentWind);\r\n            \r\n      var wind = this.currentWind;\r\n \r\n      // Order windList by heights (increasing order, \r\n      // null values are greater than numbers)               \r\n      if (height == null) {         \r\n        while(true) {          \r\n          if (wind.nextWind == null || wind.nextWind.getHeight() == null) break;\r\n          var wind = wind.nextWind;        \r\n        }\r\n         \r\n        this.moveWind(currentWind, wind);\r\n              \r\n      } else {  // height is a number\r\n        \r\n        // Moving in previous order\r\n        if (wind.prevWind.getHeight() == null || \r\n            height < wind.prevWind.getHeight()) {  \r\n        \r\n          while(true) {\r\n            if (wind.prevWind.getHeight() != null) break; \r\n            wind = wind.prevWind;       \r\n          }\r\n              \r\n          while(true) {\r\n            if (height > wind.prevWind.getHeight()) break;\r\n            wind = wind.prevWind;\r\n          }\r\n          \r\n          this.moveWind(currentWind, wind.prevWind);\r\n          \r\n        } else {\r\n                \r\n          while(true) {\r\n            if (wind.nextWind == null || wind.nextWind.getHeight() == null ||\r\n                height < wind.nextWind.getHeight()) break;\r\n            wind = wind.nextWind;    \r\n          }\r\n          \r\n          this.moveWind(currentWind, wind);        \r\n        }                        \r\n      }\r\n            \r\n      return true;            \r\n    }\r\n    \r\n    /**\r\n     * Move windA to be next wind for windB;\r\n     * Here both windA and windB belong to windList;\r\n     * Remember, that in WindList first wind always exists. \r\n     */\r\n    moveWind(windA, windB) {\r\n      if (windA == windB || windA == windB.nextWind) return;\r\n              \r\n      if (windB == this.lastWind) {\r\n        \r\n        windA.nextWind.prevWind = windA.prevWind;\r\n        windA.prevWind.nextWind = windA.nextWind;        \r\n                \r\n        windB.nextWind = windA;\r\n        windA.prevWind = windB;\r\n\r\n        this.lastWind = windA;         \r\n      } else if (windA == this.lastWind) {\r\n        \r\n        this.lastWind = windA.prevWind;\r\n        windA.prevWind.nextWind = null;        \r\n\r\n        windA.nextWind = windB.nextWind;        \r\n        windB.nextWind.prevWind = windA;\r\n        \r\n        windA.prevWind = windB;\r\n        windB.nextWind = windA;              \r\n      } else {  // both windA and windB are not lastWind\r\n        \r\n        windA.nextWind.prevWind = windA.prevWind;\r\n        windA.prevWind.nextWind = windA.nextWind;         \r\n        \r\n        windA.nextWind = windB.nextWind;        \r\n        windB.nextWind.prevWind = windA;\r\n\r\n        windA.prevWind = windB;\r\n        windB.nextWind = windA;                    \r\n      }       \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Consider wind and wind.nextWind. \r\n     * Remember that windList is ordered, so height of wind.nextWind is \r\n     * greater than height of wind. \r\n     * We add winds between wind and wind.nextWind in such way that: \r\n     * difference between wind value of consistent winds will be \r\n     * no more than 1m/s and difference between wind direction will \r\n     * be no more than 5 degrees. \r\n     * THIS FUNCTION IS NOT CREATED YET.      \r\n     */\r\n    smoothList(wind) {\r\n      \r\n      // TODO: smoothing function for WindList\r\n      \r\n      if (wind == this.lastWind || wind.getHeight() == null ||\r\n          wind.nextWind.getHeight() == null) return;\r\n      \r\n      var h0 = wind.getHeight(),\r\n          v0 = wind.getValue(), \r\n          angle0 = wind.getAngle(), \r\n          h1 = wind.nextWind.getHeight(), \r\n          v1 = wind.nextWind.getValue(), \r\n          angle1 = wind.nextWind.getAngle();\r\n      var arr = [];\r\n     \r\n      if (v1 > v0 + 1 || angle1 > angle0 + 5) {\r\n        \r\n        var valueNumber = v1 - v0;\r\n        var angleNumber  = (angle1 - angle0)/5;\r\n        \r\n        var valueHeightSpan = (h1 - h0) / valueNumber;\r\n        var angleHeightSpan = (h1 - h0) / angleNumber;\r\n\r\n        var i = 1, \r\n            j = 1;        \r\n          \r\n        var h, angle;\r\n        \r\n        while(true) {\r\n          \r\n          break;\r\n          \r\n          var valueHeight = h0 + valueHeightSpan * i;\r\n          var angleHeight = h0 + angleHeightSpan * j;\r\n\r\n          var value = v0 + i; \r\n          var angle = angle0 + j * 5;\r\n          \r\n          if (valueHeight > angleHeight) {            \r\n            arr.push([h0 + angleHeight]);            \r\n          }                      \r\n        }\r\n                \r\n        /*\r\n        for(var i = 1; i < v1 - v0; i++) {\r\n          var h = h0 + d * i;\r\n          arr.push([h, v0 + i]);\r\n          console.log([h, v0 + i]);           \r\n        } */\r\n      }                \r\n    }\r\n\r\n    \r\n    setCurrentAngle(angle) {\r\n      this.currentWind.setAngle(angle);\r\n      this.windOutput.print(this.currentWind);             \r\n    }\r\n    \r\n    setCurrentValue(value) {\r\n      this.currentWind.setValue(value);\r\n      this.windOutput.print(this.currentWind);              \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Shift coordinates of all winds in such way \r\n     * that firstWind's coordinates will be point.\r\n     */\r\n    shiftList(point) {\r\n      var wind = this.firstWind;\r\n      var [x0, y0] = wind.arrow.geometry.getCoordinates();\r\n      var [cx, cy] = point;\r\n      while(true) {\r\n        var [x1, y1] = wind.arrow.geometry.getCoordinates();\r\n        var [x, y] = [x1 - x0 + cx, (y1 - y0) + cy];\r\n        wind.arrow.setCoordinates([x, y]);\r\n        if (wind == this.lastWind) break;\r\n        wind = wind.nextWind;                      \r\n      }      \r\n    }\r\n    \r\n    \r\n    createWindVertices() {\r\n      \r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        \r\n        if (wind.pathPoint == null) {\r\n          if (wind.pathVertex != null) {\r\n            wind.pathVertex.removeFromMap();\r\n            wind.pathVertex = null;             \r\n          }\r\n        } else {\r\n          if (wind.pathVertex == null) {\r\n            wind.pathVertex = new WindVertex(wind, this.map);\r\n            wind.pathVertex.addToMap();                        \r\n          } else {\r\n            wind.pathVertex.refreshCoordinates();              \r\n          }          \r\n        }        \r\n        wind = wind.nextWind;\r\n      }  \r\n    }\r\n    \r\n    \r\n    removeWindVertices() {\r\n      var wind = this.firstWind;\r\n      while(wind != null) {\r\n        if (wind.pathVertex != null) {        \r\n          wind.pathVertex.removeFromMap();\r\n          wind.pathVertex = null;\r\n          wind.pathPoint = null;\r\n        }        \r\n        wind = wind.nextWind;\r\n      }     \r\n    }\r\n    \r\n    \r\n    /**\r\n     * It is good idea not to use this function in WindList methods\r\n     * (because it uses outer objects); use this function beyond WindList class.\r\n     */\r\n    printCurrentWindWindow() {\r\n      if (this.currentWind == this.firstWind) {\r\n        $(\"#windHeightInput\").prop(\"disabled\", true);\r\n        $(\"#removeWind\").prop(\"disabled\", true);          \r\n      } else {\r\n        $(\"#windHeightInput\").prop(\"disabled\", false);\r\n        $(\"#removeWind\").prop(\"disabled\", false);\r\n      }\r\n      $(\"#windHeightInput\").val(this.currentWind.getHeight());    \r\n      $(\"#windDirectionInput\").val(this.currentWind.getAngle());\r\n      $(\"#windValueInput\").val(this.currentWind.getValue());\r\n      $(\"#arrowScale\").prop(\"checked\", this.currentWind.arrow.getIsScaled());\r\n      var angle = this.currentWind.getAngle();\r\n      $(\"#menuArrow\").css(\"transform\", \"rotate(\" + (-1)*angle + \"deg)\");\r\n      $(\"#menuWindValue\").html(this.currentWind.getValue() + \" м/с\");      \r\n    }        \r\n  }\r\n      \r\n  provide(WindList);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/WindList.js?");

/***/ }),

/***/ "./src/scripts/WindOutputElement.js":
/*!******************************************!*\
  !*** ./src/scripts/WindOutputElement.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindOutputElement', [\r\n  'OutputElement'       \r\n],\r\nfunction(provide, OutputElement) {\r\n  /**\r\n   * Window for outputing Wind value and Wind direction.\r\n   */\r\n  class WindOutputElement extends OutputElement {\r\n    \r\n    constructor(wind) {\r\n      super();\r\n      this.print(wind);\r\n    }\r\n    \r\n    /**\r\n     * @param {Wind} wind\r\n     */     \r\n    print(wind) {\r\n      var windHeight = wind.getHeight();\r\n      windHeight = (windHeight == null) ? '?' : windHeight;\r\n    \r\n      this.data.set(\"content\", \"Ветер: h = \" + windHeight + \"м, \" +\r\n        wind.getValue() + \" м/с, \" + wind.getDirection());        \r\n    }           \r\n  } \r\n  provide(WindOutputElement);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/WindOutputElement.js?");

/***/ }),

/***/ "./src/scripts/WindVertex.js":
/*!***********************************!*\
  !*** ./src/scripts/WindVertex.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('WindVertex', [\r\n  'Circle', \r\n  'Placemark'  \r\n],\r\nfunction(provide, Circle, Placemark) {\r\n  /**\r\n   * Point on Path which corresponding to Wind.\r\n   */\r\n  class WindVertex extends Circle {\r\n    /**\r\n     * @param {number[]} point - Yandex.Maps coordinates of center.\r\n     * @param {number} radius   \r\n     */\r\n    constructor(wind, map) {\r\n      \r\n      var point = wind.pathPoint;\r\n      var radius = 4;\r\n      \r\n      super([\r\n        point, \r\n        radius\r\n      ], {}, {}); \r\n       \r\n      var color = \"#00FF00\";                 \r\n      this.options.set(\"fillColor\", color);\r\n      this.options.set(\"strokeColor\", color);      \r\n      \r\n      this.map = map;\r\n      this.wind = wind;\r\n                  \r\n      // Distance from vertex to it's heightPlacemark\r\n      this.heightPlacemarkShift = 0.0001;\r\n      \r\n      // Placemark for Height of Chute at this vertex\r\n      this.heightPlacemark = new ymaps.Placemark(\r\n        [point[0] + this.heightPlacemarkShift, point[1]], \r\n        {}, \r\n        {\r\n          preset: 'islands#darkGreenStretchyIcon', \r\n          cursor: 'arrow'\r\n        }\r\n      );\r\n      \r\n      this.printPlacemark(wind.getHeight() + \" м\");  \r\n            \r\n      this.clickNumber = 0;\r\n      this.placemarkIsShown = true;\r\n                   \r\n      this.events.add('click', function(e) {\r\n        e.stopPropagation();  // remove standart zoom for click\r\n        this.processVertexClick();\r\n      }.bind(this));\r\n      \r\n      // remove standart map zoom for double click\r\n      this.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  \r\n      });          \r\n    }\r\n          \r\n    /**\r\n     * Process both click and dblclick on this vertex.\r\n     */       \r\n    processVertexClick() {\r\n \r\n    }\r\n   \r\n    /**\r\n     * @param {string} str - This will be printed in this.heightPlacemark\r\n     */    \r\n    printPlacemark(str) {\r\n      this.heightPlacemark.properties.set(\"iconContent\", str);           \r\n    }\r\n    \r\n    printHint(str) {\r\n      this.properties.set(\"hintContent\", str);      \r\n    }\r\n        \r\n    addToMap() {\r\n      this.map.geoObjects.add(this);\r\n      this.map.geoObjects.add(this.heightPlacemark);         \r\n    }\r\n    \r\n    removeFromMap() {\r\n      this.map.geoObjects.remove(this);\r\n      this.map.geoObjects.remove(this.heightPlacemark);        \r\n    }\r\n    \r\n    refreshCoordinates() {\r\n      var point = this.wind.pathPoint;\r\n      this.geometry.setCoordinates(point);\r\n      this.heightPlacemark.geometry.setCoordinates(\r\n        [point[0] + this.heightPlacemarkShift, point[1]]\r\n      );\r\n      this.printPlacemark(this.wind.getHeight() + \" м\");      \r\n    }            \r\n  } \r\n  provide(WindVertex);  \r\n}); \n\n//# sourceURL=webpack:///./src/scripts/WindVertex.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Program calculate heights of Chute for\r\n * vertices of the Path. Path is a set of line segments (edges).\r\n * You can input Path by clicking left mouse button.\r\n */\r\n\r\nymaps.ready(init);\r\nfunction init() {\r\n  ymaps.modules.require([\r\n    'AppMap',\r\n    'WindList',\r\n    'Chute',\r\n    'Path',\r\n    'Calculator',\r\n    'Menu',\r\n    'DialogWindows',\r\n    'Keyboard',\r\n    'Constant', \r\n    'BoundaryHeights'\r\n  ]).spread(function (\r\n    AppMap,\r\n    WindList,\r\n    Chute,\r\n    Path,\r\n    Calculator,\r\n    Menu,\r\n    DialogWindows,\r\n    Keyboard,\r\n    Constant, \r\n    BoundaryHeights\r\n  ) {\r\n    // Yandex map\r\n    var map = new AppMap();\r\n\r\n    // Chute velocity = (10, 5) m/s\r\n    var chute = new Chute(10, 5);\r\n\r\n    // Winds at several heights\r\n    var windList = new WindList(map);\r\n\r\n    // List of vertices and edges\r\n    var path = new Path(map);\r\n    \r\n    // Heights at the beginning and end of the Path\r\n    var boundaryHeights = new BoundaryHeights();\r\n\r\n    // Calculator will make all computations\r\n    var calculator = new Calculator(path, chute, windList, boundaryHeights);\r\n\r\n    path.setCalculator(calculator);\r\n    \r\n    windList.setCalculator(calculator);\r\n    windList.setPath(path);\r\n\r\n    boundaryHeights.setCalculator(calculator);\r\n    boundaryHeights.setPath(path);\r\n\r\n    // Set of buttons in the left side of screen:\r\n    // Settings, Chute, Wind, Help, Clean buttons.\r\n    var menu = new Menu(map, path, windList);\r\n\r\n    // Click on the map will add vertice to Path,\r\n    // double click on the map will add wind to WindList.\r\n    var clickNumber = 0;\r\n    map.events.add('click', function(e) {\r\n      var point = e.get('coords');\r\n      clickNumber++;\r\n      if (clickNumber == 1) {\r\n        setTimeout(function() {\r\n          if (clickNumber == 1) {  // Single Click\r\n            // We add vertex to path\r\n            path.addVertex(point);\r\n          } else {  // Double Click\r\n            // We add new wind arrow (windsock)\r\n            if (windList.lastWind.getHeight() != null) {\r\n              windList.addWind(point);\r\n              windList.printCurrentWindWindow();\r\n              menu.windButton.showMenu();\r\n              $(\"#menuArrow\").removeClass(\"arrow\");\r\n              $(\"#menuArrow\").addClass(\"arrow_selected\");\r\n            }\r\n          }\r\n          clickNumber = 0;\r\n        }, 200);\r\n      }\r\n    });\r\n\r\n    // Add events processing for Dialog Windows:\r\n    //   for Settings, Chute, Wind windows.\r\n    DialogWindows.initializeWindows(calculator);\r\n\r\n    // Add keyboard events:\r\n    //   left, right, up, down pressing (for changing wind value and direction),\r\n    //   enter key press on <input> tag - to loose focus after pressing enter.\r\n    Keyboard.startKeyboardProcessing(calculator);\r\n\r\n    // After yandex maps search we should:\r\n    //   move wind arrows to the current screen,\r\n    //   add result of search to Settings Dialog Window.\r\n    map.setSearchProcessor(calculator);\r\n  });\r\n}\n\n//# sourceURL=webpack:///./src/scripts/index.js?");

/***/ }),

/***/ 0:
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/scripts/AppMap.js ./src/scripts/Arrow.js ./src/scripts/BoundaryHeights.js ./src/scripts/Calculator.js ./src/scripts/Chute.js ./src/scripts/CircleVertex.js ./src/scripts/Constant.js ./src/scripts/DialogWindows.js ./src/scripts/index.js ./src/scripts/Keyboard.js ./src/scripts/Menu.js ./src/scripts/MenuButton.js ./src/scripts/OutputElement.js ./src/scripts/Path.js ./src/scripts/PathEdge.js ./src/scripts/TriangleVertex.js ./src/scripts/VectorMath.js ./src/scripts/Vertex.js ./src/scripts/Wind.js ./src/scripts/WindList.js ./src/scripts/WindOutputElement.js ./src/scripts/WindVertex.js ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/scripts/AppMap.js */\"./src/scripts/AppMap.js\");\n__webpack_require__(/*! ./src/scripts/Arrow.js */\"./src/scripts/Arrow.js\");\n__webpack_require__(/*! ./src/scripts/BoundaryHeights.js */\"./src/scripts/BoundaryHeights.js\");\n__webpack_require__(/*! ./src/scripts/Calculator.js */\"./src/scripts/Calculator.js\");\n__webpack_require__(/*! ./src/scripts/Chute.js */\"./src/scripts/Chute.js\");\n__webpack_require__(/*! ./src/scripts/CircleVertex.js */\"./src/scripts/CircleVertex.js\");\n__webpack_require__(/*! ./src/scripts/Constant.js */\"./src/scripts/Constant.js\");\n__webpack_require__(/*! ./src/scripts/DialogWindows.js */\"./src/scripts/DialogWindows.js\");\n__webpack_require__(/*! ./src/scripts/index.js */\"./src/scripts/index.js\");\n__webpack_require__(/*! ./src/scripts/Keyboard.js */\"./src/scripts/Keyboard.js\");\n__webpack_require__(/*! ./src/scripts/Menu.js */\"./src/scripts/Menu.js\");\n__webpack_require__(/*! ./src/scripts/MenuButton.js */\"./src/scripts/MenuButton.js\");\n__webpack_require__(/*! ./src/scripts/OutputElement.js */\"./src/scripts/OutputElement.js\");\n__webpack_require__(/*! ./src/scripts/Path.js */\"./src/scripts/Path.js\");\n__webpack_require__(/*! ./src/scripts/PathEdge.js */\"./src/scripts/PathEdge.js\");\n__webpack_require__(/*! ./src/scripts/TriangleVertex.js */\"./src/scripts/TriangleVertex.js\");\n__webpack_require__(/*! ./src/scripts/VectorMath.js */\"./src/scripts/VectorMath.js\");\n__webpack_require__(/*! ./src/scripts/Vertex.js */\"./src/scripts/Vertex.js\");\n__webpack_require__(/*! ./src/scripts/Wind.js */\"./src/scripts/Wind.js\");\n__webpack_require__(/*! ./src/scripts/WindList.js */\"./src/scripts/WindList.js\");\n__webpack_require__(/*! ./src/scripts/WindOutputElement.js */\"./src/scripts/WindOutputElement.js\");\nmodule.exports = __webpack_require__(/*! ./src/scripts/WindVertex.js */\"./src/scripts/WindVertex.js\");\n\n\n//# sourceURL=webpack:///multi_./src/scripts/AppMap.js_./src/scripts/Arrow.js_./src/scripts/BoundaryHeights.js_./src/scripts/Calculator.js_./src/scripts/Chute.js_./src/scripts/CircleVertex.js_./src/scripts/Constant.js_./src/scripts/DialogWindows.js_./src/scripts/index.js_./src/scripts/Keyboard.js_./src/scripts/Menu.js_./src/scripts/MenuButton.js_./src/scripts/OutputElement.js_./src/scripts/Path.js_./src/scripts/PathEdge.js_./src/scripts/TriangleVertex.js_./src/scripts/VectorMath.js_./src/scripts/Vertex.js_./src/scripts/Wind.js_./src/scripts/WindList.js_./src/scripts/WindOutputElement.js_./src/scripts/WindVertex.js?");

/***/ })

/******/ });