/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/Arrow.js":
/*!******************************!*\
  !*** ./src/scripts/Arrow.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Arrow */\r\nymaps.modules.define('Arrow', [\r\n  'Placemark',\r\n  'templateLayoutFactory'        \r\n],\r\nfunction(provide, Placemark, templateLayoutFactory) {\r\n  \r\n  /**\r\n   * Yandex Maps Placemark for Arrow (Windsock). \r\n   */\r\n  class Arrow extends Placemark {\r\n\r\n    constructor(center, isMobile) {      \r\n      var arrowStartSize = 25;\r\n      // radius of start active area for Arrow\r\n      var arrowStartRadius = isMobile ? arrowStartSize : arrowStartSize/2; \r\n        \r\n      super(\r\n        center, \r\n        {\r\n          rotation: 90, \r\n          size: arrowStartSize\r\n        }, \r\n        {\r\n          draggable: true,\r\n          iconLayout: templateLayoutFactory.createClass(\r\n              '<div class=\"arrow\" style=\"transform: rotate($[properties.rotation]deg);' + \r\n              'width: $[properties.size]px; height: $[properties.size]px;\"/>'\r\n            ), \r\n          iconShape: {\r\n            type: 'Circle',\r\n            coordinates: [arrowStartSize/2, arrowStartSize/2],\r\n            radius: arrowStartRadius\r\n          }          \r\n        }\r\n      );\r\n\r\n      this.arrowStartSize = arrowStartSize;\r\n      this.arrowStartRadius = arrowStartRadius;    \r\n    }\r\n   \r\n   /**\r\n    * Rotate arrow\r\n    */\r\n    rotate(angle) {\r\n      this.properties.set('rotation', (-1)*angle + 90);      \r\n    }\r\n    \r\n    /**\r\n     * Arrow will have different size for different Zoom.\r\n     */\r\n    changeSize(newZoom) {\r\n      var size = (2**(newZoom - 16))*(this.arrowStartSize);\r\n      \r\n      var shape = \r\n        {\r\n          type: 'Circle',\r\n          coordinates: [size/2, size/2],\r\n          radius: (2**(newZoom - 16))*(this.arrowStartRadius)\r\n        };\r\n      \r\n      this.options.set('iconShape', shape);      \r\n      this.properties.set('size', size);\r\n      // properties.set call rebuild of Placemark, \r\n      // so, properties.set should stay after options.set      \r\n    }    \r\n  }\r\n\r\n  provide(Arrow);  \r\n});\n\n//# sourceURL=webpack:///./src/scripts/Arrow.js?");

/***/ }),

/***/ "./src/scripts/Calculator.js":
/*!***********************************!*\
  !*** ./src/scripts/Calculator.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Calculator */\r\nymaps.modules.define('Calculator', [],\r\nfunction(provide) {\r\n\r\n  class Calculator {\r\n    /**\r\n     * @param {Path} path - list of vertices and line segments of Chute Path.\r\n     * @param {Wind} wind - wind velocity\r\n     * @param {Chute} chute - chute velocity\r\n     * @param {number} startHeight - start height of chute, in meters.   \r\n     */\r\n    constructor(path, wind, chute, startHeight) {      \r\n      this.path = path;\r\n      this.chute = chute;\r\n      this.wind = wind;  \r\n      this.startHeight = startHeight;      \r\n    }\r\n    \r\n    \r\n    setStartHeight(startHeight) {\r\n      this.startHeight = startHeight;\r\n    }\r\n    \r\n    /** \r\n     * Calculate heightes in vertices of Chute Path.\r\n     * @return {number[]} height. \r\n     * Here height[i]  = height at the ith vertex of Path (in meters).\r\n     * If height.length < path.length than it is impossible\r\n     * to fly this Path.\r\n     */      \r\n    calculateHeight() {\r\n      var height = [];\r\n      var time = this.calculateTime();\r\n      \r\n      height[0] = this.startHeight;\r\n      for(var i=1; i<time.length; i++) {\r\n        height[i] = height[i-1] - time[i] * this.chute.verticalVel;\r\n      }\r\n      \r\n      return(height);\r\n    }\r\n\r\n    /** \r\n     * Calculate time of Chute flying along Path. In Path vertices.  \r\n     * @return {number[]} time.\r\n     * Here time[i]  = time of flying along ith segment of Path (in seconds).\r\n     * If time.length < path.length, than it is impossible\r\n     * to fly this Path.\r\n     */    \r\n    calculateTime() {  \r\n    \r\n      var time = [];  \r\n                                                 \r\n      var path = this.path;\r\n      var chute = this.chute;\r\n      var wind = this.wind;\r\n      var startHeight = this.startHeight;\r\n      \r\n      var currentVertex = path.firstVertex;\r\n      \r\n      if (path.length > 0) time[0] = 0;\r\n      \r\n      for(var i=1; i < path.length; i++) {\r\n                \r\n        // Let's find right norm basis (e, f), first vector of which\r\n        // has the same direction with vector prevPointcurrentPoint\r\n          \r\n        var nextVertex = currentVertex.nextVertex;\r\n       \r\n        var currentPoint = currentVertex.geometry.getCoordinates();\r\n        var nextPoint = nextVertex.geometry.getCoordinates();        \r\n          \r\n        var dist = ymaps.coordSystem.geo.getDistance(currentPoint, nextPoint);\r\n        \r\n        // Yandex Maps Coordinates: (latitude, longitude)\r\n        // Latitude is increasing from bottom to top (-90deg, 90deg)\r\n        // Longitude is increasing from West to East (-180deg, 180deg)\r\n        var ex = nextPoint[1] - currentPoint[1];\r\n        var ey = nextPoint[0] - currentPoint[0]; \r\n                                 \r\n        var d = Math.sqrt(ex*ex + ey*ey);\r\n        ex = ex / d;\r\n        ey = ey / d;\r\n        \r\n        var fx = -ey;\r\n        var fy = ex;\r\n        \r\n        // Let's find coordinates (we, wf) of vector 'wind' in basis (e, f).\r\n        // (e, f) is orthogonal basis, so we = (wind, e), wf = (wind, f).\r\n        var [wx, wy] = wind.getXY();\r\n     \r\n        var we = wx * ex + wy * ey; \r\n        var wf = wx * fx + wy * fy;     \r\n         \r\n        // Let's find coordinates (ce, cf) of chute velocity \r\n        // in basis (e, f):\r\n        \r\n        var cf = (-1)*wf;\r\n        \r\n        // it is impossible to fly this segment\r\n        if (chute.horizontalVel < Math.abs(cf)) break;\r\n    \r\n        var ce = Math.sqrt(chute.horizontalVel**2 - cf**2);\r\n        \r\n        // We consider only case, where ce > 0 \r\n        // (it's always the case, if chute velocity is greater than wind velocity)    \r\n        // In general case you should consider case, \r\n        // when ce < 0 (case when diver flies forward with his back)   \r\n\r\n        // 0.1 m/sec is too small velocity\r\n        // So, it is impossible to fly this segment        \r\n        if (ce + we <= 0.1) {  \r\n          break;\r\n        } else {\r\n          time[i] = dist / (ce + we);                   \r\n        }\r\n\r\n        currentVertex = nextVertex;        \r\n      }\r\n      \r\n      return(time);        \r\n    }\r\n  }\r\n      \r\n  provide(Calculator);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Calculator.js?");

/***/ }),

/***/ "./src/scripts/Chute.js":
/*!******************************!*\
  !*** ./src/scripts/Chute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Chute', [],\r\nfunction(provide) {\r\n\r\n  class Chute {\r\n    /**\r\n     * @param {number} horizontalVel - Horizontal chute velocity, in m/sec.\r\n     * @param {number} verticalVel - Vertical chute velocity, in m/sec.     \r\n     */\r\n    constructor(horizontalVel, verticalVel) {\r\n      this.horizontalVel = horizontalVel; \r\n      this.verticalVel = verticalVel;   \r\n    }   \r\n  }\r\n      \r\n  provide(Chute);  \r\n});       \n\n//# sourceURL=webpack:///./src/scripts/Chute.js?");

/***/ }),

/***/ "./src/scripts/Path.js":
/*!*****************************!*\
  !*** ./src/scripts/Path.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @module Path */      \r\nymaps.modules.define('Path', [\r\n  'Circle', \r\n  'Polyline',\r\n  'Placemark',  \r\n  'YmapsCircleVertex', \r\n  'YmapsTriangleVertex'  \r\n],\r\nfunction(provide, Circle, Polyline, Placemark, YmapsCircleVertex, YmapsTriangleVertex) {     \r\n  /**\r\n   * List of vertices and line segments of Chute Path.\r\n   * Line segments connect vertices.\r\n   * Last vertex consist of one outer invisible Circle (ymaps.Circle)  \r\n   * and arrow (YmapsTriangleVertex object that extends ymaps.Polyline).\r\n   * Other vertices consist of one outer invisible Circle (ymaps.Circle)\r\n   * and one visible inner Circle (ymaps.Circle). \r\n   * Outer vertex circles are invisible and serve for handy clicking  \r\n   * vertices.\r\n   */  \r\n  class Path {\r\n    /**\r\n     * @param {Map} map - link to Yandex map.\r\n     * @param {boolean} isMobile   \r\n     */  \r\n    constructor(map, isMobile) {\r\n      this.map = map;\r\n      this.firstVertex = null;\r\n      this.lastVertex = null;\r\n      // number of vertices\r\n      this.length = 0;\r\n            \r\n      // radius for inner circle vertices, in meters\r\n      this.vertexRadius = 7;\r\n      // radius for outer invisible circles, in meters    \r\n      this.vertexOuterRadius = isMobile ? 4*this.vertexRadius : 2*this.vertexRadius;     \r\n\r\n      // On the map: line segments should be under vertex images, \r\n      // vertex images should be under vertices\r\n      this.vertexZIndex = 2;      \r\n      this.imageZIndex = 1;\r\n      this.lineZIndex = 0;\r\n\r\n      // Distance from vertex to it's heightPlacemark\r\n      this.heightPlacemarkShift = 0.0002;\r\n  \r\n      //this.addVertex = this.addVertex.bind(this);\r\n      //this.removeVertex = this.removeVertex.bind(this);\r\n      //this.dragVertex = this.dragVertex.bind(this);\r\n      //this.clear = this.clear.bind(this);          \r\n    }\r\n    \r\n    /**\r\n     * Add new vertex to Path and to map.\r\n     * Add corresponding line segment to Path and to map.\r\n     * @param {number[]} point - Yandex.Maps coordinates, point = [x, y].\r\n     * @return {Array} New last vertex and new last line segment of Path.\r\n     */\r\n    addVertex(point) {  \r\n      var map = this.map;\r\n           \r\n      var vertex = new ymaps.Circle([\r\n        point, \r\n        this.vertexOuterRadius\r\n      ], {}, {\r\n        draggable: true,\r\n        // vertex will be invisible\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: this.vertexZIndex\r\n      });\r\n\r\n      // Placemark for Height of Chute ot this vertex\r\n      vertex.heightPlacemark = new ymaps.Placemark(\r\n        [point[0] + this.heightPlacemarkShift, point[1]], \r\n        {}, \r\n        {\r\n          preset: 'islands#blackStretchyIcon', \r\n          cursor: 'arrow'\r\n        }\r\n      );      \r\n              \r\n      if (this.length > 0) {\r\n                          \r\n        var lastPoint = this.lastVertex.geometry.getCoordinates();    \r\n                \r\n\r\n        var newLine = \r\n          new ymaps.Polyline([lastPoint, point], {}, {zIndex: this.lineZIndex});          \r\n        map.geoObjects.add(newLine); \r\n                \r\n        // We change last Triengle vertex to Circle vertex\r\n        map.geoObjects.remove(this.lastVertex.image);        \r\n        this.lastVertex.image = \r\n          new YmapsCircleVertex(lastPoint, this.vertexRadius, this.imageZIndex);\r\n        map.geoObjects.add(this.lastVertex.image);\r\n                        \r\n        this.lastVertex.nextVertex = vertex;\r\n        vertex.prevVertex = this.lastVertex;\r\n        \r\n        this.lastVertex.nextLine = newLine; \r\n        newLine.prevVertex = this.lastVertex;        \r\n                \r\n        vertex.image = new YmapsTriangleVertex(lastPoint, point, this.imageZIndex);\r\n      } else {  // this.length = 0;\r\n        this.firstVertex = vertex;      \r\n        vertex.image = new YmapsCircleVertex(point, this.vertexRadius, this.imageZIndex);  \r\n      }\r\n      \r\n      map.geoObjects.add(vertex.image);\r\n      map.geoObjects.add(vertex);\r\n      map.geoObjects.add(vertex.heightPlacemark);\r\n            \r\n      this.lastVertex = vertex;        \r\n      this.length++; \r\n   \r\n      return([\r\n        vertex, \r\n        (this.length > 1) ? vertex.prevVertex.nextLine : null      \r\n      ]);       \r\n    }\r\n    \r\n        \r\n    /**\r\n     * Divide line segment of Path by point.\r\n     * Point should be on that line segment. \r\n     * @param {Polyline} line\r\n     * @param {number[]} point - Yandex.maps coordinates.\r\n     * @return {Array} New vertex and two new line segments of Path.     \r\n     */        \r\n    divideLine(line, point) {\r\n      var map = this.map;\r\n\r\n      var prevVertex = line.prevVertex,\r\n          nextVertex = line.prevVertex.nextVertex;\r\n          \r\n      var prevPoint = prevVertex.geometry.getCoordinates(), \r\n          nextPoint = nextVertex.geometry.getCoordinates();\r\n\r\n      var vertex = new ymaps.Circle([\r\n        point, \r\n        this.vertexOuterRadius\r\n      ], {}, {\r\n        draggable: true,\r\n        // vertex will be invisible\r\n        fillOpacity: 0,\r\n        strokeOpacity: 0, \r\n        strokeWidth: 0, \r\n        zIndex: this.vertexZIndex\r\n      });\r\n      \r\n      vertex.image = new YmapsCircleVertex(point, this.vertexRadius, this.imageZIndex);\r\n\r\n      // Placemark for Height of Chute ot this vertex\r\n      vertex.heightPlacemark = new ymaps.Placemark(\r\n        [point[0] + this.heightPlacemarkShift, point[1]], \r\n        {}, \r\n        {\r\n          preset: 'islands#blackStretchyIcon', \r\n          cursor: 'arrow'\r\n        }\r\n      ); \r\n      \r\n      var newLine1 = \r\n        new ymaps.Polyline([prevPoint, point], {}, {zIndex: this.lineZIndex});      \r\n\r\n      var newLine2 = \r\n        new ymaps.Polyline([point, nextPoint], {}, {zIndex: this.lineZIndex});        \r\n\r\n      vertex.prevVertex = prevVertex;\r\n      vertex.nextVertex = nextVertex;\r\n      \r\n      prevVertex.nextVertex = vertex;\r\n      nextVertex.prevVertex = vertex;\r\n \r\n      prevVertex.nextLine = newLine1;\r\n      vertex.nextLine = newLine2;\r\n      \r\n      newLine1.prevVertex = prevVertex;\r\n      newLine2.prevVertex = vertex;\r\n      \r\n      this.length++;\r\n\r\n      map.geoObjects.remove(line);\r\n      map.geoObjects.add(vertex.image);\r\n      map.geoObjects.add(vertex);\r\n      map.geoObjects.add(vertex.heightPlacemark);\r\n      map.geoObjects.add(newLine1);\r\n      map.geoObjects.add(newLine2);\r\n            \r\n      return([vertex, newLine1, newLine2]);      \r\n    }\r\n    \r\n\r\n    /**\r\n     * Remove vertex from Path and from map.\r\n     * @param {Circle} removingVertex\r\n     * @return {Polyline} Line between previous and next vertices. \r\n     */    \r\n    removeVertex(removingVertex) {\r\n      var map = this.map;\r\n    \r\n      map.geoObjects.remove(removingVertex);\r\n      map.geoObjects.remove(removingVertex.image);\r\n      \r\n      if (removingVertex.heightPlacemark != undefined) {\r\n        map.geoObjects.remove(removingVertex.heightPlacemark);  \r\n      }\r\n      \r\n      var prevVertex = removingVertex.prevVertex;\r\n      var nextVertex = removingVertex.nextVertex;\r\n      \r\n      var newLine = null;\r\n      \r\n      if (this.length > 1) {\r\n        if ((prevVertex != undefined) && (nextVertex != undefined)) {\r\n          \r\n          var removingLine1 = prevVertex.nextLine;\r\n          var removingLine2 = removingVertex.nextLine;\r\n          \r\n          map.geoObjects.remove(removingLine1);\r\n          map.geoObjects.remove(removingLine2);\r\n          \r\n          var prevPoint = prevVertex.geometry.getCoordinates();\r\n          var nextPoint = nextVertex.geometry.getCoordinates();\r\n                    \r\n          newLine = \r\n            new ymaps.Polyline([prevPoint, nextPoint], {}, {zIndex: this.lineZIndex});\r\n          this.map.geoObjects.add(newLine);\r\n          \r\n          prevVertex.nextLine = newLine;\r\n          prevVertex.nextVertex = nextVertex;\r\n          nextVertex.prevVertex = prevVertex;\r\n          \r\n          newLine.prevVertex = prevVertex;\r\n          \r\n          \r\n          // case when nextVertex is lastVertex \r\n          // and so we have to change direction of \r\n          // arrow (triangle) of lastVertex\r\n          if (nextVertex.nextVertex == undefined) {\r\n            map.geoObjects.remove(nextVertex.image);            \r\n            nextVertex.image = \r\n              new YmapsTriangleVertex(prevPoint, nextPoint, this.imageZIndex);\r\n            map.geoObjects.add(nextVertex.image);            \r\n          }         \r\n        } else if (nextVertex == undefined) {  // last vertex case   \r\n          var removingLine = prevVertex.nextLine;\r\n          map.geoObjects.remove(removingLine);\r\n          this.lastVertex = prevVertex;\r\n          prevVertex.nextVertex = null;\r\n          prevVertex.nextLine = null; \r\n          if (prevVertex.prevVertex != undefined) {\r\n            map.geoObjects.remove(prevVertex.image);\r\n            var prevPrevPoint = prevVertex.prevVertex.geometry.getCoordinates();\r\n            var prevPoint = prevVertex.geometry.getCoordinates();            \r\n            prevVertex.image = \r\n              new YmapsTriangleVertex(prevPrevPoint, prevPoint, this.imageZIndex);\r\n            map.geoObjects.add(prevVertex.image);            \r\n          }          \r\n        } else {  // first vertex case\r\n          map.geoObjects.remove(removingVertex.nextLine); \r\n          nextVertex.prevVertex = null;\r\n          this.firstVertex = nextVertex;           \r\n          \r\n          if (this.length == 2) {\r\n            var p = nextVertex.geometry.getCoordinates();\r\n            map.geoObjects.remove(nextVertex.image);\r\n            nextVertex.image = \r\n              new YmapsCircleVertex(p, this.vertexRadius, this.imageZIndex);\r\n            map.geoObjects.add(nextVertex.image);\r\n          }            \r\n        }\r\n      } else {  // case: only one circle\r\n        this.lastVertex = null;\r\n      }\r\n      \r\n      this.length--;\r\n      return(newLine);\r\n    }\r\n\r\n    \r\n    /**\r\n     * Drag vertex with neibour line segments.\r\n     * @param {Circle} vertex\r\n     */     \r\n    dragVertex(vertex) {\r\n      var map = this.map;\r\n      \r\n      // new vertex coordinates\r\n      var point = vertex.geometry.getCoordinates();\r\n      \r\n      \r\n      if (vertex.heightPlacemark != undefined) {\r\n        vertex.heightPlacemark.geometry.setCoordinates(\r\n          [point[0] + this.heightPlacemarkShift, point[1]]\r\n        );\r\n      } \r\n                       \r\n      var nextVertex = vertex.nextVertex;\r\n      var prevVertex = vertex.prevVertex;  \r\n      \r\n      // Case: both prevVertex and nextVertex don't exist, \r\n      // that is, path consists of one vertex\r\n      if ((nextVertex == undefined) && (prevVertex == undefined)) {\r\n        vertex.image.geometry.setCoordinates(point);\r\n        return;\r\n      }\r\n\r\n      // Case: both prevVertex and nextVertex exist,\r\n      // that is this vertex is not first and not last.     \r\n      if ((nextVertex != undefined) && (prevVertex != undefined)) {\r\n\r\n        vertex.image.geometry.setCoordinates(point); \r\n        \r\n        var nextPoint = nextVertex.geometry.getCoordinates();\r\n        var prevPoint = prevVertex.geometry.getCoordinates();\r\n        \r\n        var nextLine = vertex.nextLine;\r\n        var prevLine = prevVertex.nextLine;\r\n        \r\n        nextLine.geometry.setCoordinates([point, nextPoint]);\r\n        prevLine.geometry.setCoordinates([prevPoint, point]);        \r\n      \r\n        // Case when vertex.nextVertex is lastVertex:\r\n        // in that case your should change \r\n        // direction of arrow at lastVertex.\r\n        if (nextVertex.nextVertex == undefined) {        \r\n          nextVertex.image.setCoordinates(point, nextPoint);\r\n        }\r\n\r\n        return;        \r\n      }\r\n      \r\n      // Case: prevVertex exists, nextVertex doesn't exist, \r\n      // that is, vertex is lastVertex.      \r\n      if (prevVertex != undefined) {        \r\n        var prevPoint = prevVertex.geometry.getCoordinates();\r\n        var prevLine = prevVertex.nextLine;        \r\n        prevLine.geometry.setCoordinates([prevPoint, point]);\r\n\r\n        // We should change direction of arrow at the vertex\r\n        vertex.image.setCoordinates(prevPoint, point);         \r\n        return;        \r\n      }\r\n            \r\n      // Case: nextVertex exists, prevVertex doesn't exist, \r\n      // that is, vertex is firstVertex. \r\n      vertex.image.geometry.setCoordinates(point);\r\n      \r\n      var nextPoint = nextVertex.geometry.getCoordinates();\r\n      var nextLine = vertex.nextLine;        \r\n      nextLine.geometry.setCoordinates([point, nextPoint]);\r\n\r\n      // Case when vertex.nextVertex is lastVertex:\r\n      // in that case your should change \r\n      // direction of arrow at lastVertex.\r\n      if (nextVertex.nextVertex == undefined) {            \r\n        nextVertex.image.setCoordinates(point, nextPoint);                  \r\n      }\r\n      return;            \r\n    }\r\n\r\n    \r\n    /** Remove all vetrices and line segments from Path and from map. */    \r\n    clear() {\r\n      var map = this.map;\r\n           \r\n      if (this.length == 0 ) return;\r\n      \r\n      var vertex = this.lastVertex;  \r\n      map.geoObjects.remove(vertex);\r\n      map.geoObjects.remove(vertex.image);\r\n      map.geoObjects.remove(vertex.heightPlacemark);\r\n      \r\n      for(var i=1; i < this.length; i++) {\r\n        vertex = vertex.prevVertex; \r\n        map.geoObjects.remove(vertex);\r\n        map.geoObjects.remove(vertex.image);\r\n        map.geoObjects.remove(vertex.nextLine);\r\n        map.geoObjects.remove(vertex.heightPlacemark);\r\n      }\r\n      \r\n      this.length = 0;\r\n      this.lastVertex = null;  \r\n    }\r\n\r\n    /**\r\n     * Print heights in vertices hints.\r\n     * @param {number[]} height - heights in Path vertices.\r\n     */     \r\n    printHeightHints(height) {\r\n      if (this.length > 0) {      \r\n        var vertex = this.firstVertex;      \r\n        for(var i=0; i<height.length; i++) {\r\n          vertex.properties.set(\"hintContent\", \"h=\" + \r\n                                       Math.floor(height[i]) + \"м\");\r\n          vertex.heightPlacemark.properties.set(\"iconContent\", \"h=\" + \r\n                                       Math.floor(height[i]) + \"м\");\r\n                                       \r\n          vertex = vertex.nextVertex;\r\n        }\r\n        for(var i=height.length; i<this.length; i++) {\r\n          vertex.properties.set(\"hintContent\", \"Невозможно!\");\r\n          vertex.heightPlacemark.properties.set(\"hintContent\", \"Невозможно!\");            \r\n          vertex = vertex.nextVertex;                    \r\n        }\r\n      }      \r\n    }   \r\n  }\r\n  \r\n  provide(Path);      \r\n});      \r\n\n\n//# sourceURL=webpack:///./src/scripts/Path.js?");

/***/ }),

/***/ "./src/scripts/Wind.js":
/*!*****************************!*\
  !*** ./src/scripts/Wind.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('Wind', [],\r\nfunction(provide) {\r\n\r\n  class Wind {\r\n    /** \r\n     * Wind in polar coordinate system.\r\n     * @param {number} value - in m/sec.\r\n     * @param {number} angle - between current wind and west wind, in degree.     \r\n     */\r\n    constructor(value, angle) {\r\n      this.value = value;\r\n      this.angle = angle;    \r\n    }\r\n    \r\n    /**\r\n     * Calculate wind coordinates in cartesian coordinate system.\r\n     * @return {number[]} [vx, vy] - coordinates, in m/sec.\r\n     */\r\n    getXY () {      \r\n      var radiandirection = this.angle * ((2*Math.PI)/360);       \r\n      var vx = this.value * Math.cos(radiandirection);\r\n      var vy = this.value * Math.sin(radiandirection);\r\n      return [vx, vy];      \r\n    } \r\n    \r\n    /**\r\n     * Get name of wind direction (E, N, W, S, ...)\r\n     */    \r\n    getDirection() {     \r\n      var angleSwitch = Math.floor((this.angle + 180 + 22)/45);\r\n      var direction;\r\n      \r\n      switch(angleSwitch) {\r\n        case 0: direction = \"В\"; break;\r\n        case 1: direction = \"СВ\"; break;\r\n        case 2: direction = \"С\"; break;\r\n        case 3: direction = \"СЗ\"; break;\r\n        case 4: direction = \"З\"; break;\r\n        case 5: direction = \"ЮЗ\"; break;\r\n        case 6: direction = \"Ю\"; break;\r\n        case 7: direction = \"ЮВ\"; break;\r\n        case 8: direction = \"В\"; break;    \r\n      }\r\n      \r\n      return direction;     \r\n    }        \r\n  }\r\n      \r\n  provide(Wind);  \r\n});      \r\n      \n\n//# sourceURL=webpack:///./src/scripts/Wind.js?");

/***/ }),

/***/ "./src/scripts/YmapsCircleVertex.js":
/*!******************************************!*\
  !*** ./src/scripts/YmapsCircleVertex.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('YmapsCircleVertex', [\r\n  'Circle'       \r\n],\r\nfunction(provide, Circle) {\r\n  \r\n  class YmapsCircleVertex extends Circle {\r\n    /**\r\n     * @param {number[]} center - Yandex.Maps coordinates.\r\n     * @param {number} radius\r\n     * @param {number} zIndex - z-index of Circle.     \r\n     */\r\n    constructor(center, radius, zIndex=0) {\r\n      super([center, radius]);\r\n      this.options.set(\"fillColor\", \"#0000FF\");\r\n      this.options.set(\"strokeColor\", \"#0000FF\");\r\n      this.options.set(\"zIndex\", zIndex);       \r\n    }\r\n  } \r\n  provide(YmapsCircleVertex);  \r\n});      \r\n      \n\n//# sourceURL=webpack:///./src/scripts/YmapsCircleVertex.js?");

/***/ }),

/***/ "./src/scripts/YmapsTriangleVertex.js":
/*!********************************************!*\
  !*** ./src/scripts/YmapsTriangleVertex.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("ymaps.modules.define('YmapsTriangleVertex', [\r\n  'Polygon'    \r\n],\r\nfunction(provide, Polygon) {\r\n \r\n  /** \r\n   * Let point1, point2 - two points with Yandex.maps (geodesic) coordinates. \r\n   * YmapsTriangleVertex is Yandex maps triangle, \r\n   * such that vector (point1, point2) and that triangle \r\n   * form arrow (end of path).\r\n   * Size of arrow is determined by scale varialable. \r\n   */ \r\n  class YmapsTriangleVertex extends Polygon {\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates. \r\n     * @param {number} zIndex - z-index of Polygon.     \r\n     */\r\n    constructor(point1, point2, zIndex=0) {\r\n      // four square brackets is a must, \r\n      // non empty super constructor is a must     \r\n      super([[point2, point2, point2]]);   \r\n   \r\n      // scale determines arrow size\r\n      this.scale = 0.00008;\r\n            \r\n      this.geometry.setCoordinates([\r\n        this.calculateVertices(point1, point2)\r\n      ]); \r\n      \r\n      this.options.set(\"fillColor\", \"#0000FF\");\r\n      this.options.set(\"strokeColor\", \"#0000FF\");\r\n      this.options.set(\"zIndex\", zIndex);      \r\n    }\r\n\r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps coordinates.    \r\n     */    \r\n    setCoordinates (point1, point2) {\r\n      this.geometry.setCoordinates([\r\n        this.calculateVertices(point1, point2)\r\n      ]);  \r\n    }\r\n    \r\n    /**\r\n     * @param {number[]} point1 - Yandex.Maps point coordinates.\r\n     * @param {number[]} point2 - Yandex.Maps point coordinates.\r\n     * @return {number[][]} p - Array of vertices of YmapsTriangleVertex.      \r\n     */     \r\n    calculateVertices (point1, point2) {\r\n      var scale = this.scale;        \r\n      var latitude = point1[0],\r\n          geodesicArrowVector = subVectors(point2, point1),\r\n          localArrowVector = toLocalVector(geodesicArrowVector, latitude, scale);         \r\n\r\n      localArrowVector = normaliseVector(localArrowVector);                \r\n      \r\n      var v = [[-2, 1], [-2, -1], [0, 0]];\r\n      var p = [];                 \r\n      for(var i=0; i<3; i++) {   \r\n        v[i] = rotateVector(v[i], localArrowVector);\r\n        p[i] = addVectors(point2, toGeodesicVector(v[i], latitude, scale));\r\n      }\r\n            \r\n      return(p);\r\n      \r\n      // scale: we want our local coordinates to be \r\n      // of the same size as 1 (m) for our arrow  \r\n      function toLocalVector(geodesicVector, latitude, scale) {  \r\n        var vx = geodesicVector[0]/scale;\r\n        var vy = (geodesicVector[1]/scale) * \r\n                  Math.cos((Math.PI/180)*latitude);\r\n        return([vx, vy]);\r\n      }\r\n      \r\n      function toGeodesicVector(localVector, latitude, scale) {\r\n        var vlat = localVector[0]*scale;\r\n        var vlon = (localVector[1]*scale) / \r\n                    Math.cos((Math.PI/180)*latitude);\r\n        return([vlat, vlon]);\r\n      }\r\n\r\n      function normaliseVector(v) {\r\n        var d = Math.sqrt(v[0]**2 + v[1]**2);\r\n        if (d>0) {\r\n          return ([v[0]/d, v[1]/d]);\r\n        }         \r\n        return 0;\r\n      }\r\n\r\n      // n = (cos(alpha), sin(alpha)), \r\n      // alpha is angle of rotation\r\n      function rotateVector(v, n) {\r\n        var wx = n[0]*v[0] - n[1]*v[1];\r\n        var wy = n[1]*v[0] + n[0]*v[1];\r\n        return ([wx, wy]);        \r\n      }\r\n\r\n      function addVectors(p1, p2) {\r\n        return([p1[0] + p2[0], p1[1] + p2[1]]);\r\n      } \r\n      \r\n      function subVectors(p1, p2) {\r\n        return([p1[0] - p2[0], p1[1] - p2[1]]);\r\n      }   \r\n    }        \r\n  }\r\n  \r\n  provide(YmapsTriangleVertex);      \r\n});\n\n//# sourceURL=webpack:///./src/scripts/YmapsTriangleVertex.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** \r\n * Program calculate height of Chute for \r\n * given point on the Path. Path is a set of line segments. \r\n * You can input Path by clicking left mouse button.\r\n */\r\n \r\n \r\n// Determine mobile or desktop cases.\r\nvar isMobile = false;\r\nif(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) { \r\n  isMobile = true;\r\n}\r\n\r\n      \r\nymaps.ready(init);  \r\nfunction init() { \r\n  var dz = [\r\n    {name: \"Коломна\", mapCenter: [55.091289443603706, 38.917269584802675]}, \r\n    {name: \"Пущино\", mapCenter: [54.78929269708931,37.64268598670033]}, \r\n    {name: \"Ватулино\", mapCenter: [55.663193308717396,36.14121807608322]}\r\n  ];\r\n\r\n  \r\n  var defaultZoom = 16;  \r\n  var map = new ymaps.Map(\"map\", {\r\n      center: dz[0].mapCenter,    \r\n      zoom: defaultZoom\r\n    },\r\n    {\r\n      suppressMapOpenBlock: true  // remove button 'open in yandex maps'\r\n    }    \r\n  );\r\n  \r\n  map.setType(\"yandex#satellite\");  // view from space    \r\n  map.cursors.push('arrow');  \r\n  map.controls.remove('trafficControl');  \r\n  map.controls.remove('zoomControl');\r\n  var zoomControl = new ymaps.control.ZoomControl({options: { \r\n    position: { right: 10, top: 105 }, \r\n    size: 'small'\r\n  }}); \r\n  map.controls.add(zoomControl);\r\n  map.controls.remove('geolocationControl');\r\n  map.controls.remove('fullscreenControl');   \r\n   \r\n  var searchControl = map.controls.get('searchControl');\r\n  searchControl.options.set('size', 'small');\r\n  searchControl.options.set('noPlacemark', true);\r\n  searchControl.options.set('noSelect', true);\r\n  \r\n  \r\n  ymaps.modules.require([\r\n    'Wind', \r\n    'Chute',\r\n    'Path',    \r\n    'Calculator', \r\n    'Arrow'\r\n  ]).spread(function (\r\n\r\n    Wind, \r\n    Chute,\r\n    Path,      \r\n    Calculator, \r\n    Arrow\r\n  ) {\r\n    \r\n    var wind = new Wind(5, 0);     // West wind, 5 m/sec      \r\n    var chute = new Chute(10, 5);  // Chute velocity = (10, 5) m/s\r\n    var path = new Path(map, isMobile); \r\n    \r\n    var startHeight = 300;   // meters\r\n    \r\n    var calculator = new Calculator(path, wind, chute, startHeight);      \r\n\r\n    \r\n    // Height output \r\n    var heightOutput = createOutputControlElement();      \r\n    heightOutput.print = function(height) {\r\n      if (height.length > 0) {      \r\n        if ((height.length == path.length) || \r\n            (path.length == 0)) {               \r\n          heightOutput.data.set(\"content\", \r\n                                \"Высота: \" + Math.floor(height[height.length - 1]) + \" м\");\r\n        } else {                               \r\n          heightOutput.data.set(\"content\", \"Невозможно!\");\r\n        }\r\n      }      \r\n    }\r\n    \r\n    heightOutput.print([startHeight]);        \r\n    map.controls.add(heightOutput, {float: 'left'});\r\n\r\n  \r\n    map.events.add('click', function(e) {\r\n      var point = e.get('coords');\r\n      \r\n      var [lastVertex, lastLine] = path.addVertex(point);\r\n            \r\n      if (lastLine != null) {\r\n        lastLine.events.add('click', \r\n                            processLineClick(lastLine));\r\n      }\r\n\r\n      function processLineClick(lastLine) {\r\n        return (function(e) {\r\n          e.stopPropagation();          \r\n          var point = e.get('coords');\r\n          var [vertex, prevLine, nextLine] = path.divideLine(lastLine, point);\r\n\r\n          vertex.events.add('click', \r\n                            processVertexClick(vertex)); \r\n          \r\n          vertex.events.add('dblclick', function(e) {\r\n            e.stopPropagation();  // remove standart map zoom for double click\r\n          });\r\n                                                           \r\n          vertex.events.add('drag', \r\n                              processVertexDrag(vertex));                             \r\n                              \r\n          prevLine.events.add('click', \r\n                      processLineClick(prevLine));                    \r\n\r\n          nextLine.events.add('click', \r\n                              processLineClick(nextLine));\r\n\r\n          var height = calculator.calculateHeight();\r\n          path.printHeightHints(height);       \r\n          heightOutput.print(height);                                                            \r\n        });\r\n      }\r\n\r\n      lastVertex.events.add('click', \r\n                            processVertexClick(lastVertex));      \r\n\r\n      // Process both click and dblclick                      \r\n      function processVertexClick(lastVertex) {\r\n        var clickNumber = 0;\r\n        var placemarkIsShown = true;\r\n        return (function(e) {\r\n          e.stopPropagation();  // remove standart zoom for click\r\n          clickNumber++;\r\n          if (clickNumber == 1) {\r\n            setTimeout(function() {  \r\n              if (clickNumber == 1) {  // Single Click\r\n                placemarkIsShown = !placemarkIsShown;\r\n                \r\n                if (placemarkIsShown) {\r\n                  map.geoObjects.add(lastVertex.heightPlacemark);\r\n                } else {\r\n                  map.geoObjects.remove(lastVertex.heightPlacemark);                  \r\n                }\r\n                                \r\n                clickNumber = 0;\r\n              } else {  // Double Click               \r\n                var newLine = path.removeVertex(lastVertex);\r\n                if (newLine != null) {\r\n                  newLine.events.add('click', \r\n                                  processLineClick(newLine));       \r\n                }\r\n                var height = calculator.calculateHeight();\r\n                path.printHeightHints(height);       \r\n                heightOutput.print(height);     \r\n               \r\n              }  \r\n            }, 200);\r\n          }  \r\n        });\r\n      } \r\n     \r\n      lastVertex.events.add('dblclick', function(e) {\r\n        e.stopPropagation();  // remove standart map zoom for double click\r\n      });\r\n                   \r\n      lastVertex.events.add('drag', \r\n                            processVertexDrag(lastVertex)); \r\n\r\n      function processVertexDrag(lastVertex) {\r\n        return (function(e) {\r\n          e.stopPropagation();          \r\n          path.dragVertex(lastVertex);\r\n          var height = calculator.calculateHeight();\r\n          path.printHeightHints(height);       \r\n          heightOutput.print(height);          \r\n        });\r\n      }\r\n      \r\n      var height = calculator.calculateHeight();\r\n      path.printHeightHints(height);       \r\n      heightOutput.print(height);        \r\n    });\r\n \r\n          \r\n    // Wind output  \r\n    var windOutput = createOutputControlElement();\r\n    windOutput.print = function(wind) {        \r\n      this.data.set(\"content\", \"Ветер: \" + \r\n        wind.value + \" м/с, \" + wind.getDirection());        \r\n    }\r\n    windOutput.print(wind);\r\n    map.controls.add(windOutput, {float: 'left'}); \r\n    \r\n    // Windsock creation\r\n    var arrow = new Arrow(map.getCenter(), isMobile);        \r\n    map.geoObjects.add(arrow);      \r\n    map.events.add('boundschange', function (e) {\r\n      var newZoom = e.get('newZoom'),\r\n            oldZoom = e.get('oldZoom');\r\n      if (newZoom != oldZoom) {\r\n        arrow.changeSize(newZoom);\r\n      }\r\n    });\r\n    \r\n      \r\n    // Only one button can be pressed at once\r\n    // pressedButton is currently pressed button\r\n    var pressedButton = null;\r\n    \r\n    // Clear Button\r\n    var clearButton = createButtonControlElement(\"Очистить\", \"images/icon_eraser.svg\");\r\n    clearButton.events.add(\"click\", function() {\r\n      path.clear();\r\n      heightOutput.print([startHeight]);\r\n    });\r\n    \r\n    // DzStartHeight Button\r\n    var dzHeightButton = createButtonControlElement(\"Настройки\", \"images/icon_settings.svg\");\r\n    connectButtonToWindow(dzHeightButton, \"#dzHeightMenu\");  \r\n\r\n    // DzStartHeight Window initialization \r\n    for(var i=0; i<dz.length; i++) {\r\n      $(\"#dz\").append(\"<option>\" + dz[i].name + \"</option>\");    \r\n    }  \r\n    $(\"#dz\").on(\"change\", function() {\r\n      var mapCenter = dz[this.selectedIndex].mapCenter;      \r\n      map.setCenter(mapCenter, defaultZoom); \r\n      arrow.geometry.setCoordinates(mapCenter);\r\n      path.clear();\r\n      heightOutput.print([startHeight]);\r\n    });\r\n    \r\n    $(\"#startHeight\").val(startHeight); \r\n    \r\n    $(\"#startHeight\").on(\"change\", function () {       \r\n      var s = $(\"#startHeight\").val();\r\n      var n = Number.parseFloat(s);\r\n      if ((n >= 4) && (n <= 4000)) {\r\n        startHeight = n;      \r\n      }\r\n      $(\"#startHeight\").val(startHeight);\r\n\r\n      calculator.setStartHeight(startHeight);      \r\n      printHeight(calculator.calculateHeight());            \r\n    });  \r\n        \r\n    // Chute Button\r\n    var chuteButton = createButtonControlElement(\"Настройки парашюта\", \"images/icon_chute.svg\");\r\n    connectButtonToWindow(chuteButton, \"#chuteMenu\");\r\n\r\n    // Chute menu initialization\r\n    $(\"#chutehorvel\").val(chute.horizontalVel);\r\n    $(\"#chutevervel\").val(chute.verticalVel);\r\n\r\n    /**\r\n     * Change Chute velocity in Chute Window.\r\n     */     \r\n    $(\"#chutehorvel, #chutevervel\").on(\"change\", function () {      \r\n      var chutehorvel = Number.parseFloat($(\"#chutehorvel\").val());\r\n      if ((chutehorvel>=0) && (chutehorvel<=25)) {\r\n        chute.horizontalVel = chutehorvel;\r\n      }\r\n      $(\"chutehorvel\").val(chute.horizontalVel);\r\n            \r\n      var chutevervel = Number.parseFloat($(\"#chutevervel\").val());\r\n      if (( chutevervel>=0) && (chutevervel<=50)) {\r\n        chute.verticalVel = chutevervel;    \r\n      } \r\n      $(\"#chutevervel\").val(chute.verticalVel);        \r\n      \r\n      printHeight(calculator.calculateHeight());\r\n    }); \r\n        \r\n    // Help Button\r\n    var helpButton = createButtonControlElement(\"Справка\", \"images/icon_help.svg\");\r\n    connectButtonToWindow(helpButton, \"#helpMenu\");\r\n\r\n    // Wind Button\r\n    var windButton = createButtonControlElement(\"Настройка ветра\", \"images/icon_arrow.svg\");  \r\n    connectButtonToWindow(windButton, \"#windMenu\");\r\n\r\n    // Draw scales for Wind Window    \r\n    drawWindScales(); \r\n      \r\n    $(\"#windDirectionInput\").val(wind.angle);\r\n    $(\"#windValueInput\").val(wind.value);\r\n    \r\n    /**\r\n     * Change Wind Direction in Wind Window.\r\n     */    \r\n    $(\"#windDirectionInput\").on('input change', function() {\r\n      var angleStr = $(\"#windDirectionInput\").val();          \r\n      var angle = Number.parseInt(angleStr);\r\n      arrow.rotate(angle);\r\n      wind.angle = angle;\r\n      var height = calculator.calculateHeight();            \r\n      printWindHeight(wind, height);      \r\n    });\r\n\r\n    /**\r\n     * Change Wind Value in Wind Window.\r\n     */     \r\n    $(\"#windValueInput\").on('input change', function() {\r\n      var valueStr = $(\"#windValueInput\").val();\r\n      var value = Number.parseInt(valueStr);    \r\n      wind.value = value;\r\n      var height = calculator.calculateHeight();       \r\n      printWindHeight(wind, height);\r\n    });\r\n\r\n    \r\n    // To loose focus after pressing Enter on <input>\r\n    // This is for dzHeightMenu and chuteMenu  \r\n    $(\"input\").keypress(function(e) {\r\n      if (e.keyCode === 13) {  // Enter keycode\r\n        $(\"input\").blur();     // Forced loose of focus\r\n      }    \r\n    });    \r\n    \r\n    \r\n    /**\r\n     * Change Wind by keyboard.\r\n     */\r\n    $(\"html\").keydown(function(e) { \r\n      var key = e.which;\r\n      switch(key) {\r\n        case 39: \r\n          wind.angle += 5;\r\n          if (wind.angle > 180) { \r\n            wind.angle = -180 + (wind.angle - 180);\r\n          }  \r\n          arrow.rotate(wind.angle);\r\n          $(\"#windDirectionInput\").val(wind.angle);\r\n          var height = calculator.calculateHeight(); \r\n          printWindHeight(wind, height);             \r\n          break;\r\n        case 37: \r\n          wind.angle -= 5;\r\n          if (wind.angle < -180) {\r\n            wind.angle = 180 - (-180 - wind.angle);\r\n          }  \r\n          arrow.rotate(wind.angle);\r\n          $(\"#windDirectionInput\").val(wind.angle);\r\n          var height = calculator.calculateHeight(); \r\n          printWindHeight(wind, height);            \r\n          break;\r\n        case 38: \r\n          wind.value++;\r\n          if (wind.value > 10) wind.value = 10;\r\n          $(\"#windValueInput\").val(wind.value);\r\n          var height = calculator.calculateHeight(); \r\n          printWindHeight(wind, height);            \r\n          break;\r\n        case 40: \r\n          wind.value--;\r\n          if (wind.value < 0) wind.value = 0;\r\n          $(\"#windValueInput\").val(wind.value);\r\n          var height = calculator.calculateHeight(); \r\n          printWindHeight(wind, height);            \r\n          break;\r\n      }              \r\n    });   \r\n\r\n    // Adding Buttons to Map.  \r\n    map.controls.add(dzHeightButton, {position: {top: 45, left: 10}});\r\n    map.controls.add(chuteButton, {position: {top: 75, left: 10}});\r\n    map.controls.add(windButton, {position: {top: 105, left: 10}});\r\n    map.controls.add(helpButton, {position: {top: 135, left: 10}});   \r\n    map.controls.add(clearButton, {position: {top: 165, left: 10}});\r\n\r\n\r\n    searchControl.events.add('resultshow', function(e) {\r\n      path.clear();\r\n      heightOutput.print([startHeight]);\r\n     \r\n      map.setZoom(defaultZoom);\r\n\r\n      arrow.geometry.setCoordinates(map.getCenter());\r\n       \r\n      var index = e.get('index');    \r\n      var geoObjectsArray = searchControl.getResultsArray();\r\n      var resultName = geoObjectsArray[index].properties.get('name');\r\n\r\n      var newDz = {\r\n        name: resultName, \r\n        mapCenter: map.getCenter()\r\n      };    \r\n      dz.push(newDz);    \r\n      $(\"#dz\").append(\"<option>\" + newDz.name + \"</option>\");    \r\n      $(\"#dz\").children()[dz.length - 1].selected = true;    \r\n    });\r\n\r\n    \r\n    /**\r\n     * Template for Output Windows.\r\n     * @param {string} content - output data.\r\n     * @return {ymaps.control.Button} outputElement       \r\n     */\r\n    function createOutputControlElement(content = '') {\r\n      \r\n      var outputElement = new ymaps.control.Button({\r\n        data: {content: content},  \r\n          \r\n        options: {\r\n          layout: ymaps.templateLayoutFactory.createClass(\r\n            \"<div class='outputControlElement'>{{data.content}}</div>\"\r\n          ),\r\n         maxWidth: 300 \r\n        }\r\n      });      \r\n      return outputElement;\r\n    }\r\n\r\n    function printHeight(height) {\r\n      path.printHeightHints(height);       \r\n      heightOutput.print(height);       \r\n    }    \r\n        \r\n    function printWindHeight(wind, height) {\r\n      windOutput.print(wind);\r\n      path.printHeightHints(height);       \r\n      heightOutput.print(height)\r\n    }  \r\n\r\n\r\n    /**\r\n     * Template for Menu Buttons.\r\n     * @param {string} title - button hint.\r\n     * @param {string} image - button icon.\r\n     * @param {string} cssclass - button css.     \r\n     * @return {ymaps.control.Button} inputElement       \r\n     */    \r\n    function createButtonControlElement(title='', \r\n                                        image='', \r\n                                        cssclass='inputControlElement') {\r\n      var inputElement = new ymaps.control.Button({\r\n        data: {\r\n          title: title,\r\n          image: image, \r\n          cssclass: cssclass        \r\n        },  \r\n        options: {\r\n          layout: ymaps.templateLayoutFactory.createClass(\r\n            \"<div title='{{data.title}}' class='{{data.cssclass}}'>\" + \r\n              \"<img class='iconimage' src='{{data.image}}'>\" +           \r\n            \"</div>\"\r\n          ),\r\n          maxWidth: 300\r\n        }\r\n      });      \r\n      return inputElement;\r\n    }      \r\n\r\n\r\n    /**\r\n     * Connect Menu Buttons to Output Html Windows:\r\n     *   when you press the button, the window will be shown, \r\n     *   when you press again - it will disapear.\r\n     * @param {ymaps.control.Button} currentButton\r\n     * @param {string} windowjQuerySelector - jQuery selector for Window.\r\n     */\r\n    function connectButtonToWindow(currentButton, windowjQuerySelector) {\r\n      currentButton.windowIsOn = false;\r\n      currentButton.windowjQuerySelector = windowjQuerySelector;  \r\n      \r\n      currentButton.events.add(\"click\", function() {\r\n        currentButton.windowIsOn = !currentButton.windowIsOn;\r\n        if (currentButton.windowIsOn) {\r\n          $(windowjQuerySelector).show();      \r\n          arrow.geometry.setCoordinates(map.getCenter());\r\n          currentButton.data.set('cssclass', 'pressedInputControlElement');\r\n\r\n          if ((pressedButton != null) && (pressedButton != currentButton)) {\r\n            turnOffButton(pressedButton);\r\n          }\r\n          pressedButton = currentButton;        \r\n        } else {\r\n          turnOffButton(currentButton);\r\n          pressedButton = null;        \r\n        }   \r\n      });\r\n          \r\n      // Cross closing of window element\r\n      $(windowjQuerySelector + \"Rectangle\").click(function() {\r\n        turnOffButton(currentButton);  \r\n        pressedButton = null;      \r\n      });\r\n    }\r\n    \r\n    /**\r\n     * Auxiliary function for connectButtonToWindow function. \r\n     * It responds for turning off button and corresponding window.\r\n     */     \r\n    function turnOffButton(turningOffButton) {\r\n      $(turningOffButton.windowjQuerySelector).hide();\r\n      turningOffButton.windowIsOn = false;\r\n      turningOffButton.data.set('cssclass', 'inputControlElement');\r\n    }  \r\n    \r\n\r\n    /**\r\n     * Draw scales for Wind Window:\r\n     *   wind direction scale (E, N, W, S, E),\r\n     *   wind velocity scale (0, ..., 10 m/s)\r\n     */\r\n    function drawWindScales() {\r\n      // Create legend for direction range input\r\n      var directionPlateSpan = 5;\r\n      var directionPlateNumber = 4*directionPlateSpan + 1;\r\n\r\n      for(var i=0; i<directionPlateNumber; i++) {\r\n        var str = \"\";\r\n        switch (i) {\r\n          case 0: \r\n            str = \"В\";\r\n            break;\r\n          case directionPlateSpan: \r\n            str = \"С\";\r\n            break;\r\n          case directionPlateSpan*2: \r\n            str = \"З\";\r\n            break;      \r\n          case directionPlateSpan*3: \r\n            str = \"Ю\";\r\n            break;\r\n          case directionPlateSpan*4: \r\n            str = \"В\";\r\n            break;\r\n          default:\r\n            str = \"&nbsp\";          \r\n        }\r\n        $(\"#windDirectionInputScale\").append(\"<div class='directionPlate'>\" + str + \"</div>\");                \r\n      }\r\n      $(\".directionPlate\").css({\r\n        \"width\": 100/(directionPlateNumber) + \"%\",\r\n        \"float\": \"left\", \r\n        \"text-align\": \"center\"\r\n      });\r\n\r\n      // Create legend for value range input\r\n      var maxWindVelocity = 10;\r\n      for(var i=0; i<maxWindVelocity + 1; i++) {    \r\n        $(\"#windValueInputScale\").append(\"<div class='valueScale' id='v\" + i + \"'>\" + i + \"</div>\");\r\n      }\r\n\r\n      $(\".valueScale\").css({\r\n        \"width\": 100/(maxWindVelocity + 0.38) + \"%\",\r\n        \"float\": \"left\",\r\n        \"text-align\": \"left\"\r\n      });\r\n\r\n      $(\"#v\" + (maxWindVelocity - 1)).css({\r\n        \"width\": 100/(maxWindVelocity*2) + \"%\"\r\n      }); \r\n\r\n      $(\"#v\" + maxWindVelocity).css({\r\n        \"width\": 100/(maxWindVelocity*1.25) + \"%\",\r\n        \"float\": \"left\",\r\n        \"text-align\": \"right\"\r\n      });  \r\n    }  \r\n  \r\n  });      \r\n}\n\n//# sourceURL=webpack:///./src/scripts/index.js?");

/***/ }),

/***/ 0:
/*!**********************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/scripts/Arrow.js ./src/scripts/Calculator.js ./src/scripts/Chute.js ./src/scripts/index.js ./src/scripts/Path.js ./src/scripts/Wind.js ./src/scripts/YmapsCircleVertex.js ./src/scripts/YmapsTriangleVertex.js ***!
  \**********************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/scripts/Arrow.js */\"./src/scripts/Arrow.js\");\n__webpack_require__(/*! ./src/scripts/Calculator.js */\"./src/scripts/Calculator.js\");\n__webpack_require__(/*! ./src/scripts/Chute.js */\"./src/scripts/Chute.js\");\n__webpack_require__(/*! ./src/scripts/index.js */\"./src/scripts/index.js\");\n__webpack_require__(/*! ./src/scripts/Path.js */\"./src/scripts/Path.js\");\n__webpack_require__(/*! ./src/scripts/Wind.js */\"./src/scripts/Wind.js\");\n__webpack_require__(/*! ./src/scripts/YmapsCircleVertex.js */\"./src/scripts/YmapsCircleVertex.js\");\nmodule.exports = __webpack_require__(/*! ./src/scripts/YmapsTriangleVertex.js */\"./src/scripts/YmapsTriangleVertex.js\");\n\n\n//# sourceURL=webpack:///multi_./src/scripts/Arrow.js_./src/scripts/Calculator.js_./src/scripts/Chute.js_./src/scripts/index.js_./src/scripts/Path.js_./src/scripts/Wind.js_./src/scripts/YmapsCircleVertex.js_./src/scripts/YmapsTriangleVertex.js?");

/***/ })

/******/ });